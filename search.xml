<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HUST_CS_系统基础整理</title>
    <url>/2024/07/06/HUST-CS-%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-1-数值数据的表示"><a href="#2-1-数值数据的表示" class="headerlink" title="2.1 数值数据的表示"></a>2.1 数值数据的表示</h2><ul>
<li>带有正负号的数叫做真值</li>
<li>编码后的数值数据都叫机器数</li>
<li>原码方便乘除法</li>
<li>补码方便条件判断指令和带条件跳转指令的执行</li>
<li>移码的还原得到真值的方式$E&#x3D;[E]_{move}-bias$</li>
</ul>
<h2 id="2-3-浮点数的表示"><a href="#2-3-浮点数的表示" class="headerlink" title="2.3 浮点数的表示"></a>2.3 浮点数的表示</h2><blockquote>
<ul>
<li>阶码的位数影响浮点数表示范围</li>
<li>尾数的位数决定有效位数,影响精度</li>
<li>是否规格化也会影响浮点数的精度,非规格化可以让浮点数在靠近0的部分精度更高一点</li>
</ul>
</blockquote>
<h4 id="IEEE-754标准的浮点数"><a href="#IEEE-754标准的浮点数" class="headerlink" title="IEEE 754标准的浮点数"></a>IEEE 754标准的浮点数</h4><p>s:符号位,Exponent:阶码(8&#x2F;11),significand:尾数(23&#x2F;52)<br>$$ SP:(-1)^S \times (1+significand) \times 2^{(exponent-127)}$$<br>$$ DP:(-1)^S \times (1+significand) \times 2^{(exponent-1023)}$$</p>
<ul>
<li>+0: 符号位0,阶码0,尾数0</li>
<li>-0: 符号位1,阶码0,尾数0</li>
<li>非规范数: 符号位根据真值,阶码0,尾数不为0</li>
<li>无穷大:符号位看正负,阶码全1,尾数全0</li>
<li>Nan:符号位无所谓,阶码全1,尾数非0<ul>
<li>尾数最高有效位为1,定义不发信号的Nan,不进行一场处理</li>
<li>尾数最高有效位为0,定义为发信号的Nan,因为Nan尾数的剩下位没有被定义,所以可以自定义余位指定具体的一异常事件</li>
</ul>
</li>
</ul>
<h2 id="2-6-数据的宽度和存储"><a href="#2-6-数据的宽度和存储" class="headerlink" title="2.6 数据的宽度和存储"></a>2.6 数据的宽度和存储</h2><ul>
<li>数据的宽度和单位<ul>
<li>位:bit,</li>
<li>字节:Byte,最小可寻址单位</li>
<li>字:WORD,一个字等于2个字节,16位</li>
<li>双字:DWORD,一个双字为两个字宽度,4字节,32位</li>
<li>四字:QWORD,一个四字位四个字宽度,8字节,64位</li>
</ul>
</li>
<li>“字长”<ul>
<li>字长是CPU内部用于整数运算的数据通路的宽度</li>
<li><strong>字</strong>:表示被处理的信息的单位,用来度量各种数据类型的宽度</li>
</ul>
</li>
</ul>
<p>字和字长可以有不同的大小,如IA-32中字位16位,字长位32位</p>
<ul>
<li>数据的存储和排列顺序<ul>
<li>大端存储</li>
<li>小端存储</li>
</ul>
</li>
</ul>
<h2 id="2-7-数据的运算"><a href="#2-7-数据的运算" class="headerlink" title="2.7 数据的运算"></a>2.7 数据的运算</h2><h4 id="移位运算的溢出判断"><a href="#移位运算的溢出判断" class="headerlink" title="移位运算的溢出判断"></a>移位运算的溢出判断</h4><ul>
<li>逻辑移位:若逻辑左移移出的位包含1,则溢出</li>
<li>算数移位:若算数座移后的符号位不同于以前的符号位,则溢出</li>
</ul>
<h3 id="4-整数加减运算"><a href="#4-整数加减运算" class="headerlink" title="4. 整数加减运算"></a>4. 整数加减运算</h3><h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><ul>
<li><code>ZF</code>:零标志,如果结果为0,<code>ZF</code>置1,否则为0</li>
<li><code>OF</code>:溢出标志.只对带符号整数有效,只对“正+正”和“负+负”考虑;否则<code>OF</code>&#x3D;0</li>
<li><code>SF</code>:符号标志,只对带符号整数有效  表示带符号整数加减运算结果的符号位,<code>SF</code>&#x3D;结果的最高位</li>
<li><code>CF</code>:加减运算时的进&#x2F;借位标志,只对无符号整数有效.<code>CF</code>&#x3D;1,表示无符号整数加法溢出或减法“不够减”,$CF&#x3D;C_{out}\oplus Sub$</li>
</ul>
<p><em>思考</em>:为什么<code>CF</code>不能用于带符号数判断溢出:<br>因为<code>CF=1</code>对有符号数而言可能是期望的溢出以实现模运算,比如$2+-1&#x3D;1$不溢出!</p>
<h4 id="溢出的考虑"><a href="#溢出的考虑" class="headerlink" title="溢出的考虑"></a>溢出的考虑</h4><ul>
<li>带符号整数加法溢出:<ul>
<li>符号相反一定不会溢出</li>
<li>符号相同可能溢出,当结果符号于加数符号不同时溢出</li>
</ul>
</li>
<li>带符号整数减法溢出:<ul>
<li>符号相同一定不会溢出</li>
<li>符号想法可能溢出.正数-负数发声的溢出成为正溢出</li>
</ul>
</li>
</ul>
<h3 id="5-整数的乘运算"><a href="#5-整数的乘运算" class="headerlink" title="5. 整数的乘运算"></a>5. 整数的乘运算</h3><p>乘法指令本身不判断溢出,在机器级乘法指令的操作数长度为n时,虽然获得了2n位的乘积结果,但是只有低n位共软件使用,高n位通常作为溢出标志用于溢出判断<br>因为硬件不判断溢出,所以如果编译器不生成用于溢出处理的代码(C语言编译器就不生成)</p>
<h4 id="整数乘法溢出的判断"><a href="#整数乘法溢出的判断" class="headerlink" title="整数乘法溢出的判断"></a>整数乘法溢出的判断</h4><p>2n位乘积的高n位全0或全1,并且等于低n位的最高位时,不溢出–&gt;<br>乘积的高n+1位全0或全1不溢出(带符号整数乘法)<br>高位寄存器中的每一位都等于0(无符号整数乘法)</p>
<h3 id="6-整数的除运算"><a href="#6-整数的除运算" class="headerlink" title="6. 整数的除运算"></a>6. 整数的除运算</h3><h4 id="通过移位进行除法"><a href="#通过移位进行除法" class="headerlink" title="通过移位进行除法"></a>通过移位进行除法</h4><p><strong>朝零舍入原则</strong></p>
<ul>
<li>对于无符号数或带符号正整数,移出的低位直接丢弃,结果正确</li>
<li>对于带符号负整数,如果需要除以$2^k$,需要先加偏移量$(2^k-1)$,然后再右移k位(除以$2^k$),进行低位截断</li>
</ul>
<p><strong>不饿能用右移代替除法的情况</strong>：<br>$-1 \div 2$<br>因为$-1$本身已经全部都是$1_2$了，所以右移后仍然是$-1$，但是理论上应该变成$0$的。</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="IA-32寻址方式"><a href="#IA-32寻址方式" class="headerlink" title="IA-32寻址方式"></a>IA-32寻址方式</h2><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><ul>
<li>操作数直接放在指令中,在指令的操作码后</li>
<li>操作数时指令的一部分,位于代码段中</li>
<li>指令中的操作数是8位、16位或32位二进制数</li>
</ul>
<p><strong>立即操作数只能作为源操作数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, 12H</span><br></pre></td></tr></table></figure>

<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>使用格式: <code>[R]</code></p>
<p>功能: 寄存器R中的内容即为操作数</p>
<p>说明: 除了个别指令外,R可以为任意寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dec bl</span><br></pre></td></tr></table></figure>
<h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><ul>
<li>操作数在内存中</li>
<li>操作数的便宜地址EA紧跟在指令操作吗后面</li>
</ul>
<p>格式:<code>[地址偏移量]</code>或者<code>段寄存器:[n]</code></p>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>格式: <code>[R]</code></p>
<p>功能:操作数在内存中,操作数的偏移地址在寄存器R中.即<code>(R)</code>为操作数的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, [esi]</span><br></pre></td></tr></table></figure>
<ul>
<li>R可以是8个32位通用寄存器中的任意一个</li>
<li>操作数的偏移地址在指令指明的寄存器中</li>
<li>操作数所载的段:<ul>
<li>扁平内存管理模式下,<code>(DS)=(SS)</code></li>
</ul>
</li>
</ul>
<h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>格式: <code>V[R * F]</code></p>
<p>功能: R中的内容*F+V为操作数的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al, 5[ebx*2]</span><br></pre></td></tr></table></figure>
<ul>
<li>R可以是8个32位通用寄存器</li>
<li>F可以是1,2,4,8</li>
</ul>
<h3 id="基址加变址寻址"><a href="#基址加变址寻址" class="headerlink" title="基址加变址寻址"></a>基址加变址寻址</h3><p>格式:<code>[BR+IR*F+V]</code>或<code>V[BR][IR*F]</code>或<code>V[IR*F][BR]</code>或<code>V[BR+IR*F]</code></p>
<p>功能: 操作数的偏移&#x3D;变址寄存器 IR中的内容*比例因子F+位移量V+基址寄存器BR中的内容<br><code>EA = (IR)*F+v+(BR)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax, -6[edi*2][ebp]</span><br></pre></td></tr></table></figure>
<ul>
<li>F可为1,2,4,8</li>
<li>当使用32位寄存器时,可以是8个通用寄存器之一</li>
<li>IR可以是除了ESP外的任意32位寄存器</li>
<li>没有携带比例因子的寄存器是BR</li>
<li>当没有比例因子时,写载前面的寄存器就是BR</li>
</ul>
<h2 id="AT-T汇编语言格式"><a href="#AT-T汇编语言格式" class="headerlink" title="AT&amp;T汇编语言格式"></a>AT&amp;T汇编语言格式</h2><ul>
<li>长度后缀:b(字节)、w(字)、l(双字)、q(四字)</li>
<li>寄存器操作数: %寄存器名称</li>
<li>存储器操作数: 偏移量(基址寄存器,变址寄存器,比例因子)</li>
<li>汇编指令格式: <code>op src, dst</code>,即<code>dst &lt;- dst op src</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 8(%ebp, %esi, 4), %eax</span><br><span class="line">寻址方式是:</span><br><span class="line">基址(%ebp)+比例变址(4*%esi)+位移(8)</span><br><span class="line">它的存储器操作数的有效地址=%ebp+%esi*4+8</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="IA-32指令"><a href="#IA-32指令" class="headerlink" title="IA-32指令"></a>IA-32指令</h2><h4 id="PUSH-POP"><a href="#PUSH-POP" class="headerlink" title="PUSH&#x2F;POP"></a>PUSH&#x2F;POP</h4><p>入栈&#x2F;出栈,操作对象都是ESP或SP寄存器指向的栈单元<br><code>push</code>先执行<code>R[esp]&lt;-R[esp]-4</code>,然后将制定寄存器内容送到ESP寄存器指向的栈单元<br><code>pop</code>先将ESP寄存器指向的栈单元送到指定寄存器中,然后再执行<code>R[esp]&lt;-R[esp]+4</code></p>
<h4 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h4><p>lea,加载有效地址,将源操作数作为存储地址送到目的寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea (%edx,%eax), %eax</span><br><span class="line">R[eax]&lt;-R[edx]+R[eax]</span><br><span class="line">对比mov指令!!</span><br><span class="line">mov (%edx, %eax), %eax</span><br><span class="line">R[eax]&lt;-M[R[edx]+R[eax]]</span><br></pre></td></tr></table></figure>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul>
<li>无条件转移指令<br> JMP DST: 无条件调转到目标指令DST处执行</li>
<li>条件转移<br> Jcc DST: cc为条件码,根据标志(条件码)判断是否满足条件,若满足,啧转移到目标指令DST处执行,否则按顺序执行</li>
<li>调用和返回指令<br>CALL DST: 将返回地址(程序计数器EIP到值,也就是CALL指令到吓一跳指令所在的地址)入栈,然后跳转到指定地址DST处执行.显然会修改ESP的值<br>RET: 从栈顶取出返回地址到程序计数器EIP,从而跳转到返回地址继续执行,显然也修改ESP的值</li>
</ul>
<h2 id="常用指令详解"><a href="#常用指令详解" class="headerlink" title="常用指令详解"></a>常用指令详解</h2><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><ol>
<li>一般数据传送指令<br><code>mov</code>,<code>movsx</code>,<code>movzx</code></li>
<li>堆栈操作指令<br><code>push</code>,<code>pop</code>,<code>pusha</code>,<code>pushad</code>,<code>popa</code>,<code>popad</code></li>
<li>标志寄存器传送指令<br><code>pushf</code>,<code>popf</code>,<code>pushfd</code>,<code>popfd</code>,<code>lahf</code>,<code>sahf</code></li>
<li>地址传送指令<br><code>lea</code></li>
<li>带条件的数据传送指令<br><code>cmove</code>,<code>cmovne</code>,<code>cmova</code> …</li>
</ol>
<h4 id="带条件的数据传送指令"><a href="#带条件的数据传送指令" class="headerlink" title="带条件的数据传送指令"></a>带条件的数据传送指令</h4><p>使用单个标志位判断转移条件是否成立</p>
<table>
<thead>
<tr>
<th align="left">cmove&#x2F;cmovz</th>
<th align="left">cmovc</th>
<th align="left">cmovs</th>
<th align="left">cmovo</th>
<th align="left">cmovp</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZF&#x3D;1</td>
<td align="left">CF&#x3D;1</td>
<td align="left">SF&#x3D;1</td>
<td align="left">OF&#x3D;1</td>
<td align="left">PF&#x3D;1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">cmovne&#x2F;cmovnz</th>
<th align="left">cmovnc</th>
<th align="left">cmovns</th>
<th align="left">cmovno</th>
<th align="left">cmovnp</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZF&#x3D;0</td>
<td align="left">CF&#x3D;0</td>
<td align="left">SF&#x3D;0</td>
<td align="left">OF&#x3D;0</td>
<td align="left">PF&#x3D;0</td>
</tr>
</tbody></table>
<p>使用多个标志位组合判断转移条件是否成立:<br><code>cmova</code>,<code>cmovb</code>,<code>cmovg</code>,<code>cmovl</code>….</p>
<h4 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h4><ol>
<li>进栈指令<code>push ops</code><br>双字数据入栈:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(ESP)-4 -&gt; ESP</span><br><span class="line">双字数据 -&gt; [ESP]</span><br></pre></td></tr></table></figure></li>
<li>出栈指令 <code>pop opd</code><br>字数据出栈<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">([ESP]) -&gt; OPD</span><br><span class="line">(ESP)+2 -&gt; ESP</span><br></pre></td></tr></table></figure>
双字数据出栈类似,<code>(ESP)+4 -&gt; ESP</code></li>
</ol>
<blockquote>
<p>8个16位寄存器入栈 <code>pusha</code><br>8个16位寄存器出栈 <code>popa</code><br>8个32位寄存器入栈 <code>pushad</code><br>8个32位寄存器出栈 <code>popad</code></p>
<p>32位标志寄存器进栈 <code>pushfd</code>  将eflags进(esp)<br>32位标志寄存器出栈 <code>popfd</code>  将栈顶内容弹出送入标志寄存器中<br>16位标志寄存器进栈 <code>pushf</code>  将$eflags_{15-0}$进(esp)<br>16位标志寄存器出栈 <code>popf</code>  将栈顶内容弹出送入标志寄存器中  </p>
</blockquote>
<h4 id="地址传送指令-1"><a href="#地址传送指令-1" class="headerlink" title="地址传送指令"></a>地址传送指令</h4><p>传送偏移地址指令<br>语句格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea R32, M32</span><br></pre></td></tr></table></figure>
<p>功能: 将<code>M32</code>对应的地址送入<code>R32</code>中</p>
<h4 id="必须记住"><a href="#必须记住" class="headerlink" title="必须记住!"></a>必须记住!</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">指令</th>
<th align="left">操作数类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一般传送</td>
<td align="left">mov</td>
<td align="left">opd, ops</td>
</tr>
<tr>
<td align="left">有符号数传送</td>
<td align="left">movsx</td>
<td align="left">R16&#x2F;R32, OPS&#x2F;非立即数</td>
</tr>
<tr>
<td align="left">无符号数传送</td>
<td align="left">movzx</td>
<td align="left">R16&#x2F;R32, OPS&#x2F;非立即数</td>
</tr>
<tr>
<td align="left">传送偏移地址</td>
<td align="left">lea</td>
<td align="left">R32, M32</td>
</tr>
<tr>
<td align="left">进栈</td>
<td align="left">push</td>
<td align="left">ops</td>
</tr>
<tr>
<td align="left">出栈</td>
<td align="left">pop</td>
<td align="left">opd</td>
</tr>
<tr>
<td align="left">32位通用寄存器进栈、出栈</td>
<td align="left">pushad, popad</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">标志寄存器进栈、出栈</td>
<td align="left">pushfd, popfd</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><p><strong>以下都是intel格式的汇编哦</strong></p>
<h4 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h4><ol>
<li>自增指令<code>inc opd</code>: <code>(opd)+1 -&gt; opd</code></li>
<li>加指令<code>add opd, ops</code>: <code>(opd)+(ops) -&gt; opd</code></li>
<li>带进位加指令<code>adc opd, ops</code>: <code>(opd)+(ops)+cfg -&gt; opd</code></li>
</ol>
<h4 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h4><p><strong>所有的减法指令都是<code>dst-src</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dec opd</span><br><span class="line">neg opd</span><br><span class="line">sub opd, ops</span><br><span class="line">sbb opd, ops</span><br><span class="line">cmp opd, ops</span><br></pre></td></tr></table></figure>
<p><strong><code>cmp</code>指令的本质是<code>dst-src</code></strong></p>
<p><code>dec</code>对OF,SF,ZF,PF,AF有影响<br>其它指令对CF,OF,SF,ZF,PF,AF有影响</p>
<ol>
<li>自减指令<code>dec opd</code>: <code>(opd)-1</code> -&gt; <code>opd</code></li>
<li>求补指令<code>neg opd</code>: <code>(opd)求反+1</code> -&gt; <code>opd</code></li>
<li>减指令<code>sub opd, ops</code>: <code>(opd)-(ops) -&gt; opd</code></li>
<li>带借位减指令<code>sbb opd, ops</code>: <code>(opd)-(ops)-cf -&gt; opd</code></li>
</ol>
<h4 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h4><ol>
<li>有符号乘法<ol>
<li>双操作数的有符号乘指令<code>imul opd, ops</code>: <code>(opd)*(ops) -&gt; opd</code></li>
<li>三操作数的有符号乘指令<code>imul opd, ops, n</code>: <code>(ops)*n -&gt; opd</code></li>
<li>单操作数的有符号乘法<code>imul ops</code>:<br>根据ops的不同,自动与eax的对应位做乘法<ol>
<li>字节乘法<code>(al)*(ops) -&gt; ax</code></li>
<li>字乘法<code>(ax)*(ops) -&gt; dx, ax</code></li>
<li>双字乘法<code>(eax)*(ops) -&gt; edx, eax</code></li>
</ol>
</li>
</ol>
</li>
<li>无符号乘法<code>mul ops</code>,同有符号单操作数乘法</li>
</ol>
<h4 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h4><ol>
<li>有符号除法<code>idiv ops</code>:<ol>
<li>字节除法<code>(ax)/(ops) -&gt; al(商), ah(余)</code></li>
<li>字除法<code>(dx, ax)/(ops) -&gt; ax(商), dx(余)</code></li>
<li>双字除法<code>(edx, eax)/(ops) -&gt; eax(商), edx(余)</code></li>
</ol>
</li>
<li>无符号除法<code>div ops</code> 同上</li>
</ol>
<p>使用除法的时候不仅要注意除数为0的问题,还要注意可能存在的除法溢出的问题!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(ax)=1234, (bl)=1, </span><br><span class="line">idiv bl就会出问题!!</span><br></pre></td></tr></table></figure>
<h4 id="符号扩展指令"><a href="#符号扩展指令" class="headerlink" title="符号扩展指令"></a>符号扩展指令</h4><ol>
<li>将字节转换成字<code>cbw</code>:<br>  将al中的符号扩展至ah中</li>
<li>将字转换成双字<code>cwd</code>:<br>  将ax中的符号扩展至dx中</li>
<li>将ax中的有符号数扩展为32位送eax<code>cwde</code></li>
<li>将eax中的有符号数扩展为64位数送edx, eax <code>cdq</code></li>
</ol>
<h4 id="按位运算指令"><a href="#按位运算指令" class="headerlink" title="按位运算指令"></a>按位运算指令</h4><ol>
<li>求反<code>not opd</code>: <code>~(opd) -&gt; opd</code></li>
<li>逻辑与<code>and opd, ops</code>: <code>(opd)&amp;(ops) -&gt; opd</code></li>
<li>测试指令<code>test opd, ops</code>: <code>opd&amp;(ops)</code></li>
<li>逻辑或<code>or opd, ops</code>: <code>(opd)|(ops) -&gt; opd</code></li>
<li>按位加<code>xor, opd, ops</code>: <code>(opd)^(ops) -&gt; opd</code></li>
</ol>
<h4 id="按位运算与逻辑运算"><a href="#按位运算与逻辑运算" class="headerlink" title="按位运算与逻辑运算"></a>按位运算与逻辑运算</h4><p><strong>似乎</strong>没有专门的逻辑运算相关的指令</p>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><ol>
<li>算数左移 <code>sal</code></li>
<li>逻辑左移 <code>shl</code></li>
<li>逻辑右移 <code>shr</code></li>
<li>算数右移 <code>sar</code></li>
</ol>
<h4 id="简单条件转移指令"><a href="#简单条件转移指令" class="headerlink" title="简单条件转移指令"></a>简单条件转移指令</h4><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>jz</code>&#x2F;<code>je</code></td>
<td align="left">ZF&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jnz</code>&#x2F;<code>jne</code></td>
<td align="left">ZF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>js</code></td>
<td align="left">SF&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jns</code></td>
<td align="left">SF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>jo</code></td>
<td align="left">OF&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jno</code></td>
<td align="left">OF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>jc</code></td>
<td align="left">CF&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jnc</code></td>
<td align="left">CF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>JP</code>&#x2F;<code>JPE</code></td>
<td align="left">pf&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jnp</code>&#x2F;<code>jpo</code></td>
<td align="left">PF&#x3D;0</td>
</tr>
</tbody></table>
<h4 id="无符号条件转移指令"><a href="#无符号条件转移指令" class="headerlink" title="无符号条件转移指令"></a>无符号条件转移指令</h4><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ja</code>&#x2F;<code>jnbe</code></td>
<td align="left">CF&#x3D;0 &amp;&amp; ZF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>jae</code>&#x2F;<code>jnb</code></td>
<td align="left">CF&#x3D;0 &amp;&amp; ZF&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jb</code>&#x2F;<code>jnae</code></td>
<td align="left">CF&#x3D;1 &amp;&amp; ZF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>jbe</code>&#x2F;<code>jna</code></td>
<td align="left">CF&#x3D;1 &amp;&amp; ZF&#x3D;1</td>
</tr>
</tbody></table>
<h4 id="有符号条件转移指令"><a href="#有符号条件转移指令" class="headerlink" title="有符号条件转移指令"></a>有符号条件转移指令</h4><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>jg</code>&#x2F;<code>jnle</code></td>
<td align="left">SF&#x3D;OF &amp;&amp; ZF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>jge</code>&#x2F;<code>jnl</code></td>
<td align="left">SF&#x3D;OF ||ZF&#x3D;1</td>
</tr>
<tr>
<td align="left"><code>jl</code>&#x2F;<code>jnge</code></td>
<td align="left">SF!&#x3D;OF &amp;&amp; ZF&#x3D;0</td>
</tr>
<tr>
<td align="left"><code>jle</code>&#x2F;<code>jng</code></td>
<td align="left">SF!&#x3D;OF ||ZF&#x3D;1</td>
</tr>
</tbody></table>
<h4 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h4><table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">名称</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>jmp</code>标号</td>
<td align="left">直接</td>
<td align="left">(EIP)+位移量-&gt;EIP</td>
</tr>
<tr>
<td align="left"><code>jmp</code> opd</td>
<td align="left">间接</td>
<td align="left">（OPD）-&gt; EIP</td>
</tr>
<tr>
<td align="left">间接转移方式中给，除了立即数寻址方式外，其它方式均可以使用</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><ol>
<li><code>loop</code> 标号：<br>(EXC)-1 -&gt; ECX，如果（ECX）不为0，则转标号处执行。<br>基本等价<code>dec ecx; jnz 标号</code>。*<code>loop</code>指令对标志位无影响*。</li>
<li><code>loope</code>&#x2F;<code>loopz</code> 标号：<br>(ECX)-1 -&gt; ECX，如果(ECX)!&#x3D;0，且ZF&#x3D;1，则转移标号处执行。<br>等于或为0循环转移指令，对标志位没有影响。</li>
<li><code>loo pne</code>&#x2F;<code>loopnz</code> 标号：<br>(ECX)-1 -&gt; ECX，若(ECX)!&#x3D;0,且ZF&#x3D;0，则转移到标号处执行。</li>
<li><code>jecxz</code> 标号：<br>若(ECX)&#x3D;&#x3D;0，则转移到标号处执行。<br>先判断，后执行循环体时，使用次语句。标号为循环结束处。</li>
</ol>
<h2 id="C语言程序的机器级表示"><a href="#C语言程序的机器级表示" class="headerlink" title="C语言程序的机器级表示"></a>C语言程序的机器级表示</h2><h3 id="IA-32中过程调用的存储区：栈"><a href="#IA-32中过程调用的存储区：栈" class="headerlink" title="IA-32中过程调用的存储区：栈"></a>IA-32中过程调用的存储区：栈</h3><p>在x86架构中，采用从高地址向低地址增长方式（栈底地址比栈顶地址大）</p>
<p>由于x86是小端排列，因此数据也是小端排列。<code>pushw %ax</code>之后，al的内容在栈顶。即al在低地址，ah在高地址。</p>
<h4 id="程序运行时的栈"><a href="#程序运行时的栈" class="headerlink" title="程序运行时的栈"></a>程序运行时的栈</h4><ul>
<li>auto局部变量存储在用户栈中。</li>
<li>malloc申请的空间在堆中。</li>
<li>static局部变量存放在静态数据区。</li>
<li>全局变量存放在静态数据区。</li>
</ul>
<ul>
<li>静态数据区的数据在整个程序执行期间都存在</li>
<li>栈中数据随着过程返回而清楚</li>
<li>堆中数据随着执行空间释放语句而清除。<br><img src="/../img/HUST_CS_%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/%E6%A0%881.png" alt="栈1"></li>
</ul>
<h4 id="IA-32的栈的结构"><a href="#IA-32的栈的结构" class="headerlink" title="IA-32的栈的结构"></a>IA-32的栈的结构</h4><p><img src="/../img/HUST_CS_%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/%E6%A0%882.png" alt="栈2"></p>
<h5 id="与栈相关的关键寄存器"><a href="#与栈相关的关键寄存器" class="headerlink" title="与栈相关的关键寄存器"></a>与栈相关的关键寄存器</h5><ul>
<li>EBP: 帧指针寄存器，指向当前栈帧的其实位置（栈底）</li>
<li>ESP:  栈指针寄存器，指向当前栈帧的顶部，值浮动</li>
<li>栈帧的范围：ESP~EBP之间的存储区域</li>
</ul>
<h5 id="栈的相关操作"><a href="#栈的相关操作" class="headerlink" title="栈的相关操作"></a>栈的相关操作</h5><ul>
<li>调用指令<code>call</code><br>call指令在跳转到被调用过程执行值钱，先将返回地址（即程序计数器EIP的值，也就是call指令的下一条指令地址）压栈（相当于push操作，回改变ESP的值），然后跳转到被调用过程执行。</li>
<li>返回指令<code>ret</code><br>ret指令从栈顶取出返回地址到EIP，以返回调用过程继续执行。</li>
</ul>
<h5 id="保存现场的IA-32约定"><a href="#保存现场的IA-32约定" class="headerlink" title="保存现场的IA-32约定"></a>保存现场的IA-32约定</h5><ul>
<li>调用者保存寄存器：EAX,ECX,EDX</li>
<li>被调用者保存寄存器： EBX,ESI,EDI</li>
<li>根据以上约定，为减少过程的准备和结束阶段的开销，每个过程应该优先使用EAX,ECX,EDX<br><img src="/../img/HUST_CS_%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%88%E5%B8%A7%E5%8F%98%E5%8C%96.png" alt="过程调用栈帧变化"><br>在调用者P保存他的参数的时候，将入口参数从右到左一次保存的，这样可以从低地址空间向高地址空间依次访问各参数。</li>
</ul>
<p>在进入到Q的过程里面以后，Q首先回把P的EBP的值压入自己的栈帧中，然后用当前ESP的值设置自己的EBP，再修改ESP设置自己的栈帧的顶部。</p>
<h4 id="过程（函数）对应的机器级代码结构"><a href="#过程（函数）对应的机器级代码结构" class="headerlink" title="过程（函数）对应的机器级代码结构"></a>过程（函数）对应的机器级代码结构</h4><ul>
<li>准备阶段<ul>
<li>形成帧底部：<code>pushl %ebp</code>,<code>movl %esp, %ebp</code></li>
<li>生成栈帧、保护现场：修改esp*<code>sub</code>指令*，被调用者保护寄存器入栈（mov指令）</li>
</ul>
</li>
<li>过程执行阶段<ul>
<li>为欸本过程非静态局部变量再栈中分配空间并赋值</li>
<li>开始具体处理，如果遇到函数调用时<ul>
<li>如果需要保存调用者保存寄存器的值，则保存</li>
<li>准备参数：通过<code>mov</code>指令将实参送栈帧入口参数处</li>
<li><code>call</code>指令：保存返回地址到栈顶，然后跳转被调用函数</li>
</ul>
</li>
<li>过程体执行结束前，如需胡衣服被调用者寄存器的值，则恢复，并通产再EAX中准备返回结果</li>
</ul>
</li>
<li>结束阶段<ul>
<li>退栈：<code>leave</code>指令或<code>popl</code>指令。<br><strong><code>leave</code>指令等价于先执行<code>movl %ebp, %esp</code>，然后再执行<code>popl %ebp</code></strong></li>
<li>取返回地址返回：<code>ret</code>指令</li>
</ul>
</li>
</ul>
<p>为什么递归的时空效率差：  </p>
<ol>
<li>每次都需要重复执行自身过程体，直到结束条件满足才停止。</li>
<li>空间开销大，每次调用，都形成一个完整的栈帧，最多会形成n+1个栈帧</li>
<li>时间开销大，为了支持过程递归，每次都需要走一遍准备阶段和结束阶段。增加许多额外指令，特别是内存访问相关的指令。</li>
</ol>
<h4 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h4><blockquote>
<p>当使用cmpl指令比较两个寄存器中存放的地址的时候，条件转移的时候应该是无符号类型的条件转移，因为地址都是无符号整数。</p>
</blockquote>
<h5 id="switch语句的机器级表示"><a href="#switch语句的机器级表示" class="headerlink" title="switch语句的机器级表示"></a>switch语句的机器级表示</h5><ul>
<li>跳转表是一个数组（hash表），数组每个元素存储对应的开关索引值对应的代码段的首地址。</li>
<li>用开关索引作为跳转表的索引，确定跳转目标</li>
<li>跳转表放在可执行目标文件的只读数据节中，按4字节边界对齐</li>
</ul>
<h4 id="循环结构的机器级表示"><a href="#循环结构的机器级表示" class="headerlink" title="循环结构的机器级表示"></a>循环结构的机器级表示</h4><ul>
<li>一般来说，可以用分支转移指令来实现循环</li>
<li>专门的循环指令：<code>loop</code>,<code>loope</code>,<code>loopne</code>,<code>jecxz</code></li>
<li>编译优化：<ul>
<li>循环展开：确定循环次数的，不大的，直接展开，充分利用流水线。</li>
<li>与寄存器绑定，减少访存操作，减少指令</li>
<li>并行计算，SIMD并行运算等。</li>
</ul>
</li>
</ul>
<h2 id="复杂数据类型的分配和访问"><a href="#复杂数据类型的分配和访问" class="headerlink" title="复杂数据类型的分配和访问"></a>复杂数据类型的分配和访问</h2><h3 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h3><h4 id="静态区的数组"><a href="#静态区的数组" class="headerlink" title="静态区的数组"></a>静态区的数组</h4><ul>
<li>分配在静态区的数组在编译、链接的时候就可以确定数组的地址</li>
<li>机器洁指令可以直接用数组首地址和数组元素的下标访问数组元素</li>
</ul>
<h4 id="栈区数组的初始化和访问、"><a href="#栈区数组的初始化和访问、" class="headerlink" title="栈区数组的初始化和访问、"></a>栈区数组的初始化和访问、</h4><p>auto型数组就是在栈中分配的，因此数组的首地址通过<code>ebp</code>定位。</p>
<p>为了能够按照地址递增的方式遍历数组，数组的首地址都会放在最低地址处。即<code>buf[0]</code>一般都对应<code>%ebp-max</code></p>
<h3 id="结构体数据的分配和访问"><a href="#结构体数据的分配和访问" class="headerlink" title="结构体数据的分配和访问"></a>结构体数据的分配和访问</h3><ul>
<li>结构体的地址是第一个数据项第一字节的地址。</li>
<li>编译器在处理结构数据时，根据每个成员的数据类型计算成员相对于结构体变量基址的相应字节偏移量，然后通过每个成员的字节偏移量来访问结构成员。</li>
</ul>
<h5 id="结构体数据作为入口参数的机器级实现"><a href="#结构体数据作为入口参数的机器级实现" class="headerlink" title="结构体数据作为入口参数的机器级实现"></a>结构体数据作为入口参数的机器级实现</h5><ul>
<li>按值传递：结构体成员要赋值到栈中参数区。增加时空开销，且更新后的数据无法在调用过程中使用。</li>
<li>按地址传递，在call之前，只需要传递指向结构体的指针。</li>
</ul>
<h3 id="联合体数据的分配和访问"><a href="#联合体数据的分配和访问" class="headerlink" title="联合体数据的分配和访问"></a>联合体数据的分配和访问</h3><h3 id="数据的对齐"><a href="#数据的对齐" class="headerlink" title="数据的对齐"></a>数据的对齐</h3><h2 id="编译器的优化"><a href="#编译器的优化" class="headerlink" title="编译器的优化"></a>编译器的优化</h2><ol>
<li>循环展开：将程序执行流程变成一个顺序结构，消除引起循环的跳转指令，让指令流水线利用更充分，避免在指令流水线上产生要被丢弃的“半成品”而浪费事件。</li>
<li>分支语句向无分支语句转换：使用条件传送指令等，可以提高指令流水线的利用率。</li>
<li>调整指令执行顺序：后面的指令用到前面指令的结果，前面的指令结果还未产生，后面的指令就要等待，产生阻塞就会影响指令流水线的速度。调整指令顺序的目的是减少可能的阻塞。</li>
<li>使用执行速度更块的机器指令，比如用移位指令代替乘法、除法指令。</li>
<li>使用串操作指令代替用循环一个数据一个数据的处理（传送、比较、串初始值设定等）。</li>
<li>使用SIMD：一条指令成组操作，解决操作次数。</li>
<li>使用位数更长的寄存器：使用字节数更大的寄存器，一次就可以处理更多的内容，充分利用硬件中已有数据线宽度。</li>
<li>对一个二位数组调整数据处理顺序（行优先）：提高CPU的cache命中率，减少cache与内存之间来回的数据交换，从而节约事件。</li>
<li>变量与寄存器绑定：访问变量变成访问绑定的寄存器，访问寄存器的速度远远宽裕访问内存（包括cache）的速度。</li>
<li>并行优化：利用多线程、多核等特点。</li>
</ol>
<h2 id="在C语言中，如何提高程序运行速率"><a href="#在C语言中，如何提高程序运行速率" class="headerlink" title="在C语言中，如何提高程序运行速率"></a>在C语言中，如何提高程序运行速率</h2><ol>
<li>优化数据的访问顺序：对于二维数组，按照行优先顺序访问</li>
<li>减少重复计算（<code>for(int i=0;i&lt;strlen(s);i++)</code>，避免<code>strlen</code>的多次计算</li>
<li>调用封装了串操作指令的函数，如<code>memcpy</code>,<code>memset</code>,<code>memcmp</code>等。</li>
<li>变递归为迭代，函数调用传递参数、断点压栈等多种操作，既慢又有栈溢出风险。</li>
<li>用移位实现乘除法。</li>
<li>调整条件语句中组合条件的子条件顺序，可以避免没有必要的判断。因为在C中，<code>&amp;&amp;</code>在第一个为<code>0</code>的时候就不判断第二个了</li>
<li>使用封装了SIMD指令的函数调用</li>
<li>利用多线程</li>
<li>去除冗余指令。</li>
<li>有一些优化是编译器无法做到的，比如指针相关的数据访问。本来不用指针可能可以让编译器自行优化的。</li>
</ol>
<h1 id="第四章-程序的链接"><a href="#第四章-程序的链接" class="headerlink" title="第四章 程序的链接"></a>第四章 程序的链接</h1><h2 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h2><h3 id="程序链接的定义、链接的意义与过程"><a href="#程序链接的定义、链接的意义与过程" class="headerlink" title="程序链接的定义、链接的意义与过程"></a>程序链接的定义、链接的意义与过程</h3><p>链接：<br>在将高级语言编译转换成了机器代码之后，将所有关联到的可重定位目标文件（包括用到的标准库函数目标文件），按照某种形式组合在一起，生成一个具有统一地址空间、可被加载到存储器直接执行的可执行目标文件。</p>
<p>链接的好处：</p>
<ul>
<li>程序可以划分位多个模块，多人进行编辑、编译，缩短开发周期</li>
<li>将常用函数用于构建公共库函数，供不同程序员重用，实现共享</li>
<li>支持增量编译，部分源程序文件修改，只用重新编译被修改的源程序文件，然后重新链接。提高程序修改后的编译效率。</li>
</ul>
<p>链接过程的本质：<br>将设计到的所有可重定位目标文件中相同的节合并，形成具有统一虚拟地址空间编址的可执行目标文件。</p>
<h4 id="链接操作的步骤"><a href="#链接操作的步骤" class="headerlink" title="链接操作的步骤"></a>链接操作的步骤</h4><ol>
<li>符号解析</li>
</ol>
<ul>
<li>将每个模块中引用的符号（包括变量和函数）和某个模块中定义符号建立关联。</li>
<li>编译器将定义的符号存放在一个符号表中。  <ul>
<li>符号表是一个结构数组</li>
<li>每个表项包含符号名、长度和位置等信息。</li>
</ul>
</li>
<li>链接器将每个符号的引用都与其确定的符号定义建立关联。</li>
</ul>
<ol start="2">
<li>重定位<br>将所有关联的模块合并，并确定运行时每个定义符号在虚拟空间中的地址，然后再定义符号的引用处重定位引用符号的地址。</li>
</ol>
<h3 id="目标文件格式、可重定位目标文件格式、可执行目标文件格式"><a href="#目标文件格式、可重定位目标文件格式、可执行目标文件格式" class="headerlink" title="目标文件格式、可重定位目标文件格式、可执行目标文件格式"></a>目标文件格式、可重定位目标文件格式、可执行目标文件格式</h3><h4 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h4><ul>
<li>目标文件（Object file）<ul>
<li>源代码经过编译或汇编后生成的机器语言代码成为目标代码</li>
<li>存放目标代码的文件称为目标文件。</li>
</ul>
</li>
<li>目标文件主要有两类<ul>
<li>可重定位目标文件<ul>
<li>代码和数据可以和其它可重定位文件的代码和数据合并位可执行目标文件。其中每个可重定位目标文件的代码和数据的地址都从0开始。</li>
</ul>
</li>
<li>可执行目标文件<ul>
<li>包含的代码和数据可以直接复制到内存并被执行，其中代码和数据的地址为统一地址空间中的虚拟地址</li>
</ul>
</li>
</ul>
</li>
<li>目标文件格式：目标文件的结构规范<ul>
<li>COM, COFF, PE(Winndows)</li>
<li>ELF格式linux使用的格式<ul>
<li>链接视图：对应“可重定位目标文件”<ul>
<li>可重定位目标文件由不同的节组成。</li>
<li>节，section，是ELF文件中具有i昂同特征的最小可处理单位，不同节描述目标文件中不同类型的信息及其特征。</li>
<li><code>.text</code>：代码节</li>
<li><code>.rodata</code>：只读数据节</li>
<li><code>.data</code>：已初始化的数据节</li>
<li><code>.bss</code>：未初始化的数据节</li>
</ul>
</li>
<li>执行视图：对应“可执行目标文件”<ul>
<li>可执行目标文件的最基本结构单元还是“节”，但是引入逻辑单元“段”</li>
<li>段，segment，是具有某种共同的性质的节的集合。</li>
<li>可读写数据段是映射到一块连续区域的<code>.data</code>和<code>.bss</code>节的集合</li>
<li>只读代码段是映射到一块连续区域的<code>.text</code>和<code>.rodata</code>等节的集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可重定位目标文件的ELF格式"><a href="#可重定位目标文件的ELF格式" class="headerlink" title="可重定位目标文件的ELF格式"></a>可重定位目标文件的ELF格式</h4><ul>
<li>ELF头：位于目标文件的起始位置，包含文件结构说明信息</li>
<li><code>.text</code>节：编译后的代码部分</li>
<li><code>.rodata</code>节：只读数据，如printf格式串，switch跳转表等</li>
<li><code>.data</code>节：已初始化的全局变量和静态局部变量</li>
<li><code>.bss</code>节：未初始化的全局变量和静态局部变量，仅占位，不占据实际磁盘空间（为了提高空间效率）</li>
<li>节头表：由若干表项组成，每个节都由一个表项与之对应，每个表项描述对应的一个节的</li>
</ul>
<h4 id="可执行目标文件格式"><a href="#可执行目标文件格式" class="headerlink" title="可执行目标文件格式"></a>可执行目标文件格式</h4><ul>
<li>包含代码、数据</li>
<li>定义的所有变量和函数再统一虚拟地址空间中有确定的地址</li>
<li>符号引用处已被重定位，指向相应的已定义符号再统一虚拟地址空间中的地址</li>
<li>可被CPU直接执行，指令地址和质量你个给出的操作数都是统一虚拟地址空间中的虚拟地址</li>
<li>为了能够被执行，再执行视图中，需要将具有相同访问属性的节合并成段，说明每个段的属性。例如：再可执行缪奥文件中的唯一、大小、在统一虚拟空间中的位置、对齐方式、访问属性等。程序投标就是用来说明这些段信息，也称段头表。</li>
</ul>
<p>与可重定位目标文件的不同：</p>
<ul>
<li>ELF头中的字段<code>e_entry</code>在可执行目标文件中会给出执行程序时第一条指令的地址，而在可重定位文件中，此字段为0</li>
<li>多一个程序头表（段头表），用于说明可执行目标文件的段的组成</li>
<li>多一个<code>.init</code>节，其中定义了一个<code>_init</code>函数，用于可执行目标文件开始执行时的初始化工作</li>
<li>少了重定位的信息节<code>.rel.text</code>和<code>.rel.data</code></li>
</ul>
<p>程序头表：描述可执行文件中的段与虚拟地址空间的映射关系，每个表项记录一个段的映射等相关信息。</p>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="符号表、符号解析"><a href="#符号表、符号解析" class="headerlink" title="符号表、符号解析"></a>符号表、符号解析</h3><p>链接的第一步就是符号解析，这个过程需要知道被定义的所有符号（函数名和变量名）的相关信息。相关信息存储在可重定位目标文件的符号表中。</p>
<p>符号表中的符号：</p>
<ol>
<li>Global Symbol（全局符号）：<br>本模块内部定义并且被其它模块引用的符号。包括非static的函数名和非static的全局变量名。</li>
<li>Local symbol（本地符号）：<br>本模块内部定义并仅由本模块内部引用的符号，包括在本模块内部定义的的带static属性的函数名和带static属性的全局变量名。</li>
<li>External symbol（外部符号）：<br>由其它模块定义并被本模块引用的符号，例如声明中出现的带extern的函数名和变量名。</li>
</ol>
<h4 id="全局符号的解析"><a href="#全局符号的解析" class="headerlink" title="全局符号的解析"></a>全局符号的解析</h4><ol>
<li>全局符号的强弱特性：</li>
</ol>
<ul>
<li>已定义的函数名和已初始化的全局变量名是强符号</li>
<li>未初始化的全局变量名是弱符号</li>
<li>外部符号和本地符号没有强弱区分，因为没有必要</li>
</ul>
<ol start="2">
<li>链接器对多重定义符号的处理规则<ol>
<li>强符号不能多次定义</li>
<li>若一个符号被说明为一次强符号定义和多次弱符号定义，则按强符号定义为准</li>
<li>若由多个弱符号定义，则任意选择一个</li>
<li>就算弱符号的定义和强符号的定义的类型不统一，也不会报错，会自动忽略弱符号定义。但是在执行的时候就会出问题了。</li>
</ol>
</li>
</ol>
<p>使用全局变量的时候，最好：</p>
<ol>
<li>尽量使用本地变量</li>
<li>全局变量赋初值</li>
</ol>
<h3 id="与静态库的链接"><a href="#与静态库的链接" class="headerlink" title="与静态库的链接"></a>与静态库的链接</h3><h3 id="重定位所需信息和重定位过程"><a href="#重定位所需信息和重定位过程" class="headerlink" title="重定位所需信息和重定位过程"></a>重定位所需信息和重定位过程</h3><ol>
<li>合并相同的节：在符号解析的基础上，将所有关联的目标模块中相同的节合并成同一类型的新节</li>
<li>对定义符号进行重定位，确定其地址<br>  根据每个定义符号相对于以前所在节的相对位置以及改节在虚拟地址空间中的起始位置，为每个定义符号确定其在统一虚拟地址空间中的存储地址。</li>
<li>对引用符号进行重定位：链接器对合并后新代码节<code>.text</code>和数据节<code>.data</code>中的引用符号进行重定位，使其指向对应的定义符号在统一虚拟地址空间中的首地址。</li>
</ol>
<p>链接器根据.o文件中的<code>.rel.data</code>和<code>.rel.text</code>中保存的重定位信息，才能知道哪些引用符号需要重定位</p>
<p>重定位类型：</p>
<ol>
<li><code>R_386_PC32</code>：指明引用处采用的使相对寻址方式，即<code>有效地址=PC的内容+重定位后的32位地址（偏移）</code></li>
<li><code>R_386_32</code>：指明引用处采用绝对地址方式，即<code>有效地址=重定位后的32位地址</code></li>
</ol>
<p>　</p>
<h3 id="可执行文件的加载"><a href="#可执行文件的加载" class="headerlink" title="可执行文件的加载"></a>可执行文件的加载</h3><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="动态链接的特性"><a href="#动态链接的特性" class="headerlink" title="动态链接的特性"></a>动态链接的特性</h3><p>静态库的缺点：</p>
<ul>
<li>在link的时候，其目标代码通过静态链接被加入到程序的可执行目标代码中。与i那次库函数的实体被包含在每个运行进程的代码段中，对于并发高的系统，每个进程都有它们的副本，造成极大的主存资源浪费。</li>
<li>库函数（printf）被合并在可执行目标文件中，磁盘上存放着数千个可执行目标文件，每个文件里面包含同样的库函数副本，造成磁盘空间的极大浪费</li>
<li>更新维护困难。新版本出现以后需要重新编译和链接</li>
</ul>
<p>共享库：</p>
<ul>
<li>共享库文件也是可重定位目标文件，包含代码和数据。只是代码和数据从程序中分离出来，单独存放，在磁盘和内存中都只有一个备份</li>
<li>值在执行可执行目标文件中引用的这些库函数的地方做好引用标识，通过动态链接技术，将库函数实际加载和链接时刻推迟到可执行目标文件装入或运行时</li>
<li>Windows称为动态链接库，<code>.dll</code>文件</li>
<li>Linux称为动态共享对象，<code>.so</code>文件</li>
<li>动态链接可以按照两种方式进行<ul>
<li>在第一次加载时进行<ul>
<li>Linux通常由动态链接器自动处理。（libc.so）就是按照这种方式动态被链接的</li>
</ul>
</li>
<li>在运行时进行<ul>
<li>在Linux中，通过调用<code>dlopen()</code>等接口实现</li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li>在一个共享库目标文件被所有程序共享，节省磁盘空间</li>
<li>在内存中只有一个备份，被所有进程共享，节省内存空间</li>
<li>共享库升级时，被自动加载到内存和程序动态链接，使用方便</li>
<li>共享库可分模块、独立地用不同变成语言进行开发，开发效率高</li>
<li>第三方开发的共享库可作为程序插件，使程序功能易于扩展</li>
</ul>
</li>
</ul>
<h3 id="程序加载时的动态链接、程序运行时的动态链接"><a href="#程序加载时的动态链接、程序运行时的动态链接" class="headerlink" title="程序加载时的动态链接、程序运行时的动态链接"></a>程序加载时的动态链接、程序运行时的动态链接</h3><h3 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h3><p>gcc中的编译选项<code>fPIC</code></p>
<h1 id="第七章-中断和异常"><a href="#第七章-中断和异常" class="headerlink" title="第七章 中断和异常"></a>第七章 中断和异常</h1><p>中断和异常：一个进程在执行过程中，正常的逻辑控制流被特殊的事件所打断，CPU转到处理这些事件的内核程序取执行，从而引发一个异常控制流。</p>
<ul>
<li>中断：<ul>
<li>由外部设备出发、与正在执行的指令无关，异步事件</li>
</ul>
</li>
<li>异常：<ul>
<li>与正在执行的指令相关的同步事件</li>
<li>CPU内部出现的中断，也称为同步中断</li>
</ul>
</li>
</ul>
<p>一条指令的执行过程中，CPU检测到了某种预先定义条件，产生一个异常信号，进而调用异常处理程序对该异常进行处理。</p>
<p>Intel CPU中的异常：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">后续操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">故障</td>
<td align="left">重新执行引起异常的指令</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td align="left">执行引起异常指令之下的指令</td>
</tr>
<tr>
<td align="left">中止</td>
<td align="left">终止程序运行</td>
</tr>
</tbody></table>
<h4 id="中断描述表（中断矢量表）"><a href="#中断描述表（中断矢量表）" class="headerlink" title="中断描述表（中断矢量表）"></a>中断描述表（中断矢量表）</h4><p>中断服务程序和异常处理程序的入口地址构成的一个表，每个表项占8哥字节，存放入口偏移地址以及相应代码段的描述信息；这些表项是按照中断和异常的编号（类型号）顺序排列的。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>故障<ul>
<li>故障是在引起异常的指令之前或指令执行期间，在检测到故障或者预先定义的条件不能满足时产生</li>
<li>常见故障：<ul>
<li>缺页</li>
<li>除法出错（除以0，除法溢出）</li>
<li>数据访问越界（访问一个不准本程序访问的内存单元）</li>
</ul>
</li>
<li>故障通常可以就曾，处理完异常以后，引起故障的指令重新执行</li>
</ul>
</li>
<li>陷阱<ul>
<li>在执行引起异常的指令后，把异常情况通知给系统</li>
<li>执行异常处理程序后，回到产生异常信号的指令之下的一条语句</li>
<li><strong>软中断</strong>是一种常见的陷阱。在程序中写了中断指令，执行该语句就会调用中断处理程序，中断处理完后又继续运行下面的程序</li>
<li>软中断调用与调用一般的子程序非常类似。借助软中断，可以调用操作系统提供的服务程序。</li>
</ul>
</li>
<li>中止<ul>
<li>中止是在系统出现严重问题时通知系统的一种异常</li>
<li>引起中止的指令是无法确定的</li>
<li>产生中止时，正在执行的程序不能被恢复执行。系统接收终止信号后，处理程序要重新建立各种系统表格，并可能重新启动操作系统</li>
<li>中止的例子包括硬件故障和系统表中出现非法值或不一致的值</li>
</ul>
</li>
</ul>
<h3 id="异常-中断相应过程"><a href="#异常-中断相应过程" class="headerlink" title="异常&#x2F;中断相应过程"></a>异常&#x2F;中断相应过程</h3><p>CPU的控制逻辑确定检测到中断和异常类型号，从中断描述表中取出对应的表项，计算相应的处理程序的入口地址，保存当前的CS，EIP，EFLASGS等信息，然后转到处理程序的入口地址对应的位置取执行。在中断处理程序中有IRET指令，执行该指令从堆栈中恢复CS，EIP，EFLAGS等，从而回到被中断的位置继续执行。对于三类异常的处理策略有所差异。故障表示能修复，引起故障的指令会被再次执行；陷阱则是执行引发陷阱的下一条指令；中止则是结束程序的运行。</p>
<ol>
<li>关中断：使CPU处于“禁止中断”状态，防止新中断破坏断点（PC）、程序状态（PSW）和现场（通用寄存器）</li>
<li>保护断点和程序状态：将断点和程序状态保存到栈中或特殊寄存器中</li>
<li>识别中断事件：有软件识别和硬件识别（向量中断）两种方式。<br>在IA32中，响应异常时不关中断，值在响应中断时关中断</li>
</ol>
<p>MIPS采用软件识别方式。IA32采用硬件识别方式，用专门的硬件查询电路按优先级顺序识别中断，得到”中断类型号“，根据此好，到中断向量表中读取对应的中断服务程序的入口地址。<br>所有事件都被分配一个”中断类型号”，每个中断都有相应的“中断服务程序”，可根据中断类型号找到中断服务器程序的入口地址。<br>中断类型号相当于中断向量表的索引，表中存放中断服务程序首地址。</p>
<p><strong>要重点注意汇编代码中的数字是十六进制还是十进制！！</strong></p>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST-CS-操作系统</title>
    <url>/2025/01/07/HUST-CS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h3 id="多道程程序设计技术"><a href="#多道程程序设计技术" class="headerlink" title="多道程程序设计技术"></a>多道程程序设计技术</h3><ul>
<li>定义: 在计算机主存中同时存放几道相互独立的程序，这些程序在管理程序控制之下，相互穿插的运行。当某道程序因为某种原因不能继续运行下去时候(如等待外设),管理程序便将另一道程序投入运行</li>
<li>特征<ul>
<li>多道(内存中村南方多个相互独立的程序)</li>
<li>宏观上并行(相互穿插运行)</li>
<li>微观上穿行(CPU上永远只能执行单个程序)</li>
</ul>
</li>
<li>硬件基础: 内存大、中断</li>
</ul>
<h3 id="分时技术"><a href="#分时技术" class="headerlink" title="分时技术"></a>分时技术</h3><ul>
<li>定义: 吧处理机时间划分称很短的时间片，轮流分配给各个应用程序使用，如果某个程序在分配的时间片用完之前计算还未完成，该程序就暂停执行，等待下一次获得时间片后再继续计算</li>
<li>特点<ul>
<li>联机交互</li>
<li>独占使用</li>
<li>响应时间块</li>
</ul>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>定义: 一个大型的软件系统，负责计算机系统软硬件资源分配，控制和协调并发活动，提供给用户和其它软件方便的接口环境，使用户获得良好的工作环境</li>
<li>特点<ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>不确定</li>
</ul>
</li>
</ul>
<h1 id="操作系统的物质基础、结构和用户接口"><a href="#操作系统的物质基础、结构和用户接口" class="headerlink" title="操作系统的物质基础、结构和用户接口"></a>操作系统的物质基础、结构和用户接口</h1><h2 id="物质基础"><a href="#物质基础" class="headerlink" title="物质基础"></a>物质基础</h2><h3 id="CPU特权级"><a href="#CPU特权级" class="headerlink" title="CPU特权级"></a>CPU特权级</h3><ul>
<li>CPU特权级的意义：保护操作系统</li>
<li>分类<ul>
<li>管理态(supervisor mode， 内核态): 操作系统的管理程序执行时机器所处的状态，又称处理机的特权态。在此状态下处理机可以使用全部指令（包括一组特权指令）、使用全部系统资源（包括整个存储区域）</li>
<li>用户态(user mode): 用户程序执行时机器所处的状态成为用户态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域</li>
</ul>
</li>
<li>CPU特权指令<ul>
<li>I&#x2F;O指令(如x86的in&#x2F;out指令)</li>
<li>MMIO地址空间访问指令</li>
<li>改变机器状态寄存器(MSR)的指令</li>
</ul>
</li>
</ul>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li>定义：某个事件（电源掉电、运算溢出、IO）发生时，系统中止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点继续执行的过程</li>
<li>发现中断信号<ul>
<li>发现中断源并向CPU发出中断信号的硬件称为中断装置，IRR是中断装置中的一个寄存器，称中断请求寄存器</li>
<li>IRR中的每一位对应一个中断源，当某个中断源产生中断请求时相应的位被置1.中断装置可以接收多个外部中断源的中断请求，并进行优先级判断，将当前优先级最高的中断请求送到CPU的INTR端</li>
<li>CPU执行完一条指令后检查INTR端，如果发现有中断请求，再从中断装置获取该中断的中断号</li>
</ul>
</li>
<li>中断响应<ul>
<li>定义: 中止先行程序执行，自动引出中断处理程序，也称中断进入</li>
<li>中断响应是由硬件完成的</li>
<li>过程：<ul>
<li>保留程序断点及处理机有关信息</li>
<li>自动转入相应的中断处理程序执行</li>
</ul>
</li>
<li>中断进入的实质: 交换指令地址及处理机的状态信息(PSW)</li>
</ul>
</li>
<li>程序状态字PSW<ul>
<li>反应程序执行时机器所处的现行状态的代码，包括: 指令地址、指令执行情况、处理机状态、应屏蔽的中断等。</li>
<li>PSW的主要作用是实现程序状态的保护和恢复，每个程序都有一个与其执行相关的PSW，每个处理机都有一个PSW寄存器</li>
<li>由于寄存器组织方式不同，大多数计算机的处理器中可能找不到一个称为PSW的寄存器，但总有一组控制与状态寄存器实际上起到这个作用</li>
</ul>
</li>
<li>如何保证将来还能回到当前程序被中断的点继续执行: 保护现场和恢复现场<ul>
<li>现场: 在中断的那一时刻能确保程序继续运行的有关信息<ul>
<li>后继指令所在的主存的单元号</li>
<li>程序运行所处的状态</li>
<li>指令执行情况</li>
<li>程序执行的中间结果</li>
</ul>
</li>
<li>保护现场: 当中断发生时，必须立即把现场信息保存在主存中</li>
<li>恢复现场: 程序重新运行之前，把保留的该程序的现场信息从主存中送至相应的指令计数器、通用寄存器或一些特殊的寄存器中</li>
</ul>
</li>
<li>中断响应的一般过程<ul>
<li>中断进入(硬件实现)<ul>
<li>切换指令地址，改变处理器状态</li>
</ul>
</li>
<li>中断保护<ul>
<li>保护应用程序的执行现场到特定内存区域</li>
<li>在高优先级实现中断的处理</li>
<li>调用特定中断返回指令</li>
</ul>
</li>
<li>中断返回<ul>
<li>从特定内存区域恢复执行现场</li>
<li>回到中断发生前的优先级</li>
</ul>
</li>
</ul>
</li>
<li>向量中断<ul>
<li>定义: 当中断发生时，由中断源自己引导处理机进入中断服务程序的中断过程称为向量中断</li>
<li>中断向量: 每类中断类型都有自己的中断向量，包含：中断服务例程的入口地址和程序状态字</li>
<li>中断向量表: 主存中用于存放中断向量服务地址的一组存储单元组成的表</li>
</ul>
</li>
<li>中断分类<ul>
<li>中断请求(Interrupt ReQuest, IRQ)<ul>
<li>IRQ是Intel术语体系中的对应概念，RISCV术语中称为interrupt</li>
<li>由处理机外部事件引起的中断，称为外部中断</li>
<li>e.g. I&#x2F;O中断、时钟中断、机器故障中断</li>
</ul>
</li>
<li>异常(exception)<ul>
<li>由处理机内部异常状态事件引起的中断</li>
<li>e.g. 除零错误、用户态下用内核态指令、地址访问异常</li>
</ul>
</li>
<li>系统调用(syscall)<ul>
<li>程序为了使用操作系统的服务自愿执行访管指令产生中断</li>
<li>e.g. x86机器中的int指令，RISCV中的ecall指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">IRQ</th>
<th align="left">exception</th>
<th align="left">syscall</th>
</tr>
</thead>
<tbody><tr>
<td align="left">产生原因</td>
<td align="left">CPU以外的外部设备产生的异步事件</td>
<td align="left">当前程序的执行所导致的同步事件</td>
<td align="left">当前执行的程序需要调用OS功能</td>
</tr>
<tr>
<td align="left">处理时机</td>
<td align="left">指令执行的间隙</td>
<td align="left">发生异常的指令执行过程中</td>
<td align="left">访管指令执行完成</td>
</tr>
<tr>
<td align="left">返回地址</td>
<td align="left">下一条指令</td>
<td align="left">发生异常的那条指令</td>
<td align="left">下一条指令</td>
</tr>
<tr>
<td align="left">e.g.</td>
<td align="left">键盘输入、磁盘数据传输</td>
<td align="left">除0错、非法内存访问</td>
<td align="left">x86中的int指令，RISCV中的ecall指令</td>
</tr>
</tbody></table>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><ul>
<li>三种常见的时钟硬件<ul>
<li>可编程间隔定时器(Programmable Interval Itmer, PIT)<ul>
<li>晶体振荡器产生精确周期信号，被送到计数器，数值递减，0的时候产生时钟中断。如果希望周期产生，那么会从一个存储器中复制初值，然后循环。</li>
<li>周期性的中断被称为时钟滴答(clock tick)</li>
</ul>
</li>
<li>实时时钟(Real Time Clock, RTC)<ul>
<li>在PC断电后仍保存事件</li>
<li>通过主板上的电池供电，与CMOS RAM集成到一块芯片上，称为CMOS Timer</li>
<li>可在系统初启时读入并转换位相对于某一基准事件的事件滴答数</li>
</ul>
</li>
<li>时间戳计数器(Time Stamp Counter, TSC)<ul>
<li>某系处理器包含的64位寄存器</li>
<li>在每一个振荡信号到时，计数器递增</li>
<li>可为操作系统提供更精确的时间度量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><ul>
<li>特点<ul>
<li>传输过程中无需CPU参与控制</li>
<li>需要中断支持</li>
<li>用于DMA的内存地址必须连续</li>
<li>传输过程占用总线资源</li>
</ul>
</li>
</ul>
<h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ul>
<li>定义: 为了处理多道程序系统中的并发性、共享性和随机性，使用户程序能协调的工作，必须由一个软件能对硬件处理器及有关资源进行改造，以便为程序的运行提供良好的运行环境，这个部分就是操作系统内核kernel</li>
<li>基本功能：<ul>
<li>中断处理</li>
<li>进程调度</li>
<li>原语管理</li>
</ul>
</li>
<li>特征<ul>
<li>内核是由中断驱动的</li>
<li>内核的执行是连续的</li>
<li>内核在屏蔽中断状态下执行</li>
<li>内核可以使用特权指令</li>
</ul>
</li>
<li>结构分类<ul>
<li>单内核结构<ul>
<li>所有操作系统组件全部放在内核中，全部运行在内核态</li>
<li>优点: 系统结构简单，代码执行效率高; 缺点: 内核庞大，难以维护、调试</li>
<li>UNIX, Linux</li>
</ul>
</li>
<li>微内核结构<ul>
<li>只将操作系统核心组件放在内核中，将外围组件放在用户态运行</li>
<li>优点: OS内核非常小，容易保证稳定; 缺点: 采用IPC通讯，效率偏低</li>
<li>Windows NT, 鸿蒙</li>
</ul>
</li>
<li>伴生内核结构<ul>
<li>在同一台机器上运行多个OS,一个主，其它伴生</li>
<li>docker容器，云端虚拟机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h5><ul>
<li>微内核结构的操作系统分为两大部分<ul>
<li>微内核: 核心功能(中断处理、进程&#x2F;线程管理、低级存储器管理)</li>
<li>服务进程：文件服务、存储管理服务</li>
</ul>
</li>
<li>操作系统以C&#x2F;S形式为用户程序提供服务<ul>
<li>内核把用户请求服务的消息传给服务进程</li>
<li>服务进程接收并执行用户服务的请求</li>
<li>内核用消息把结果返回给用户</li>
</ul>
</li>
<li>优点：<ul>
<li>可靠、可扩充、可移植</li>
</ul>
</li>
<li>缺点<ul>
<li>系统开销大(消息收发、上下文切换)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">单内核</th>
<th align="left">微内核</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户进程调用库或内核调用，进入操作系统服务例程。操作系统服务例程是在用户进程的上下文环境中执行的。</td>
<td align="left">用户通过发送请求的方式让操作系统执行服务例程</td>
</tr>
</tbody></table>
<h2 id="操作系统的生成和启动"><a href="#操作系统的生成和启动" class="headerlink" title="操作系统的生成和启动"></a>操作系统的生成和启动</h2><h3 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h3><ul>
<li>将操作系统的必要部分装入主存并对系统进行初始化工作，最终使系统处于命令接收状态</li>
<li>独立引导方式(滚雪球方式)<ul>
<li>OS核心文件存储在系统本身的存储设备中，由系统自己将OS核心程序读入主存并运行，建立一个操作环境</li>
<li>适用于微机和大多数系统</li>
</ul>
</li>
<li>辅助下装方式<ul>
<li>OS主要文件不放在系统本身的存储设备中，在系统启动后执行下装操作，从另外的计算机系统中将操作系统常驻部分传送到计算机中，使它形成一个操作环境</li>
<li>用于多计算机系统、由主控机与前端机构成的系统以及分布式系统</li>
</ul>
</li>
</ul>
<h3 id="x86机器上的Linux的启动流程"><a href="#x86机器上的Linux的启动流程" class="headerlink" title="x86机器上的Linux的启动流程"></a>x86机器上的Linux的启动流程</h3><ul>
<li>系统加电或复位</li>
<li>BIOS启动<ul>
<li>ROM中的引导程序放在固定位置: FFFF: 0000, CPU从这里开始执行</li>
<li>硬件自检</li>
<li>从硬盘读入零柱面零磁道1扇区(Master Boot Record, MBR)到固定位置，jmp到0000: 7C00，将控制权交给MBR中的Boot Loader程序(如GRUB)</li>
</ul>
</li>
<li>Boot Loader(引导程序)<ul>
<li>将Linux内核读入内存，jmp到内核的入口地址，将控制权交给OS的初始化程序</li>
</ul>
</li>
<li>系统核心初始化<ul>
<li>Setup.s的工作<ul>
<li>检查调入内存中的代码</li>
<li>获取内存容量信息，设置设备模式</li>
<li>屏蔽中断，准备进入保护模式</li>
<li>设置中断描述符表(IDT)，全局描述符表(GDT)；控制交给Heads</li>
</ul>
</li>
<li>Heads的工作<ul>
<li>调用Setup_IDT做准备工作</li>
<li>检查CPU类型</li>
<li>调用Setup_pageing进行页表初始化</li>
<li>调用main.c中的Start_kernel()</li>
</ul>
</li>
<li>Start_kernel()的工作<ul>
<li>对与CPU、内存等最基本硬件相关部分进行初始化</li>
<li>对IDT进行初始化</li>
<li>为进程调度程序做准备</li>
<li>设置基准时钟</li>
<li>内核的内存分配</li>
<li>对文件系统进行初始化</li>
<li>建立init进程</li>
</ul>
</li>
<li>init进程对每一个联机终端建立”getty”进程，getty 在终端上现实login, 等待用户登录</li>
</ul>
</li>
</ul>
<h3 id="操作系统的生成"><a href="#操作系统的生成" class="headerlink" title="操作系统的生成"></a>操作系统的生成</h3><ul>
<li>定义<ul>
<li>所谓系统生成，就是为了满足物理设备的约束和需要的系统功能，通过组装一批模块来产生一个清晰的、使用方便的操作系统的过程</li>
<li>简单地说就是系统的安装，即将OS安装到启动装置(可以是磁盘，也可以是tftp服务器的某个目录)</li>
</ul>
</li>
<li>系统生成的内容<ul>
<li>Bootloader</li>
<li>OS内核</li>
<li>文件系统</li>
<li>执行环境(如用户态lib等)</li>
</ul>
</li>
</ul>
<h2 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h2><h3 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>一个源程序经过编译后，生成一个可重定位的目标模块，并产生内部符号表和外部调用表，供链接程序使用。</p>
<ul>
<li>内部符号表: 本模块可以被其它程序调用的入口点</li>
<li>外部调用表: 本模块要调用的外部程序模块名</li>
<li>链接程序需要做的工作<ul>
<li>将各模块连接称为一个整体</li>
<li>构造全程符号表，在其中填写模块的裸机地址</li>
<li>查找各程序段的外部调用表，填入对应调用函数的地址</li>
</ul>
</li>
<li>静态链接的缺点<ul>
<li>静态链接需要将所需的外部函数链接到目标文件中生成一个可执行文件。若多个应用程序都调用了同一个库中的外部函数，则每个执行文件中都会包含这个外部函数对应的代码</li>
</ul>
</li>
</ul>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><ul>
<li>动态链接不需要将外部函数链接到目标文件中，而是在应用程序中需要调用外部函数的地方做记录，并说明要使用的外部函数名和引用入口号，形成函数调用链表</li>
<li>所需支持： 动态链接库(DLL)</li>
<li>OS的装在程序将应用程序和DLL装入主存后，装载程序会遍历函数调用链表，将DLL中函数在主存的入口(段: 偏移)填入链表中的每个节点</li>
<li>缺点: 可执行文件的执行需要执行环境找到并加载所有它依赖的函数库</li>
</ul>
<h2 id="操作系统的用户接口"><a href="#操作系统的用户接口" class="headerlink" title="操作系统的用户接口"></a>操作系统的用户接口</h2><h4 id="Linux系统调用控制程序的功能"><a href="#Linux系统调用控制程序的功能" class="headerlink" title="Linux系统调用控制程序的功能"></a>Linux系统调用控制程序的功能</h4><ol>
<li>取系统调用号，检验合法性</li>
<li>建立调用堆栈，保护现场信息</li>
<li>根据系统调用号定位核心函数地址</li>
<li>根据通用寄存器内容，从用户栈中取入口参数</li>
<li>核心函数执行，把结果返回给应用程序</li>
<li>执行退栈操作，判别调度程序scheduler是否要被执行</li>
</ol>
<h1 id="进程及进程管理"><a href="#进程及进程管理" class="headerlink" title="进程及进程管理"></a>进程及进程管理</h1><h2 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h2><h4 id="顺序程序"><a href="#顺序程序" class="headerlink" title="顺序程序"></a>顺序程序</h4><ul>
<li>程序的一次执行过程称为一个计算，由许多简单操作组成</li>
<li>一个计算的若干操作必须按照严格的先后次序顺序地执行，这个计算过程就是程序的顺序执行过程</li>
<li>特点<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
</li>
</ul>
<h4 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h4><ul>
<li>定义: 若干个程序段同时在系统中运行，这些程序段的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的</li>
<li>特点：<ul>
<li>程序与计算不再一一对应</li>
<li>程序并发执行的相互制约<ul>
<li>间接的相互制约关系: 资源共享</li>
<li>直接的相互制约关系: 公共变量</li>
</ul>
</li>
<li>失去程序的封闭性和可再现性: 若一个程序的执行可以改变另一个程序的变量，那么后者的输出就可能有赖于各程序执行的相对速度，即失去了程序的封闭性特点<ul>
<li>程序并发执行时的结果与各并发程序的相对速度有关，即给定相同的初始条件，若不加以控制，也可能得到不同的结果，此为与时间有关的错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><ul>
<li>进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li>
<li>进程与程序的区别<ul>
<li>程序是静态的概念，进程是动态的概念</li>
<li>进程一个独立运行的活动单位</li>
<li>进程是竞争系统资源的基本单位</li>
<li>一个程序可以对应多个进程，一个进程至少包含一个程序</li>
</ul>
</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul>
<li>运行状态(running)<ul>
<li>该进程已获得运行所必需的资源，它的程序正在处理机上执行</li>
</ul>
</li>
<li>等待状态(waiting)<ul>
<li>进程正等待着某一事件的发生而暂时停止执行。这时，即使给它CPU控制权，它也无法执行</li>
</ul>
</li>
<li>就绪状态(ready)<ul>
<li>进程已获得除CPU之外的运行所必需的资源，一旦得到CPU控制权，立即可以运行</li>
</ul>
</li>
</ul>
<h3 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h3><ul>
<li>进程控制块<ul>
<li>描述进程与其它进程、系统资源的关系以及各进程在各不同时期所处的状态的数据结构，称为进程控制块(process control block, PCB)</li>
<li>主要内容<ul>
<li>进程标识符: 进程符号名内部id</li>
<li>进程当前状态: 本进程目前处于何种状态</li>
<li>当前队列指针next: 该项等级了处于同一状态下的下一个进程的PCB地址</li>
<li>进程优先级: 反应了进程要求CPU的紧迫程度</li>
<li>CPU现场保护区: 当进程由于某种原因释放处理机时，CPU现场信息被保存在PCB的该区域中</li>
<li>通信信息: 进程间进行通信时所记录的有关信息</li>
<li>家族联系: 指明本进程与家族的联系</li>
<li>占有资源清单</li>
</ul>
</li>
</ul>
</li>
<li>进程的组成(进程映像)<ul>
<li>程序与数据<ul>
<li>描述进程本身应完成的功能</li>
</ul>
</li>
<li>进程控制块PCB<ul>
<li>进程的动态特征，该进程与其它进程和系统资源的关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程控制的概念"><a href="#进程控制的概念" class="headerlink" title="进程控制的概念"></a>进程控制的概念</h3><ul>
<li>进程控制的职责: 对系统中的进程实时有效的管理，负责进程状态的改变</li>
<li>常用的进程控制原语<ul>
<li>创建原语、撤销原语、等待原语、唤醒原语</li>
</ul>
</li>
<li>进程的状态变化</li>
</ul>
<table>
<thead>
<tr>
<th align="left">创建进程的典型原因</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">新建一个批处理任务</td>
<td align="left">在一个批处理任务作业流中，当操作系统完成了上一个作业，从作业流中读出下一个作业时</td>
</tr>
<tr>
<td align="left">交互式登录</td>
<td align="left">用户通过一个交互式终端登录到某个系统中时</td>
</tr>
<tr>
<td align="left">操作系统创建，以提供某种服务</td>
<td align="left">现代操作系统往往需要创建某种服务以辅助用户进程完成其工作</td>
</tr>
<tr>
<td align="left">被已经存在的进程所创建</td>
<td align="left">例如为提高多核系统的资源利用率，某用户创建一个子进程</td>
</tr>
</tbody></table>
<h4 id="Linux-fork"><a href="#Linux-fork" class="headerlink" title="Linux::fork()"></a>Linux::fork()</h4><p>Linux用fork()创建一个子进程，它从父进程继承整个进程的地址空间，包括: 进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等</p>
<ol>
<li>为新进程分配一个新的PCB结构</li>
<li>为子进程赋一个唯一的进程标识号PID</li>
<li>为子进程做一个父进程上下文的裸机副本。这意味着父子进程将执行完全相同的代码</li>
<li>增加与该进程相关联的文件表和索引节点表的引用数。这就意味着父进程打开的文件子进程可以继续使用。</li>
<li>对父进程返回子进程的进程号，对子进程返回0</li>
</ol>
<h3 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h3><ul>
<li>进程撤销原语的形式<ul>
<li>进程完成任务或希望终止时使用进程撤销原语<code>exit()</code></li>
</ul>
</li>
<li>进程撤销原语的功能<ul>
<li>撤销当前运行的进程。将改进程的PCB结构归还到PCB资源池，所占用的资源归还给父进程，从总链队列中摘除它，然后转进程调度程序</li>
</ul>
</li>
<li>进程撤销原语的实现<ul>
<li>入口-&gt;由运行指针得当前进程的pid-&gt;释放本进程所占用的资源给父进程-&gt;该进程从总队列中摘下-&gt;释放PCB结构-&gt;转进程调度</li>
</ul>
</li>
<li>进程撤销的主要原因<ul>
<li>进程正常运行结束</li>
<li>进程运行中处所，如执行了非法指令、在常态下执行了特权指令、运行时间超越了分给的最大时间段、申请的内存超过了系统能提供的最大量、越界错误等</li>
<li>操作员或操作系统干预</li>
<li>父进程撤销其子进程</li>
<li>操作系统终止</li>
</ul>
</li>
</ul>
<h4 id="Linux-exit"><a href="#Linux-exit" class="headerlink" title="Linux::exit()"></a>Linux::exit()</h4><ul>
<li>Linux用exit(status)撤销一个进程，它停止当前进程的运行，清楚其使用的内存空间，销毁其在内核中的各种数据结构，但仍保留其PCB结构，等待父进程回收</li>
<li>进程的状态变为zombie</li>
<li>若父进程正在等待它的终止，则父进程可立即得到其返回的整数status</li>
<li>僵尸进程<ul>
<li>若子进程调用<code>exit()</code>，而父进程并没有调用<code>wait()</code>或<code>waitpid()</code>获取子进程的状态信息，那么子进程的PCB仍然保存在系统中。这种进程称之为僵尸进程</li>
</ul>
</li>
<li>孤儿进程<ul>
<li>当一个父进程由于正常完成工作而退出或由于其它情况被终止，它的一个或多个子进程却还在运行，那么那些子进程将称为孤儿进程</li>
<li>孤儿进程将被1号进程接管</li>
<li>1号进程定期清除它接管的僵尸进程</li>
</ul>
</li>
</ul>
<h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><ul>
<li>进程等待原语的形式<ul>
<li>当进程需要等待某一事件完成时，它可以调用等待原语挂起自己</li>
<li><code>susp(chan)</code></li>
<li>入口参数<code>chan</code>: 进程等待的原因</li>
</ul>
</li>
<li>进程等待原语的功能<ul>
<li>中止调用进程的执行，并加入到等待chan的等待队列中；最后使控制转进程调度</li>
<li>注意：并没有一个唯一特定的系统调用来将进程挂起，导致进程挂起的原因很多，所以很多系统调用例程都可能使用此原语讲当前进程挂起</li>
</ul>
</li>
<li>进程等待原语的实现<ul>
<li>入口-&gt;保护进程的CPU现场到PCB结构中-&gt;置该进程为“等待”状态-&gt;将该进程PCB结构插入到等待队列中-&gt;转进程调度</li>
</ul>
</li>
<li>进程等待的原因<ul>
<li>进程在执行过程中通过系统调用请求一些暂时得不到而必须等待的服务<ul>
<li>读写文件、访问共享内存等，这些服务操作系统可能无法立即提供</li>
<li>进程在执行过程中发出了I&#x2F;O请求，从而必须等待改I&#x2F;O请求的完成才能继续执行</li>
<li>因为进程间通讯的原因，一个进程在执行过程中必须等待另一个进程的消息才能继续往下执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Linux-wait"><a href="#Linux-wait" class="headerlink" title="Linux::wait"></a>Linux::wait</h4><ul>
<li><code>wait()</code>: 等待子进程结束<ul>
<li><code>pid=wait(int *status);</code></li>
<li>wait函数使父进程暂停执行，直到它的一个子进程结束位置，该函数的返回值是中止运行的子进程PID。参数status所指向的变量存放子进程的退出码，即从子进程的main函数返回的值或子进程中exit函数的参数。</li>
</ul>
</li>
<li><code>waitpid()</code>: 等待某个特定子进程结束<ul>
<li><code>waitpid(pit_t pid, int* status, int options)</code></li>
<li>pid为要等待的子进程的pid</li>
<li>status的含义与wait中的status相同</li>
</ul>
</li>
</ul>
<h3 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h3><ul>
<li>进程唤醒原语的形式<ul>
<li>当处于等待状态的进程所期待的事件到来时，由发现者进程使用唤醒原语唤醒它</li>
<li><code>wakeup(chan)</code></li>
<li>入口参数chan: 进程等待的原因</li>
</ul>
</li>
<li>进程唤醒原语的哦功能<ul>
<li>当进程等待的事件发生时，唤醒等待该事件的进程</li>
</ul>
</li>
<li>进程唤醒原语的实现<ul>
<li>入口-&gt;找到该等待队列-&gt;将队列首进程移除此等待队列-&gt;将该进程置为“就绪”状态，并将其PCB结构插入到就绪队列中-&gt;返回</li>
</ul>
</li>
<li>进程唤醒的时机<ul>
<li>I&#x2F;O完成时会产生一个中断，在该中断的中断处理函数中会唤醒等待该I&#x2F;O的进程</li>
<li>进程在等待某个被上锁的资源，当另一个进程通过系统调用来释放其施加在该资源上的锁的时候，系统调用服务例程会唤醒该进程</li>
<li>进程在等待另一个进程的消息，当另一个进程通过系统调用向其发送消息时，系统调用服务例程会唤醒该进程</li>
</ul>
</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul>
<li>进程切换的时机<ul>
<li>操作系统必须先获取处理器的使用权</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">机制</th>
<th align="left">原因</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td align="left">外部事件的发生</td>
<td align="left">响应异步的外部事件</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">当前指令无法继续执行</td>
<td align="left">处理器错误（如除零错）或者异常事件（如缺页）</td>
</tr>
<tr>
<td align="left">系统调用</td>
<td align="left">由当前运行的进程主动发出请求</td>
<td align="left">调用操作系统的服务例程</td>
</tr>
</tbody></table>
<ul>
<li>操作系统获得了处理器使用权后，一定会做进程切换吗？<ul>
<li>处理机状态切换(操作系统获得使用权的过程)<ul>
<li>设置程序计数器为中断处理例程的入口</li>
<li>从用户态切换到内核态，开始中断处理例程(包含特权指令)的执行</li>
</ul>
</li>
<li>处理机状态切换的开销很小，大多数情况下不会导致进程切换；但是如果当前进程的状态需要变为等待态或就绪态，就必须做进程切换</li>
</ul>
</li>
<li>进程切换要做哪些事情<ul>
<li>保存当前进程的上下文</li>
<li>改变当前进程的进程控制块内容，包括其状态的改变、离开运行态的原因等</li>
<li>将当前进程的控制块移到相应队列中，如就绪队列、事件等待队列等</li>
<li>选则一个合适的进程开始执行</li>
<li>更新被选则进程的控制块，将其状态置为运行态</li>
<li>恢复被选则进程的上下文</li>
</ul>
</li>
</ul>
<h2 id="进程之间的相互制约关系"><a href="#进程之间的相互制约关系" class="headerlink" title="进程之间的相互制约关系"></a>进程之间的相互制约关系</h2><p>进程间可能存在的交互关系</p>
<table>
<thead>
<tr>
<th align="left">无交互</th>
<th align="left">间接交互</th>
<th align="left">直接交互</th>
</tr>
</thead>
<tbody><tr>
<td align="left">竞争系统资源</td>
<td align="left">竞争临界资源</td>
<td align="left">通过通讯协作</td>
</tr>
<tr>
<td align="left">计算结果与其它进程无关。可能影响其它进程的时间特征</td>
<td align="left">可能影响其它进程的计算结果。可能影响其它进程的时间特征</td>
<td align="left">可能影响其它进程的计算结果。可能影响其它进程的时间特征</td>
</tr>
</tbody></table>
<h3 id="进程互斥的概念"><a href="#进程互斥的概念" class="headerlink" title="进程互斥的概念"></a>进程互斥的概念</h3><ul>
<li>临界资源<ul>
<li>特点: 当两个进程共用一个变量时，它们必须顺序地使用，一个进程对公用变量操作完毕后，另一个进程才能去访问和修改这一变量</li>
<li>定义: 一次仅允许一个进程使用的资源称为临界资源</li>
<li>e.g. 硬件: 输入机、打印机、磁带机; 软件: 公用变量、数据、表格、队列等</li>
</ul>
</li>
<li>临界区<ul>
<li>临界区是进程中对公共变量(或存储区)进行审查与修改的程序段，称为相对于该公共变量的临界区</li>
</ul>
</li>
<li>互斥<ul>
<li>操作系统中，当某进程正在访问某一存储区域时，就不允许其它进程来读出或者修改该存储区的内容，否则，就会发生后果无法估计的错误。进程间的这种相互制约关系称为互斥。</li>
<li>注意: 关于同一临界资源的临界区才需要互斥进入</li>
</ul>
</li>
<li>进程同步的定义<ul>
<li>并发进程在一些关键点上可能需要互相等待以互通消息，这种相互制约的等待于互通消息称为进程同步</li>
</ul>
</li>
<li>临界区的访问规则<ul>
<li>空闲则进入: 没有进程在临界区时，任何进程都可以进入临界区</li>
<li>忙则等待: 有进程在临界区时，其它进程均不能进入临界区</li>
<li>有限等待: 等待进入临界区的进程不能无限等待</li>
<li>让权等待(可选): 不能进入临界区的进程应释放CPU</li>
</ul>
</li>
</ul>
<h2 id="进程同步机构"><a href="#进程同步机构" class="headerlink" title="进程同步机构"></a>进程同步机构</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>用变量w代表某种资源的状态，称为锁。</p>
<ul>
<li>检测w的值(0或1)</li>
<li>如果w的值为1，继续检测</li>
<li>如果w的值为0，将锁位置1(表示占用资源)，进入临界区执行</li>
<li>临界资源使用完毕，将锁位置0</li>
</ul>
<h3 id="信号灯"><a href="#信号灯" class="headerlink" title="信号灯"></a>信号灯</h3><ul>
<li>信号灯是一个确定的二元组(s, q)，s是一个具有非负数值的整型变量，q是一个初始状态为空的队列。操作系统利用信号灯对并发进程和共享资源进行控制和管理。<ul>
<li>s &gt;&#x3D; 0，进程执行</li>
<li>s &lt; 0，进程停止执行</li>
<li>注意: 创建信号灯时应说明信号灯的意义和s的初值，且初值绝不能为负值</li>
</ul>
</li>
<li>P操作<ul>
<li>对信号灯s的P操作记为P(s)</li>
<li>P(s)是一个不可分隔的原语操作，即取信号灯值减1，若相减结果为负，则调用P(s)的进程被阻，并插入到该信号灯的等待队列中，否则该进程继续执行</li>
</ul>
</li>
<li>V操作<ul>
<li>对信号灯s的V操作记为V(s)</li>
<li>V(s)是一个不可分隔的原语操作，即取信号灯值加1，若相加结果大于零，进程继续执行，否则，唤醒在该信号灯等待队列上的第一个进程</li>
</ul>
</li>
<li>注意事项<ul>
<li>信号灯的初值不能为负值</li>
<li>必须成对使用P和V操作: 遗漏P操作则不能保证互斥访问，遗漏V操作则不能再使用临界资源之后将其释放(给其它等待的进程)</li>
<li>P、V操作不能次序错误、重复或遗漏</li>
</ul>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>进程通信是指进程之间传递信息及同步的机制</li>
<li>IPC的基本形式为以下两个操作<ul>
<li>发送消息: send(destination, message)</li>
<li>接收消息: recieve(source, message)</li>
</ul>
</li>
<li>基本通信流程<ul>
<li>在通信进程间建立通信链路</li>
<li>通过send&#x2F;receive交换信息</li>
</ul>
</li>
<li>同步方式: 阻塞VS非阻塞<ul>
<li>发送端阻塞，接收端非阻塞: 两端都阻塞，消息被接收后再将两端唤醒<ul>
<li>常用于要求进程进行强同步的场合</li>
</ul>
</li>
<li>发送端不阻塞，接收端阻塞: 发送端在发送完消息后继续执行，而接收端必须阻塞，直到接收到消息后才被唤醒<ul>
<li>最广泛使用的方案</li>
<li>问题: 可能导致消息重复发送，消耗系统资源，难以确定消息是否被接收</li>
</ul>
</li>
<li>发送端不阻塞，接收端不阻塞: 两端都不等待<ul>
<li>问题: 可能导致消息接收失败</li>
</ul>
</li>
</ul>
</li>
<li>寻址方式: 直接vs间接<ul>
<li>直接通信: 发送&#x2F;接收消息时必须指明消息的接收&#x2F;发送进程<ul>
<li><code>send(P, message)</code> 发送消息到进程P</li>
<li><code>receive(Q, message)</code> 从进程Q接收消息</li>
<li>通信双方必须同时存在</li>
</ul>
</li>
<li>间接通信: 消息被发送到一个操作系统维护的消息队列（信箱）中，接收端从其中取出消息<ul>
<li>每个消息队列具有一个唯一的标识</li>
<li>只有使用相同消息队列的进程才能够通信</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信箱的归属权-进程vs操作系统"><a href="#信箱的归属权-进程vs操作系统" class="headerlink" title="信箱的归属权: 进程vs操作系统"></a>信箱的归属权: 进程vs操作系统</h4><ul>
<li>信箱属于创建它的进程<ul>
<li>随着创建它的进程结束而结束</li>
<li>e.g. 端口</li>
</ul>
</li>
<li>信箱属于操作系统<ul>
<li>与使用它的进程是否结束无关，必须通过明确的命令撤销</li>
<li>e.g. 消息队列</li>
</ul>
</li>
</ul>
<h4 id="Linux-共享内存"><a href="#Linux-共享内存" class="headerlink" title="Linux: 共享内存"></a>Linux: 共享内存</h4><p>共享内存是把同一片物理内存区域同时映射到多个进程的地址空间的通信机制</p>
<ul>
<li>共享内存的创建<ul>
<li><code>int shmget(key_t key, int size, int shmflg)</code></li>
<li><code>key</code>: 键值，多个需要使用同一共享内存的进程用相同的key来创建或获取该共享内存</li>
<li><code>size</code>: 共享内存的大小</li>
<li><code>shmflg</code>: IPC_CREAT | 0666</li>
</ul>
</li>
<li>共享内存的绑定<ul>
<li><code>void *shmat(int shmid, char* shmaddr, int shmflg)</code></li>
<li><code>shmid</code>: 共享内存句柄，shmget调用的返回值</li>
<li>shmaddr: 一般用NULL</li>
<li>shmflg: SHM_R | SHM_W</li>
</ul>
</li>
<li>共享内存的释放<ul>
<li><code>int shmctl(int shmid, int cmd, struct shmid_ds* buf)</code></li>
<li><code>shmid</code>: 共享内存句柄，即shmget函数的返回值</li>
<li><code>cmd</code>: 控制命令</li>
<li><code>buf</code>: 一个结构指针，它指向共享内存模式和访问权限的结构</li>
</ul>
</li>
</ul>
<h4 id="Linux-信号量"><a href="#Linux-信号量" class="headerlink" title="Linux: 信号量"></a>Linux: 信号量</h4><ul>
<li>信号量的创建<ul>
<li><code>int semget(key_t key, int num_sems, int sem_flags)</code></li>
<li><code>key</code>: 用来允许多个进程访问相同信号量的整数值，它们通过相同的key值来调用semget</li>
<li><code>num_sems</code>: 所需要的信号量数目。Semget创建的是一个信号量数组，数组元素的个数即为num_sems</li>
<li><code>sem_flags</code>: 一个标记集合，与open函数的标记十分类似。低九位是信号的权限，其作用与文件权限类似。另外，这些标记可以与IPC_CREATE进行或操作来创建新的信号量，一般用IPC_CREATE | 0666</li>
</ul>
</li>
<li>信号量的控制<ul>
<li><code>int semctl(int sem_id, int sem_num, int command, ...)</code></li>
<li><code>sem_id</code>: 是由semget所获得的信号量标识符</li>
<li><code>sem_num</code>: 是信号量数组元素的下标，即指定对第几个信号量进行控制</li>
<li><code>command</code>: 要执行的动作，有多个不同的command值可用于semctl，常用的两个command值为<ul>
<li>SETVAL: 用于为信号量赋初值，其值通过第四个参数指定</li>
<li>IPC_RMID: 当信号量不再需要时用于删除一个信号量标识</li>
</ul>
</li>
<li>如果有第四个参数，则是union semun，该联合定义如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span>* <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>信号量的操作<ul>
<li><code>int semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops)</code></li>
<li><code>sem_id</code>: 要操作的信号量的标识符</li>
<li><code>sem_ops</code>: 一个指向结构数组的指针，该结构包含操作的参数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">  <span class="type">short</span> sem_num;  <span class="comment">// 数组下标</span></span><br><span class="line">  <span class="type">short</span> sem_op;  <span class="comment">// 操作，-1或1</span></span><br><span class="line">  <span class="type">short</span> sem_flg;  <span class="comment">// 0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>num_sem_ops</code>: 操作数量，一般为1</li>
</ul>
</li>
</ul>
<h4 id="Linux-信号"><a href="#Linux-信号" class="headerlink" title="Linux: 信号"></a>Linux: 信号</h4><ul>
<li>信号机制是一种进程间的软件中断信号通知和异步处理机制</li>
<li>信号机制是在软件层次上对中断机制的一种模拟</li>
<li>进程在很多情况下会都接收到软中断信号<ul>
<li>用户在终端按下某些特殊键: e.g. ^C,终端进程会发送SIGINT信号给前台进程</li>
<li>硬件异常: e.g. 除零，CPU产生异常，内核处理完该已成后会发送SIGFPE信号给进程</li>
<li>内核检测到某种软件条件: 如闹钟超时，会发送SIGALRM信号给进程</li>
<li>显式调用kill函数或kill命令发送信号给某个进程</li>
</ul>
</li>
</ul>
<h4 id="信号机制的功能"><a href="#信号机制的功能" class="headerlink" title="信号机制的功能"></a>信号机制的功能</h4><ul>
<li>预制对信号的处理方式<ul>
<li>忽略: 忽略该信号不做处理，SIGKIL和SIGSTOP不能被忽略</li>
<li>捕获: 通知内核在某种信号发生时，调用用户指定的函数进行处理</li>
<li>执行默认动作: 编译器预置了各个信息的处理函数</li>
</ul>
</li>
<li>信号发送: 发送进程把信号送到指定进程的信号域的某一位上，如果目标进程正在一个可被中断的优先级上睡眠，系统将其唤醒</li>
<li>信号处理: 收到信号的进程在由核态返回到用户态前，按预置的处理方式完成对相应事件的处理</li>
<li>不足: 传送的信息量小，只有一个信号类型</li>
</ul>
<h4 id="Linux-管道"><a href="#Linux-管道" class="headerlink" title="Linux: 管道"></a>Linux: 管道</h4><ul>
<li>管道是进程间基于文件的一种间接通信机制</li>
<li>管道是半双工的，数据只能单向流动</li>
<li>管道对于管道两端的进程而言就是一个文件，写管道时内容添加在文件末尾，读管道则从文件头部读出</li>
<li>无名管道<ul>
<li>无名管道没有名字，只有一组文件描述符</li>
<li>子进程从父进程继承文件描述符</li>
<li>只能用于具有亲缘关系的进程间的通信</li>
</ul>
</li>
<li>命名管道<ul>
<li>管道有文件名，允许无亲缘关系的进程通过访问管道文件进行通信</li>
</ul>
</li>
<li>与管道相关的系统调用<ul>
<li>创建无名管道: <code>int pipefd[2]; int pipe(pipefd)</code><ul>
<li><code>pipedf[0]</code>只能用于读，接收进程应关闭写入端，即<code>close(pipefd[1])</code></li>
<li><code>pipefd[1]</code>只能用于写，发送进程应关闭读取端，即<code>close(pipefd[0])</code></li>
</ul>
</li>
<li>将数据写入管道: <code>write()</code><ul>
<li>管道长度受到限制，管道满时写操作将被阻塞，直到管道中的数据被读取</li>
<li><code>fcntl()</code>可将管道写模式设置为非阻塞模式</li>
</ul>
</li>
<li>从管道读取数据: <code>read()</code><ul>
<li>数据被读取后将自动从管道中清楚，若管道中没有数据则读操作将被阻塞</li>
<li><code>fcntl()</code>可将管道读模式设置为非阻塞模式</li>
</ul>
</li>
<li>关闭管道: <code>close()</code><ul>
<li>所有读端口都关闭时，在管道上进行写操作的进程将受到SIGPIPE信号</li>
<li>所有写端口都关闭时，在管道上进行读操作的<code>read()</code>函数将返回0</li>
</ul>
</li>
<li>创建命名管道<ul>
<li><code>int mknod(char* pathname, mode_t mod, dev_t dev);</code></li>
<li><code>int mkfifo(char* pathname, mode_t mode);</code></li>
</ul>
</li>
<li>命名管道的使用<ul>
<li>命名管道必须先调用<code>open()</code>将其打开，其它与无名管道相似</li>
<li>以只读方式(O_RDONLY)打开时，进程将被阻塞直到有写方打开管道</li>
<li>以只写方式(O_WRONLY)打开时，进程将被阻塞直到有读方打开管道</li>
</ul>
</li>
<li>命名管道的删除<ul>
<li><code>int unlink(char* pathname)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Linux-消息队列"><a href="#Linux-消息队列" class="headerlink" title="Linux: 消息队列"></a>Linux: 消息队列</h4><ul>
<li>消息队列是消息的链接表，存放在内核中并由消息队列标识符表示</li>
<li>每一条消息都由自己的消息类型，每种类型的消息都被对应的链表所维护</li>
<li>消息队列的创建<ul>
<li><code>int msgget(key_t key, int msgflg)</code></li>
<li><code>key</code>: 键值，多个需要使用同一消息队列的进程用相同的key来创建或获取该消息队列</li>
<li><code>msgflg: flag | mode</code><ul>
<li><code>flag</code>: 可以是0或者IPC_CREATE(不存在就创建)</li>
<li><code>mode</code>: 同文件权限一样</li>
</ul>
</li>
</ul>
</li>
<li>消息的发送<ul>
<li><code>int msgsnd(int msqid, const void* msgp, size_t msgsz, int msgflg)</code></li>
<li><code>msqid</code>: 消息队列ID</li>
<li><code>msgp</code>: 存放消息的结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> mtype;  <span class="comment">// 消息的类型，必须&gt;0</span></span><br><span class="line">  <span class="type">char</span> mtext[<span class="number">1</span>];  <span class="comment">// 消息内容，长度可变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>msgsz</code>: 要发送的消息的大小，不包括消息的类型占用的4个字节</li>
<li><code>msgflg</code>: 如果是0，当消息队列为满时msgsnd会阻塞；如果是IPC_NOWAIT，当消息队列为满时不阻塞，立即返回</li>
</ul>
</li>
<li>消息的接收<ul>
<li><code>int msgrcv(int msqid, void* msgp, size_t msgsz, long msgtype, int msgflg);</code></li>
<li><code>msqid</code>: 消息队列ID</li>
<li><code>msgp</code>: 存放消息的结构体</li>
<li><code>msgsz</code>: 要接收的消息的大小，不包括消息的类型占用的4个字节</li>
<li><code>msgtyp</code>: 要接收的消息类型<ul>
<li>&#x3D;0: 返回消息队列中的第一条消息</li>
<li><blockquote>
<p>0: 返回消息队列中类型等于msgtyp的第一条消息</p>
</blockquote>
</li>
<li>&lt;0: 返回其类型小于或等于msgtyp绝对值的最小的一个消息</li>
</ul>
</li>
<li><code>msgflg</code>: 如果是0，则没有指定类型的消息时会阻塞；如果是IPC_NOWAIT，则不阻塞，立即返回</li>
</ul>
</li>
<li>消息队列的删除<ul>
<li><code>int msgctl(int msqid, int cmd, struct msqid_ds* buf);</code></li>
<li><code>msqid</code>: 消息队列ID</li>
<li><code>cmd</code>: 控制命令，IPC_RMID表示删除</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>动机: 允许多个合作的“进程”共享同一个地址空间，这样它们既可以并发执行，又可以方便的通信和共享数据</li>
<li>传统的进程模型<ul>
<li>进程是资源占用的基本单位: 进程拥有主存、I&#x2F;O通道、I&#x2F;O设备、文件等系统资源的使用权</li>
<li>进程是调度&#x2F;执行的基本单位: 操作系统以进程为单位进行处理机的调度</li>
<li>不足:<ul>
<li>进程创建开销大</li>
<li>进程切换开销大</li>
<li>进程通信代价大</li>
<li>进程之间的并发粒度较粗，并发度不高</li>
<li>不适合客户&#x2F;服务器计算的要求</li>
</ul>
</li>
</ul>
</li>
<li>多线程方案的解决思路<ul>
<li>把进程的两项功能: “独立分配资源”与“被调度执行”分离开来</li>
<li>进程作为系统资源分配和保护的独立单位</li>
<li>在进程内增加一类实体: 线程</li>
<li>线程作为调度的基本单位</li>
<li>同一进程内的线程共享相同的地址空间</li>
</ul>
</li>
</ul>
<h3 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h3><ul>
<li><p>线程是进程中的一条执行路径</p>
</li>
<li><p>单个进程可创建多个同时存在的线程</p>
</li>
<li><p>每个线程又自己私用的堆栈和处理机执行环境</p>
</li>
<li><p>同一进程中的多个线程共享分配给该进程的内存</p>
</li>
<li><p>线程的特点</p>
<ul>
<li>优点<ul>
<li>创建和撤销一个线程比创建一个进程的开销要小得多(10~100倍)</li>
<li>因为共享地址空间和数据，线程间通信十分方便且高效</li>
<li>同一个进程的线程间切换速度快(纳秒级)</li>
<li>在进程内创建多线程，可以提高系统的并性处理能力，加快进程的处理速度</li>
</ul>
</li>
<li>缺点<ul>
<li>一个线程崩溃，会导致其所属进程内的所有线程崩溃</li>
</ul>
</li>
</ul>
</li>
<li><p>多核与多线程</p>
<ul>
<li>应用在多核处理器上所能取得的性能上的好处，实际上取决于它对多处理器资源的利用能力</li>
<li>设<code>f</code>为程序中能并性的部分的运行事件在整个程序运行事件中的占比</li>
<li><code>加速比</code> &#x3D; 在单处理器上执行程序的时间 &#x2F; 在N个处理器上执行程序的时间 &#x3D; $\frac{1}{1-f+\frac{f}{N}}$</li>
</ul>
</li>
<li><p>线程的状态</p>
<ul>
<li>创建</li>
<li>就绪</li>
<li>运行</li>
<li>等待</li>
<li>终止</li>
</ul>
</li>
</ul>
<h4 id="线程的实现-用户级线程"><a href="#线程的实现-用户级线程" class="headerlink" title="线程的实现: 用户级线程"></a>线程的实现: 用户级线程</h4><ul>
<li>所有线程管理的工作都由应用(进程)自己完成，内核不知道线程的存在</li>
<li>缺点: 一个线程阻塞导致整个进程阻塞，且难以利用多核</li>
</ul>
<h4 id="线程的实现-内核级线程"><a href="#线程的实现-内核级线程" class="headerlink" title="线程的实现: 内核级线程"></a>线程的实现: 内核级线程</h4><ul>
<li>所有线程的管理功能由操作系统内核来完成</li>
<li>e.g. windows NT</li>
<li>缺点: 线程控制时产生处理机状态切换</li>
</ul>
<h4 id="两种实现方式的对比"><a href="#两种实现方式的对比" class="headerlink" title="两种实现方式的对比"></a>两种实现方式的对比</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">用户级线程</th>
<th align="left">核心级线程</th>
</tr>
</thead>
<tbody><tr>
<td align="left">管理</td>
<td align="left">线程库</td>
<td align="left">内核</td>
</tr>
<tr>
<td align="left">调度单位</td>
<td align="left">进程</td>
<td align="left">线程</td>
</tr>
<tr>
<td align="left">切换速度</td>
<td align="left">同一进程内线程间切换，由线程库完成，速度较快</td>
<td align="left">由内核完成，速度较慢</td>
</tr>
<tr>
<td align="left">系统调用</td>
<td align="left">内核视为整个用户进程的行为</td>
<td align="left">内核只视为该进程的行为</td>
</tr>
<tr>
<td align="left">阻塞</td>
<td align="left">用户进程</td>
<td align="left">线程</td>
</tr>
<tr>
<td align="left">优点</td>
<td align="left">线程切换不调用内核，切换速度较快，调度算法可由应用程序决定</td>
<td align="left">对多处理器，可同时调度统一进程的多个线程；阻塞繁盛在线程级</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">阻塞发生在进程级；难以利用多处理器(多核)</td>
<td align="left">同一进程内的线程切换速度慢</td>
</tr>
</tbody></table>
<h4 id="Linux-线程创建"><a href="#Linux-线程创建" class="headerlink" title="Linux: 线程创建"></a>Linux: 线程创建</h4><ul>
<li><code>pthread_create(pthread_t *thread, pthread_attr_t* attr, void *(*start_routine)(void*), void* arg);</code></li>
<li><code>thread</code>指向返回线程标识符的指针</li>
<li><code>attr</code>设置线程属性</li>
<li><code>start_routine</code>线程运行函数地址</li>
<li><code>arg</code>运行函数的参数</li>
</ul>
<h4 id="Linux-线程等待"><a href="#Linux-线程等待" class="headerlink" title="Linux: 线程等待"></a>Linux: 线程等待</h4><ul>
<li><code>int pthread_join(pthread_t thread, void** thread_return);</code></li>
<li><code>thread</code>为被等待的线程标识符</li>
<li><code>thread_return</code>为一个用户定义的指针，它可以用来存储被等待线程的返回值。</li>
<li>这个函数是一个线程阻塞的函数，调用它的函数将一直等待直到被等待的线程结束为止，当函数返回时，被等待线程的资源被回收</li>
</ul>
<h1 id="资源分配与调度"><a href="#资源分配与调度" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h1><h2 id="资源管理概述"><a href="#资源管理概述" class="headerlink" title="资源管理概述"></a>资源管理概述</h2><ul>
<li>资源管理目标<ul>
<li>保证资源的高利用率</li>
<li>在“合理”的时间内使所有顾客有获得所需资源的机会</li>
<li>对不可共享的资源实时互斥使用</li>
<li>防止由资源分配不当引起的死锁</li>
</ul>
</li>
<li>资源管理功能<ul>
<li>资源数据结构的描述<ul>
<li>包含资源的物理名、逻辑名、类型、地址、分配状态等信息</li>
</ul>
</li>
<li>确定资源的分配原则(调度原则)<ul>
<li>决定资源应该分给谁，何时分配，分配多少等问题</li>
</ul>
</li>
<li>实时资源分配<ul>
<li>执行资源分配、资源回收工作</li>
</ul>
</li>
<li>存取控制和安全保护<ul>
<li>对资源的存取进行控制并对资源实施安全保护措施</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟资源"><a href="#虚拟资源" class="headerlink" title="虚拟资源"></a>虚拟资源</h3><ul>
<li>操作系统对资源区分两种不同的概念<ul>
<li>物理资源(实资源)</li>
<li>虚拟资源(逻辑资源): 某些物理资源有限，采用其它物理资源改造成该类资源使用</li>
</ul>
</li>
<li>虚拟技术的目的<ul>
<li>方便用户使用</li>
<li>资源可动态分配，提高资源利用率</li>
</ul>
</li>
</ul>
<p>计算机系统中的物理资源与虚拟资源分析</p>
<table>
<thead>
<tr>
<th align="left">资源类别</th>
<th align="left">物理资源</th>
<th align="left">虚拟(逻辑)</th>
<th align="left">映射</th>
</tr>
</thead>
<tbody><tr>
<td align="left">处理机</td>
<td align="left">CPU</td>
<td align="left">进程</td>
<td align="left">进程调度</td>
</tr>
<tr>
<td align="left">存储器</td>
<td align="left">主存</td>
<td align="left">虚存(程序地址空间)</td>
<td align="left">地址映射</td>
</tr>
<tr>
<td align="left">设备</td>
<td align="left">外部设备</td>
<td align="left">逻辑设备&#x2F;虚拟设备</td>
<td align="left">设备分配；动态映射</td>
</tr>
<tr>
<td align="left">信息</td>
<td align="left">物理文件</td>
<td align="left">逻辑文件</td>
<td align="left">磁盘空间分配，文件目录查找</td>
</tr>
</tbody></table>
<h2 id="资源分配机构和策略"><a href="#资源分配机构和策略" class="headerlink" title="资源分配机构和策略"></a>资源分配机构和策略</h2><ul>
<li>资源描述器<ul>
<li>定义: 描述各类资源的最小分配单位的数据结构称为资源描述器</li>
<li>e.g. 主存分配方法中，最小分配单位为主存分区</li>
<li>内容: 资源名、资源类型、最小分配单位的大小、地址、分配标志、描述其链接信息、存取权限、密级、存取时间</li>
</ul>
</li>
<li>资源信息块<ul>
<li>定义: 描述某类资源的请求者、可用资源和资源分配程序等必要信息的数据结构</li>
<li>内容<ul>
<li>等待队列头指针-&gt;请求者队列</li>
<li>可利用资源队列头指针-&gt;可利用资源队列</li>
<li>资源分配程序入口地址-&gt;资源分配程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h3><ul>
<li>先请求先服务<ul>
<li>每一个新产生的请求均排在队尾</li>
<li>当资源可用时，取队首元素，并满足其需要</li>
<li>排序原则: 按请求的先后次序排序</li>
</ul>
</li>
<li>优先调度<ul>
<li>对每一个进程指定一个优先级</li>
<li>每一个新产生的请求，按其优先级的高低插到相应的为止</li>
<li>当资源可用时，取对手元素，并满足其需要</li>
<li>排序原则: 按优先级的高低排序</li>
</ul>
</li>
<li>针对设备特性的调度<ul>
<li>e.g. 磁盘调度算法<ul>
<li>最短寻道时间优先SSTF</li>
<li>扫描算法SCAN</li>
<li>循环扫描算法CSCAN</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><ul>
<li>寻道时间$T_s$<ul>
<li>把磁臂(磁头)移动到指定磁道上所经历的时间。该事件是启动磁臂的时间$s$与磁头移动$n$条磁道所花费的时间之和。$T_s &#x3D; m \times n + s$</li>
<li>$m$是一常数，与磁盘驱动器的速度有关</li>
</ul>
</li>
<li>旋转延迟时间$T_{\tau}$<ul>
<li>指定扇区移动到磁头下面所经历的时间</li>
</ul>
</li>
<li>传输时间$T_t$<ul>
<li>把数据从磁盘读除或向磁盘写入数据所经历的时间。$T_t$的大小与每次所读&#x2F;写的字节数$b$和旋转速度有关。$T_t &#x3D; \frac{b}{rN}$</li>
<li>其中，$r$为磁盘每秒钟的转数，$N$为一条磁道上的字节数。</li>
</ul>
</li>
<li>访问时间$T_a$表示为$T_a &#x3D; T_s + T_T + T_t$</li>
</ul>
<h5 id="最短寻道时间优先-SSTF"><a href="#最短寻道时间优先-SSTF" class="headerlink" title="最短寻道时间优先(SSTF)"></a>最短寻道时间优先(SSTF)</h5><ul>
<li>选则从当前磁头位置所需寻道时间最短的请求</li>
<li>特点: 寻道性能比FCFS好，但不能保证寻道时间最短，而且可能引起某些请求的饥饿</li>
</ul>
<h5 id="扫描算法-SCAN"><a href="#扫描算法-SCAN" class="headerlink" title="扫描算法(SCAN)"></a>扫描算法(SCAN)</h5><ul>
<li>磁头从磁盘的一端开始向另一端移动，沿途相应访问的请求，直到到达了磁盘的另一端，此时磁头反向移动并继续相应服务请求。有时也称为电梯算法</li>
<li>特点: 寻道性能较好，避免了饥饿，但不利于远离磁头一端的访问请求</li>
</ul>
<h5 id="循环扫描算法-CSCAN"><a href="#循环扫描算法-CSCAN" class="headerlink" title="循环扫描算法(CSCAN)"></a>循环扫描算法(CSCAN)</h5><ul>
<li>规定磁头从磁盘的一端开始向另一端单向移动，沿途相应访问的请求</li>
<li>特点: 消除了对两端磁道请求的不公平</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>定义: 在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，称这一组进程产生了死锁。</p>
<h4 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h4><ul>
<li>约定$P_i -&gt; R_j$为请求边，表示进程$P_i$申请资源$R_j$中的一个资源得不到满足而处于等待$R_j$类资源的状态，该有向边从进程开始指向方框边缘，表示进程$P_i$申请$R_j$类中的一个资源。</li>
<li>$R_j -&gt; P_i$为分配边，表示$R_j$类中的一个资源已经倍进程$P_i$占用</li>
</ul>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ol>
<li>互斥条件: 涉及的资源是非共享的，即为临界资源</li>
<li>不剥夺条件(非抢占): 进程所获得的资源在未使用完毕之前，不能被其它进程强行夺走</li>
<li>占有并等待(部分分配): 进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源</li>
<li>环路条件(循环等待): 存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求</li>
</ol>
<h3 id="解决死锁问题的策略"><a href="#解决死锁问题的策略" class="headerlink" title="解决死锁问题的策略"></a>解决死锁问题的策略</h3><ul>
<li>破坏产生死锁的四个必要条件之一<ul>
<li>预防死锁</li>
<li>避免死锁</li>
<li>死锁的检测与解除</li>
</ul>
</li>
<li>死锁预防: 静态分配策略<ul>
<li>在作业调度时为选中的作业分配它所需要的所有资源，资源一旦分配给该作业后，在其整个运行期间这些资源为它独占</li>
<li>缺点<ul>
<li>一个用户(进程)在程序运行之前很难提出将要使用的全部设备</li>
<li>设备(资源)的浪费太大，有些资源在进程运行过程中可能只有很少的时间会用到，有的甚至根本不会用到，例如条件分支语句</li>
</ul>
</li>
</ul>
</li>
<li>死锁预防: 有序资源分配法<ul>
<li>系统中所有资源都给定一个唯一的编号</li>
<li>所有分配请求必须以上升的次序进行</li>
<li>当遵守上升次序的规则时，若有资源可用，则予以分配；否则，请求者等待</li>
<li>优点: 相对于静态分配法，提高了资源使用效率</li>
<li>缺点: 进程实际使用资源的顺序不一定与资源的编号相一致</li>
</ul>
</li>
<li>死锁避免: 银行家算法<ul>
<li>对每个资源请求进行检查，看是否会导致不安全状态。若是，则拒绝该请求；否则便满足该请求</li>
<li>检查状态是否安全的方法是看其是否有足够的资源满足一个距最大需求最近的客户，如此反复下去。如果所有投资最终都被收回，则该状态是安全状态，最初的请求可以批准</li>
<li>按某种顺序并发进程都能获得最大资源而顺序完成的序列称为安全序列</li>
</ul>
</li>
</ul>
<h5 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h5><p>资源的分配不加任何限制，也不采取死锁避免措施。系统定时地运行一个”死锁检测“程序，判断系统内是否已经出现死，如果检测到系统已经发生了死锁，再采取措施解除它。</p>
<h4 id="基于资源分配图检测系统死锁状态"><a href="#基于资源分配图检测系统死锁状态" class="headerlink" title="基于资源分配图检测系统死锁状态"></a>基于资源分配图检测系统死锁状态</h4><ul>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的虫咬条件，环路中的进程便为死锁进程</li>
<li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件</li>
</ul>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><ul>
<li>立即结束所有进程的执行，并重启操作系统</li>
<li>撤销陷于死锁的所有进程</li>
<li>逐个撤销陷于死锁的进程，回收其资源，直至死锁解除</li>
<li>剥夺陷入死锁的进程占用 资源，但并不撤销它，直至死锁解除</li>
<li>根据系统保存的checkpoint，让所有进程回退，直到足以解除死锁</li>
</ul>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h2 id="处理机的多级调度"><a href="#处理机的多级调度" class="headerlink" title="处理机的多级调度"></a>处理机的多级调度</h2><ul>
<li>长期调度: 决定是否为作业创建新进程，并将其加入将待执行的进程集合中(作业调度)(宏观调度)</li>
<li>中期调度: 决定是否将一个挂起进程加载进内存。(换入调度)(微观调度)</li>
<li>短期调度: 决定哪个就绪进程&#x2F;线程将被处理器执行(进程调度)(微观调度)</li>
</ul>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><h3 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h3><ul>
<li>作业名</li>
<li>资源要求<ul>
<li>估计执行时间</li>
<li>最迟完成时间</li>
<li>要求的主存数量</li>
<li>要求外设的类型及台数</li>
<li>要求文件量和输出量</li>
</ul>
</li>
<li>类型<ul>
<li>控制方式(联机&#x2F;脱机)</li>
<li>作业类型(计算型&#x2F;IO型)</li>
</ul>
</li>
<li>资源使用情况<ul>
<li>进入系统时间</li>
<li>开始执行时间</li>
<li>已执行时间</li>
<li>主存地址</li>
<li>外设台号</li>
</ul>
</li>
<li>优先级</li>
<li>状态</li>
</ul>
<h3 id="作业调度的目标"><a href="#作业调度的目标" class="headerlink" title="作业调度的目标"></a>作业调度的目标</h3><ul>
<li>调度实质上式一个策略问题，设定的目标往往是相互冲突的<ul>
<li>单位时间内运行尽可能多的作业</li>
<li>使处理机尽可能保持”忙碌”</li>
<li>使各种I&#x2F;O设备得以充分利用</li>
<li>对所有的作业都是公平合理的</li>
</ul>
</li>
<li>考虑因素<ul>
<li>调度算法应与系统设计目标保持一致</li>
<li>注意系统资源均衡使用</li>
<li>保证提交的作业在截至时间内完成</li>
<li>设法缩短作业平均周转时间</li>
</ul>
</li>
</ul>
<h3 id="作业调度算法性能的衡量指标"><a href="#作业调度算法性能的衡量指标" class="headerlink" title="作业调度算法性能的衡量指标"></a>作业调度算法性能的衡量指标</h3><ul>
<li>周转时间<ul>
<li>定义: 一个作业提交给计算机系统到该作业的结果返回给用户所需要的时间</li>
<li>$t_i &#x3D; tc_i - ts_i$<ul>
<li>$t_i$: 作业i的周转时间</li>
<li>$ts_i$: 作业i的提交时间</li>
<li>$tc_i$: 作业i的完成时间</li>
</ul>
</li>
<li>意义: 说明作业i在系统中停留时间的长短</li>
<li>平均周转时间: $t&#x3D;\frac{1}{n}\sum _{i&#x3D;1}^n t_i$</li>
</ul>
</li>
<li>带权周转时间<ul>
<li>定义: 一个作业的周转时间与其运行时间的比值</li>
<li>$w_i &#x3D; \frac{t_i}{tr_i}$<ul>
<li>$tr_i$为作业的实际运行时间</li>
</ul>
</li>
<li>意义: 说明作业i在系统中相对等待时间</li>
<li>平均带权周转时间$w&#x3D;\frac{1}{n}\sum _{i&#x3D;1}^n w_i$</li>
</ul>
</li>
</ul>
<h3 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h3><ul>
<li>先来先服务调度算法(FCFS)<ul>
<li>策略: 按作业来到的先后次序进行调度</li>
<li>特点<ul>
<li>优先考虑系统中等待时间最长的作业，不管运行特性</li>
<li>简单，容易实现</li>
<li>性能指标不稳定，波动大</li>
</ul>
</li>
</ul>
</li>
<li>短作业优先调度算法(SJF: Shortest Job First)<ul>
<li>策略: 按照作业请求运行的时间长短进行调度，优先选则短作业</li>
<li>特点: 容易实现，系统吞吐量高<ul>
<li>只照顾短作业，而没有考虑长作业的利益；需要预知作业的运行时间</li>
</ul>
</li>
</ul>
</li>
<li>响应比高者优先调度算法(HRN: Highest Response Ratio Next)<ul>
<li>响应时间&#x3D;开始执行时间-提交时间，可以反映作业等待了多久，等待时间长的就会更能够先执行</li>
<li>在我们的版本中，响应时间&#x3D;周转时间</li>
<li>响应比&#x3D;响应时间&#x2F;运行时间</li>
<li>策略: 优先选则响应比高者作业运行</li>
<li>特点: 前两种算法的一种折衷，既照顾了短作业，又不使作业等待时间过长</li>
</ul>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h4 id="进程调度-分派结构"><a href="#进程调度-分派结构" class="headerlink" title="进程调度&#x2F;分派结构"></a>进程调度&#x2F;分派结构</h4><ul>
<li>调度: 在众多处于就绪状态的进程中，按一定的原则选则一个进程</li>
<li>分派: 当处理机空闲时，移除就绪队列中第一个进程，并赋予它使用处理机的权力</li>
</ul>
<h3 id="进程调度的功能"><a href="#进程调度的功能" class="headerlink" title="进程调度的功能"></a>进程调度的功能</h3><ul>
<li>记录进程的有关情况和状态特征</li>
<li>决定调度策略<ul>
<li>优先调度原则: 进程就绪队列按进程优先级高低排序</li>
<li>先来先服务原则: 进程就绪队列按进程来到的先后次序排序</li>
</ul>
</li>
<li>实施处理机的分配和回收</li>
</ul>
<h4 id="CPU调度时机"><a href="#CPU调度时机" class="headerlink" title="CPU调度时机"></a>CPU调度时机</h4><ul>
<li>当一个进程从运行态切换称等待态时</li>
<li>当一个进程从运行状切换称就绪态时</li>
<li>当一个进程终止时</li>
</ul>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ul>
<li>进程调度方式是指当一个进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要运行，系统如何分配处理机<ul>
<li>非剥夺方式: 正在执行的进程继续执行，直到该进程完成或发生某事件而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程</li>
<li>剥夺方式: 当“重要而紧迫”的进程一到，便暂停正在执行的进程，立即把处理机分配给优先级更高的进程</li>
</ul>
</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="优先数调度算法"><a href="#优先数调度算法" class="headerlink" title="优先数调度算法"></a>优先数调度算法</h4><ul>
<li>预先确定各进程的优先数，系统把处理机的使用权赋予就绪队列中具备最高优先权(优先数和一定的优先级相对应)的就绪进程</li>
<li>优先数的分类及确定<ul>
<li>静态优先数<ul>
<li>在进程被创建时确定，且一经确定后再整个进程运行期间不再改变</li>
<li>确定<ul>
<li>优先数根据进程所需使用的资源来计算</li>
<li>优先数基于程序运行时间估计</li>
<li>优先数基于进程的类型</li>
</ul>
</li>
</ul>
</li>
<li>动态优先数<ul>
<li>进程优先数再进程运行期间可以改变</li>
<li>确定<ul>
<li>进程使用CPU超过一定数值时，降低优先数</li>
<li>进程进行I&#x2F;O操作后，增加优先数</li>
<li>进程等待时间超过一定数值时，提高优先数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="循环轮转调度算法"><a href="#循环轮转调度算法" class="headerlink" title="循环轮转调度算法"></a>循环轮转调度算法</h4><ul>
<li>当CPU空闲时，选取就绪队列首元素，赋予一个时间片，当时间片用完时，该进程转为就绪态并进入就绪队列末端</li>
<li>时间片的取值<ul>
<li>太小，多数进程不能再一个时间片内运行完毕，切换就会频繁，开销显著增大，从系统效率来看，时间片取大一点好</li>
<li>太大，随着就绪队列里进程数目增加，轮转依次的总时间增大，对进程的响应速度变慢</li>
<li>为了满足响应时间要求，要么限制就绪进程数量，要么采用动态时间片算法，根据分在状况，及时调整时间片的大小</li>
</ul>
</li>
<li>简单循环轮转调度<ul>
<li>就绪队列中的所有进程以等速度向前推进$q&#x3D;\frac{t}{n}$，t为响应时间，n为进入系统的进程数目</li>
</ul>
</li>
<li>可变时间片轮转调度: 时间片的大小是可变的，系统可根据系统中当前的进程数来确定时间片的大小<ul>
<li>理论上克服了系统中进程数很少时系统开销大的特点，但修改时间片的大小、统计系统进程的数量也需要消耗系统时间</li>
<li>调整时间片大小的周期若太大，等于是固定时间片；太小，系统开销很大，得不偿失</li>
</ul>
</li>
<li>多重时间片循环调度: 又称反馈循环队列或多队列策略。<ul>
<li>将就绪进程分为两级或多级，系统相应建立两个或多个就绪进程队列，较高优先级的队列一般分配给较短的时间片</li>
<li>处理器调度先从高级就绪进程队列中选取可占有处理器的进程，只有在其为空时，才从较低级的就绪进程队列中选取</li>
</ul>
</li>
</ul>
<h4 id="时间片与优先数混合调度"><a href="#时间片与优先数混合调度" class="headerlink" title="时间片与优先数混合调度"></a>时间片与优先数混合调度</h4><ul>
<li>队列结构<ul>
<li>I&#x2F;O等待队列: 一个进程如果请求I&#x2F;O: 则进入I&#x2F;O等待队列</li>
<li>低优先级就绪队: 一个进程如果在运行中超过了它的时间片，就进入低优先就绪队列</li>
<li>高优先就绪队列: 当进程从等待状态变为就绪状态时，则进入高优先就绪队列</li>
</ul>
</li>
<li>调度算法: 采用优先调度与时间片调度相结合的调度策略<ul>
<li>当CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选则一个进程运行，分配时间片为100ms</li>
<li>当CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选则一个进程运行，分配时间片为500ms</li>
<li>调度效果: 优先照顾了I&#x2F;O量大的进程</li>
</ul>
</li>
</ul>
<h3 id="Linux进程调度目标和特点"><a href="#Linux进程调度目标和特点" class="headerlink" title="Linux进程调度目标和特点"></a>Linux进程调度目标和特点</h3><ul>
<li>调度策略<ul>
<li>基于动态优先级和可变时间片的调度</li>
<li>调度方式为可抢占式调度</li>
</ul>
</li>
<li>调度目标<ul>
<li>实现算法复杂度为O(1)级的调度</li>
<li>提高交互性能</li>
<li>保证公平</li>
<li>实现SMP可扩展性</li>
</ul>
</li>
<li>特点(多级反馈循环调度)<ul>
<li>基于进程过去行为的启发式算法</li>
<li>选则优先级高的进程先运行，相同优先级的进程按循环方式调度</li>
<li>动态优先级依进程占有CPU的情况、休眠时间的长短来增、减</li>
<li>系统根据进程优先级调整分配给它的时间片</li>
<li>实施可抢占调度方式</li>
</ul>
</li>
<li>可变优先级<ul>
<li>基于优先级的调度: 优先级高的进程先运行，相同优先级的进程按轮转方式进行调度</li>
<li>静态优先级<ul>
<li>静态优先级的确定: 在进程创建时，新创建的进程继承父进程的静态优先级</li>
<li>静态优先级的取值范围: 0-99对应实时进程，100-139对应普通进程(取值越小，优先级越高)</li>
<li>静态优先级的改变: 用户可以通过系统调用改变nice值，从而改变自己拥有的静态优先级</li>
</ul>
</li>
<li>动态优先级<ul>
<li>每个进程有一个动态优先级，它是进程调度程序选择可运行进程所使用的参数，其取值范围是100(最高优先级)~139(最低优先级)(实时进程优先级不变)</li>
<li>动态优先级的计算 动态优先级&#x3D;nax(100, min(静态优先级-bonus+5, 139))<ul>
<li>bonus的取值范围是0~10</li>
<li>bonus值小于5，表示降低动态优先级以示惩罚</li>
<li>bonus值大于5，表示增加动态优先级以示奖励</li>
<li>bonux的值也与进程的平均休眠时间有关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可变时间片<ul>
<li>Linux系统的进程的调度目标: 优先照顾交互式进程，为其提供较长的时间片</li>
<li>时间片的计算<ul>
<li>基本时间片: 静态优先级本质上决定了进程的基本时间片</li>
<li>静态优先级越高(值越小)，基本时间片越长</li>
</ul>
</li>
<li>时间片处理的时机<ul>
<li>创建新进程时的处理: 新创建的子进程和父进程均分父进程剩余的时间片</li>
<li>进程用完时间片时的处理: 根据任务的静态优先级重新计算时间片</li>
</ul>
</li>
<li>时间片的使用<ul>
<li>一个进程拥有的时间片可分多次使用，放弃CPU时进入活动队列</li>
<li>当一个进程的时间片耗尽时，认为是过期进程，进入过期队列</li>
</ul>
</li>
</ul>
</li>
<li>活动队列和过期队列<ul>
<li>每个处理器维护两个优先级数组: 活动数组和过期数组</li>
<li>活动数组上的可执行队列中的进程都有剩余时间片</li>
<li>过期数组上的可执行队列中的进程都已耗尽时间片</li>
<li>当一个进程的时间片耗尽时，被移至过期队列中；当活动数组上的可执行队列中的所有进程都已耗尽时间片，在活动数组和过期数组之间切换指针</li>
</ul>
</li>
</ul>
<h1 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h1><h2 id="主存管理概述"><a href="#主存管理概述" class="headerlink" title="主存管理概述"></a>主存管理概述</h2><h4 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h4><ul>
<li>存储器的功能示保存数据，存储器的发展方向是告诉、大容量和小体积</li>
<li>存储组织是指在存储计数和CPU寻址计数许可的范围内组织合理的存储结构<ul>
<li>依据是访问速度匹配关系、容量要求和价格</li>
<li>寄存器-内存-外存 结构</li>
<li>寄存器-缓存-内存-外存 结构</li>
<li>快速缓存<ul>
<li>data cache</li>
<li>TLB(Translation Lookaside buffer)</li>
</ul>
</li>
<li>内存: DRAM, SDRAM等</li>
<li>外存: 硬盘、光盘、软盘、磁带等</li>
</ul>
</li>
</ul>
<h4 id="程序的逻辑组织"><a href="#程序的逻辑组织" class="headerlink" title="程序的逻辑组织"></a>程序的逻辑组织</h4><ul>
<li>一维地址结构<ul>
<li>一个程序是一个连续、线性的地址结构</li>
<li>确定线性地址空间中断 指令地址或操作数地址只需要一个信息</li>
</ul>
</li>
<li>二维地址结构<ul>
<li>一个程序由若干个分段组成，每个分段是一个连续的地址区</li>
<li>确定线性地址空间中断指令地址或操作数地址需要两个信息，一是该信息所在的分段，另一个是该信息在段内的偏移量</li>
</ul>
</li>
</ul>
<h4 id="主存共享方式"><a href="#主存共享方式" class="headerlink" title="主存共享方式"></a>主存共享方式</h4><ul>
<li>大小不等的区域<ul>
<li>分区存储管理</li>
<li>段式存储管理</li>
</ul>
</li>
<li>大小相等的区域<ul>
<li>页式存储管理</li>
</ul>
</li>
<li>结合<ul>
<li>段页式存储管理</li>
</ul>
</li>
</ul>
<h2 id="主存管理功能"><a href="#主存管理功能" class="headerlink" title="主存管理功能"></a>主存管理功能</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>物理地址(绝对地址、实地址): 物理地址式计算机主存单元的真实地址，又称为绝对地址或实地址</li>
<li>主存空间: 物理地址的集合所对应的空间组成了主存空间</li>
<li>逻辑地址(相对地址、虚地址): 用户的程序地址(指令地址或操作数地址)均为逻辑地址</li>
<li>程序地址空间: 用户程序所有的逻辑地址集合对应的空间</li>
</ul>
<h3 id="主存管理功能-1"><a href="#主存管理功能-1" class="headerlink" title="主存管理功能"></a>主存管理功能</h3><ul>
<li>地址映射</li>
<li>主存分配</li>
<li>存储保护</li>
<li>主存扩充</li>
</ul>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><ul>
<li>定义: 将程序地址空间中使用的逻辑地址变换称主存中的物理地址的过程，称为地址映射</li>
<li>时机和类别<ul>
<li>编程或编译时确定地址映射关系: 在程序编写或程序编译时确定虚、实地址之间的对应关系，结果是一个不能浮动的程序模块</li>
<li>在程序装入时确定地址映射关系: 在程序装入过程中随即进行的地址变换方式称为静态地址映射</li>
<li>在程序运行时确定地址映射关系: 在程序执行期间，随着每条指令和数据的访问自动地连续地进行地址映射，这种地址变换方式称为动态地址映射</li>
<li>静态地址映射与动态地址映射的区别</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">静态地址映射</th>
<th align="left">动态地址映射</th>
</tr>
</thead>
<tbody><tr>
<td align="left">在程序装入过程中，进行地址映射</td>
<td align="left">在程序执行期间进行地址映射</td>
</tr>
<tr>
<td align="left">需软件(重定位装入程序)</td>
<td align="left">需硬件地址变换机构(重定位寄存器)</td>
</tr>
<tr>
<td align="left">需花费较多CPU时间</td>
<td align="left">地址变换快</td>
</tr>
<tr>
<td align="left">不灵活</td>
<td align="left">灵活</td>
</tr>
</tbody></table>
<h4 id="主存分配"><a href="#主存分配" class="headerlink" title="主存分配"></a>主存分配</h4><ul>
<li>构造分配用的数据结构<ul>
<li>主存资源信息块: 等待队列、空闲区队列、主存分配程序</li>
<li>制定策略<ul>
<li>分配策略: 在众多个请求者中选则一个请求者的原则</li>
<li>放置策略: 在可用资源中，选则一个空闲区的原则</li>
<li>调入策略: 信息装入主存的实际(预调策略&#x2F;请调策略)</li>
<li>淘汰策略: 确定淘汰已占用的内存区的原则</li>
</ul>
</li>
<li>实施主存分配与回收</li>
</ul>
</li>
</ul>
<h4 id="主存扩充"><a href="#主存扩充" class="headerlink" title="主存扩充"></a>主存扩充</h4><ul>
<li>目标<ul>
<li>用户编程不受内存容量限制</li>
<li>用户编程不需知道内存寻址等细节</li>
</ul>
</li>
<li>主存扩容的可行性<ul>
<li>程序局部性原理: 程序在执行过程中的一个较短时间内，所执行的指令地址或操作数地址分别局限于一定的存储区域中</li>
</ul>
</li>
<li>实现方法<ul>
<li>程序的全部代码和数据存放在辅存中</li>
<li>将程序当前执行所设计的那部分程序代码放入主存中</li>
<li>程序执行时，当所需信息不在主存，由操作系统和硬件相配合来完成主存从辅存中调入信息，程序继续执行</li>
</ul>
</li>
</ul>
<h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h4><ul>
<li>定义<ul>
<li>在多用户环境中，主存储器按区分配给各用户程序使用</li>
<li>为了互不影响，必须由硬件(软件配合)保证各用户程序只能在给定的存储区域内活动，</li>
</ul>
</li>
<li>实现方法<ul>
<li>界地址保护<ul>
<li>上下界保护</li>
<li>基地址、限长防护</li>
</ul>
</li>
<li>存储键保护: 为每个进程的连续存储区域分配一个或若干位组成的存储保护键盘</li>
</ul>
</li>
</ul>
<h2 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h2><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><ul>
<li>操作系统在启动时将内存区域划分为若干个分区。分区总数和各分区的大小一旦确定，则整个系统运行阶段都保持不变。固态分区也称为静态分区</li>
<li>分区说明表: 记录分区信息的树结构。存储管理程序在内存分配、释放、存储保护以及地址转换时都要查询和修改分区说明表中的信息</li>
</ul>
<h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><p>动态分区式指处理程序的过程中依用户请求的大小建立并分配分区</p>
<h5 id="分区分配数据结构"><a href="#分区分配数据结构" class="headerlink" title="分区分配数据结构"></a>分区分配数据结构</h5><ul>
<li>主存资源信息块(M_RIB)<ul>
<li>等待队列头指针</li>
<li>空闲区队列头指针</li>
<li>主存分配程序入口地址</li>
</ul>
</li>
<li>分区描述器(PD)<ul>
<li>分配标志(flag): 0空闲，1已分配</li>
<li>大小(size): 分区大小</li>
<li>勾链字(next): 空闲区: 自由主存队列中的勾链字；已分配区: 此项为0</li>
</ul>
</li>
</ul>
<h4 id="动态分区的分配与回收"><a href="#动态分区的分配与回收" class="headerlink" title="动态分区的分配与回收"></a>动态分区的分配与回收</h4><ul>
<li>分区分配思路<ul>
<li>寻找空闲块: 依申请者所要求的主存区大小，分区分配程序在自由主存队列中找一个满足用户需要的空闲块</li>
<li>若找到了所需的空闲区，有两种情况<ul>
<li>空闲区与要求的大小相等，将该空闲区分配并从队列中摘除</li>
<li>空闲区大于所要求的大小，将空闲区分为两部分: 一部分成已分配区，建立已分配区的描述器，剩下部分仍为空闲区</li>
<li>返回所分配区域的首址</li>
</ul>
</li>
<li>否则，告之不能满足要求</li>
</ul>
</li>
<li>分区回收思路<ul>
<li>检查释放分区(即为回收分区)在主存中的邻接情况<ul>
<li>若上、下邻接空闲区，则合并，成为一个连续的空分区</li>
</ul>
</li>
<li>若回收分区不与任何空闲区相邻接<ul>
<li>建立一个新的空闲区，并加入到空闲区队列中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h4><ul>
<li>定义: 选则空闲区的策略</li>
<li>常用策略<ul>
<li>首次匹配(首次适应算法)</li>
<li>最佳匹配(最佳适应算法)</li>
<li>最坏匹配(最坏适应算法)</li>
</ul>
</li>
</ul>
<h5 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h5><ul>
<li>定义: 将程序放置到第一个足够装入它的地址最低的空闲区</li>
<li>空闲区队列结构: 空闲区地址由低到高排序</li>
<li>特点<ul>
<li>尽可能地利用低地址的空闲区，而尽量保存高地址的空闲区</li>
</ul>
</li>
<li>问题<ul>
<li>地址去的小分区多，降低查找效率</li>
</ul>
</li>
</ul>
<h5 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h5><ul>
<li>定义: 将程序放置到主存中与它所需大小最接近的空闲区中</li>
<li>空闲区队列结构: 按空闲区大小由小到大排序</li>
<li>特点<ul>
<li>尽可能地利用存储器中小的空闲区，而尽量保存大的空闲区</li>
</ul>
</li>
<li>问题<ul>
<li>碎片多，分配时查找效率降低，且内存利用率下降；回收分区时需要遍历整个空闲区链表</li>
</ul>
</li>
</ul>
<h5 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h5><ul>
<li>定义: 将程序放置到主存中与它所需大小差距最大的空闲区中</li>
<li>空闲区队列结构: 按空闲区大小由大到小排序</li>
<li>特点<ul>
<li>尽可能地利用存储器中的空闲区。分配时查找效率高</li>
</ul>
</li>
<li>问题<ul>
<li>分区大小难以满足大型程序的需要；回收分区时需要遍历整个空闲区链表</li>
</ul>
</li>
</ul>
<h4 id="碎片问题及拼接技术"><a href="#碎片问题及拼接技术" class="headerlink" title="碎片问题及拼接技术"></a>碎片问题及拼接技术</h4><ul>
<li>碎片: 在已分配分区之间存在着的一些没有被充分利用的空闲区</li>
<li>拼接技术: 移动存储器中某些已分配区中的信息，使本来分散的空闲区连城一个大的空闲区</li>
</ul>
<h3 id="分区存储管理的缺点"><a href="#分区存储管理的缺点" class="headerlink" title="分区存储管理的缺点"></a>分区存储管理的缺点</h3><ul>
<li>程序必须整体装入</li>
<li>需要分配连续的内存空间</li>
<li>碎片问题</li>
</ul>
<h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>页面: 程序的地址空间被分成大小相等的片，称为页面(page),又称为虚页。</li>
<li>主存块: 主页被分成大小相等的片，称为主存块，又称为实页、页框(frame)</li>
<li>页面与主存块的关系</li>
<li>页表<ul>
<li>定义: 为了实现从地址空间到物理主存的映像，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表</li>
<li>组成<ul>
<li>高速缓冲区: 旁路转换缓冲(Translation Lookaside Buffer, TLB)，或称为页表缓冲，CPU中用于存放页表项的告诉缓存。地址变换速度快，但成本较高</li>
<li>主存区域: 地址变换速度比硬件慢，成本较低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="页式地址变换"><a href="#页式地址变换" class="headerlink" title="页式地址变换"></a>页式地址变换</h3><ul>
<li>页表: 记录页与块之间的对应关系</li>
<li>虚地址结构: 当CPU给出的虚地址长度为16位，页面大小位1KB时，在分页系统中地址结构的格式为<ul>
<li>页号P(15<del>10) + 页内位移w(9</del>0)</li>
</ul>
</li>
<li>页式地址变换<ul>
<li>CPU给出操作数地址</li>
<li>由页分页机构自动把逻辑地址分为两部分，得到页号P和页内相对位移w</li>
<li>根据页表始址寄存器指示的页表始地址，以页号为索引，找到p对应的块号b</li>
<li>将块号b和页内位移量w拼接在一起，就形成了访问主存的物理地址</li>
</ul>
</li>
<li>缺点:<ul>
<li>每次取数据都需要访问两次内存</li>
</ul>
</li>
<li>采用联想存储器加快查表速度<ul>
<li>在联想存储器中存放正在运行的进程当前用到的页号和对应的块号，又称为快表</li>
</ul>
</li>
</ul>
<h4 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h4><ul>
<li>每个页面中可以存放1K(1024)个页表项(4B)，这样每1K个连续的页表项位一组，整个页表则被划分位1K(1024)个组，离散的放在各个内存块中</li>
<li>为离散的页表再建立一张页表，称为页目录表(一级页表、顶层页表)，它的大小正好一个页面</li>
<li>二级页表地址结构: 一级页号: 二级页号: 页内偏移</li>
<li>地址变换<ul>
<li>按照地址结构将逻辑地址拆分称三个部分: 一级页号: 二级页号: 页内偏移</li>
<li>根据一级页号查找页目录表，找到对应的二级页表再内存中存放位置</li>
<li>根据页号查二级页表，找到最终想要访问的内存块号</li>
<li>由内存块号和页内偏移量得到物理地址</li>
</ul>
</li>
</ul>
<h4 id="请调页面的机制"><a href="#请调页面的机制" class="headerlink" title="请调页面的机制"></a>请调页面的机制</h4><ul>
<li>两种页式系统<ul>
<li>简单页式系统: 装入一个程序的全部页面才能投入运行</li>
<li>请求页式系统: 装入一个程序的部分页面即可投入运行</li>
</ul>
</li>
<li>扩充页表项功能:<ul>
<li>页号+主存块号+中断位+辅助地址</li>
<li>中断位: 标识该页是否在主存，1不在主存；0在主存</li>
<li>辅存地址: 该页在辅存的位置</li>
</ul>
</li>
</ul>
<h3 id="缺页处理"><a href="#缺页处理" class="headerlink" title="缺页处理"></a>缺页处理</h3><h4 id="淘汰机制与策略"><a href="#淘汰机制与策略" class="headerlink" title="淘汰机制与策略"></a>淘汰机制与策略</h4><ul>
<li>用来选则淘汰哪一页的规则叫做淘汰策略&#x2F;置换策略</li>
<li>扩充页表项功能: 页号+主存块号+中断位+辅存地址+引用位+改变位<ul>
<li>引用位: 标识该页最近是否被访问: 0没被访问，1已被访问</li>
<li>改变位: 标识该页是否被修改: 0未被修改，1已被修改</li>
</ul>
</li>
<li>颠簸<ul>
<li>主存和辅存之间的频繁页面置换的现象称为颠簸，又称抖动</li>
<li>这将导致系统效率急剧下降</li>
</ul>
</li>
<li>缺页中断率<ul>
<li>假定程序p共有n页，系统分配m块，有$1&lt;&#x3D;n&lt;&#x3D;n$</li>
<li>若程序p在运行中: 成功的访问次数为s，不成功的访问次数为f<ul>
<li>缺页中断率:$f’ &#x3D; \frac{f}{s+f}$</li>
<li>$f’ &#x3D; \mathscr{f}(r, m, p)$</li>
<li>r: 置换算法; m: 系统分配的块数; p: 程序特征</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="SV39中的PDE-PTE格式"><a href="#SV39中的PDE-PTE格式" class="headerlink" title="SV39中的PDE&#x2F;PTE格式"></a>SV39中的PDE&#x2F;PTE格式</h4><table>
<thead>
<tr>
<th align="left">reserved</th>
<th align="left">PPN</th>
<th align="left">RSW</th>
<th align="left">D</th>
<th align="left">A</th>
<th align="left">G</th>
<th align="left">Y</th>
<th align="left">X</th>
<th align="left">W</th>
<th align="left">R</th>
<th align="left">V</th>
</tr>
</thead>
<tbody><tr>
<td align="left">63~54</td>
<td align="left">53~10</td>
<td align="left">9~8</td>
<td align="left">7</td>
<td align="left">6</td>
<td align="left">5</td>
<td align="left">4</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<ul>
<li>V: 该PDE&#x2F;PTE是否有效(V&#x3D;1时有效),即是否有对应的实页</li>
<li>R(Read),W(Write),X(excutable): 只对PTE有意义，对PDE而言3个位都是0</li>
<li>U(User): 表示该页是不是一个用户模式页</li>
<li>G(Global): 表示该PDE&#x2F;PTE是不是全局的</li>
<li>A(Access): 表示该页面是否被访问过</li>
<li>D(Dirty): 表示该页的内容是否被修改</li>
<li>RSW位: 保留位，一般由运行在S模式的代码(如操作系统来使用)</li>
<li>PPN位: 物理页号</li>
</ul>
<h4 id="常用的置换算法"><a href="#常用的置换算法" class="headerlink" title="常用的置换算法"></a>常用的置换算法</h4><ul>
<li>最佳算法(OPT算法)<ul>
<li>当要调入一新页而必须先淘汰一旧页时，所淘汰的那一页应是以后不再要用的，或者是在最长的时间以后才会用到的那页</li>
<li>不现实，不可能知道未来访问顺序</li>
</ul>
</li>
<li>先进先出淘汰算法(FIFO算法)<ul>
<li>总是选则在主存中停留时间最长(即最早进入主存)的一页淘汰<ul>
<li>建立一个页面进入主存的先后次序表</li>
<li>建立一个替换指针，指向最早进入主存的页面</li>
<li>当需要置换一页时，选则替换指向的那一页，然后调整替换指针的内容</li>
</ul>
</li>
</ul>
</li>
<li>最久未使用淘汰算法(LRU算法)<ul>
<li>总是选则最长时间未被使用的那一页淘汰</li>
<li>用引用位考察页面的使用情况</li>
<li>当访问页面时，将引用位置1，并记时</li>
<li>当要淘汰一页时，选则时间最长的一页淘汰</li>
<li>硬件方法: 采用时钟计数器，在页表中增加“最后访问时间”字段</li>
<li>软件方法: 采用页号栈</li>
</ul>
</li>
<li>LRU近似淘汰算法(CLOCK算法)<ul>
<li>CLOCK算法并不知道哪个页面是最久未被使用页面，只是有一个引用位，进来的页面就是有效。当需要替换的时候，会把所有的之前的页面全部都引用位置0，最先进来的页就最先出去。</li>
</ul>
</li>
</ul>
<h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><h3 id="段式地址空间"><a href="#段式地址空间" class="headerlink" title="段式地址空间"></a>段式地址空间</h3><ul>
<li>段: 分段式程序中自然划分的一组逻辑意义完整的信息集合，如代码段、数据段</li>
<li>程序地址空间: 由若干逻辑分段组成，每个分段有自己的名字，并且是一个连续的地址区</li>
<li>段式地址结构: 段号s + 段内位移w</li>
<li>段式地址变换<ul>
<li>取出程序地址(s, w)</li>
<li>用s检索段表</li>
<li>如w &lt; 0 或 w &gt;&#x3D; L，则主存越界</li>
<li>(B+w)即为所需主存地址</li>
</ul>
</li>
</ul>
<p>分段和页面的区别</p>
<table>
<thead>
<tr>
<th align="left">分段</th>
<th align="left">页面</th>
</tr>
</thead>
<tbody><tr>
<td align="left">信息的逻辑划分</td>
<td align="left">信息的物理划分</td>
</tr>
<tr>
<td align="left">段长式可变的</td>
<td align="left">页的大小是固定的</td>
</tr>
<tr>
<td align="left">用户可见</td>
<td align="left">用户不可见</td>
</tr>
<tr>
<td align="left">w字段的溢出将产生越界中断</td>
<td align="left">w字段的溢出自动加入到页号中</td>
</tr>
</tbody></table>
<h3 id="Linux系统的存储管理"><a href="#Linux系统的存储管理" class="headerlink" title="Linux系统的存储管理"></a>Linux系统的存储管理</h3><h4 id="Linux系统的段页式地址变换"><a href="#Linux系统的段页式地址变换" class="headerlink" title="Linux系统的段页式地址变换"></a>Linux系统的段页式地址变换</h4><ul>
<li>Linux主要采用分页机制来实现虚拟存储器管理<ul>
<li>Linux的分段机制使得所有的进程都使用相同的段寄存器值，这就使得内存管理变得简单，也就是说，所有的分段都使用相同的线性地址空间</li>
</ul>
</li>
</ul>
<h4 id="Linux系统的分段"><a href="#Linux系统的分段" class="headerlink" title="Linux系统的分段"></a>Linux系统的分段</h4><ul>
<li>Linux系统在用户态时，使用用户代码段和用户数据段来对指令和数据寻址</li>
<li>在内核态时，使用内核代码段和内核数据段来对指令和数据寻址</li>
<li>每个分段式一个连续的线性地址空间，从0开始直到$2^{32}-1$的寻址长度</li>
<li>虚拟内存-共4G字节，分为内核空间(最高的1G字节)和用户空间(较低的3G字节)两部分，每个进程最大拥有3G字节的私有虚存空间</li>
</ul>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><ul>
<li><p>设备分类</p>
<ul>
<li>块设备<ul>
<li>以块为单位传输信息的设备，通常为存储设备</li>
<li>e.g. 磁盘、磁带、光驱</li>
</ul>
</li>
<li>字符设备<ul>
<li>以字符为单位将信息从计算机外部输入到内部，或反之</li>
<li>e.g. 键盘、显示器、打印机</li>
</ul>
</li>
<li>网络设备<ul>
<li>负责计算机之间的信息传输</li>
<li>e.g. 以太网、无线、蓝牙</li>
</ul>
</li>
</ul>
</li>
<li><p>设备管理的目标</p>
<ul>
<li>提高设备利用率<ul>
<li>合理分配设备</li>
<li>提高设备与CPU、各外部设备之间的并行性</li>
</ul>
</li>
<li>方便用户的使用<ul>
<li>提供使用方便且独立于设备的接口</li>
<li>统一: 对各种不同的设备提供一致的接口</li>
<li>独立于设备: 用户使用的设备与物理设备无关</li>
</ul>
</li>
</ul>
</li>
<li><p>设备管理功能</p>
<ul>
<li>状态跟踪: 动态地记录各种设备的状态</li>
<li>设备分配与回收<ul>
<li>静态分配: 应用程序级<ul>
<li>程序进入系统时进行分配，退出系统时收回全部资源</li>
</ul>
</li>
<li>动态分配: 进程级<ul>
<li>进程提出设备申请时分配，使用完毕后立即回收</li>
</ul>
</li>
</ul>
</li>
<li>设备控制: 实施设备驱动和中断处理工作</li>
</ul>
</li>
<li><p>设备独立性</p>
<ul>
<li>概念<ul>
<li>用户在程序中使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名</li>
</ul>
</li>
<li>逻辑设备名: 用户自己指定的设备名(设备号)，是暂时的、可更改的</li>
<li>物理设备名: 系统提供的设备的标准名称，是永久的、不可更改的</li>
<li>两种类型的设备独立性<ul>
<li>一个程序独立于分配给它的某种类型的具体设备<ul>
<li>系统可以根据设备的使用情况，动态的分配给程序某类设备中的任一台物理设备，程序都能正确地执行</li>
</ul>
</li>
<li>程序应尽可能与它所使用的I&#x2F;O设备类型无关<ul>
<li>在输入(或输出)信息时，信息可以从不同类型的输入(或输出)设备上输入(或输出)，若要改变输入输出设备的类型，程序只需要进行最少的修改</li>
</ul>
</li>
</ul>
</li>
<li>实现<ul>
<li>在高级语言中用软通道实现<ul>
<li>在使用高级语言提供的指派语句，通过指派一个逻辑设备名(通道号)来定义一个设备或文件</li>
<li>e.g. <code>fd=open(&quot;/dev/lp&quot;, mode)</code></li>
</ul>
</li>
<li>在批处理系统中，用链接说明语句来定义<ul>
<li>e.g. <code>OUTPUT1=LPT</code></li>
</ul>
</li>
<li>在交互系统中，用指派命令来定义<ul>
<li>e.g. <code>ASSIGN 设备物理名 设备逻辑名</code></li>
</ul>
</li>
</ul>
</li>
<li>优点<ul>
<li>方便用户</li>
<li>改善设备利用率</li>
<li>提高系统的可扩展性和可适应性</li>
</ul>
</li>
</ul>
</li>
<li><p>设备控制块</p>
<ul>
<li>DCB: 系统为每一台设备都配置了一个用来记录设备的硬件特性、连接和使用情况的一组数据，称为设备控制块</li>
<li>内容<ul>
<li>设备名: 设备的系统名，即设备的物理名</li>
<li>设备属性: 描述设备信息的一组属性</li>
<li>命令转换表: 转换表包含设备特定的I&#x2F;O例程地址，不具备相应功能的设备在其例程地址上可以填”-1”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="I-O控制"><a href="#I-O控制" class="headerlink" title="I&#x2F;O控制"></a>I&#x2F;O控制</h2><h3 id="输入输出控制方式"><a href="#输入输出控制方式" class="headerlink" title="输入输出控制方式"></a>输入输出控制方式</h3><p>CPU通过I&#x2F;O控制器与物理设备打交道。按照I&#x2F;O控制器智能化程度的高低，I&#x2F;O设备的控制方式分为四类</p>
<ul>
<li>循环测试I&#x2F;O方式</li>
<li>I&#x2F;O中断方式</li>
<li>DMA方式</li>
<li>通道方式</li>
</ul>
<h4 id="I-O中断方式"><a href="#I-O中断方式" class="headerlink" title="I&#x2F;O中断方式"></a>I&#x2F;O中断方式</h4><ul>
<li>要求输入数据的进程把一个启动命令和允许中断位”1”写入相应设备的控制状态寄存器中，从而启动该设备</li>
<li>进程因等待输入的完成而进入睡眠状态(CPU执行其它任务)</li>
<li>当输入完成后，输入设备向CPU发出中断请求信号</li>
<li>处理机响应中断，处理该中断，并唤醒等待输入完成的进程</li>
<li>该进程在以后的某个时刻被调度运行</li>
<li>优点: 大大提高了CPU的利用效率</li>
<li>缺点: 每次I&#x2F;O都要CPU的干预，如果系统中配备了多台设备时候，CPU的利用率也会降低</li>
</ul>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><ul>
<li>存放输入数据的内存起始地址、要传送的字节数送入DMA控制器的内存地址寄存器和传送字节计数器</li>
<li>中断允许位和启动位置1，启动设备</li>
<li>发出传输要求的进程进入等待状态，进程调度其它进程占据CPU</li>
<li>输入设备不断窃取CPU工作周期将数据写入内存，传送完毕后发出中断信号</li>
<li>CPU接到中断信号转纳入中断处理程序处理</li>
<li>中断处理结束，CPU返回原进程或切换到新的进程</li>
<li>DMA与中断的主要区别<ul>
<li>中断方式是在数据缓冲寄存器满后发中断请求</li>
<li>DMA方式则在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数</li>
<li>中断方式下，设备与内存之间的数据传送式由CPU控制完成的</li>
<li>DMA方式下，设备与主存之间的数据交换式在DMA控制器的控制下直接使用总线进行的</li>
</ul>
</li>
</ul>
<h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><ul>
<li>CPU: 执行用户程序，当遇到I&#x2F;O请求时，可根据该请求生成通道程序放入内存(也可事先编好放入内存)，并将该通道程序的首地址放入通道地址字CAW中；然后执行“启动I&#x2F;O”指令，启动通道工作</li>
<li>通道: 接收到“启动I&#x2F;O”指令后，从CAW中取出通道程序的首地址，同时向CPU发出应答信号，使CPU可继续执行其它程序，而通道则开始执行通道程序，完成I&#x2F;O传输工作</li>
<li>通道: 当通道程序的最后一条指令执行完成时，通道向CPU发I&#x2F;O中断信号，并停止工作</li>
<li>CPU: CPU接受到I&#x2F;O中断信号，从通道状态字CSW中取得有关信息，决定下一步做什么</li>
</ul>
<h3 id="I-O子系统"><a href="#I-O子系统" class="headerlink" title="I&#x2F;O子系统"></a>I&#x2F;O子系统</h3><ul>
<li>I&#x2F;O控制的功能<ul>
<li>解释用户的I&#x2F;O系统调用</li>
<li>设备驱动</li>
<li>中断处理</li>
</ul>
</li>
<li>设备驱动程序<ul>
<li>设备驱动程序是能直接控制设备运转的程序，它根据各类设备的特点和性能来编写。每一类设备有一个相应的设备驱动程序，能控制同类中多台物理设备同时工作。设备I&#x2F;O完成或出错时产生中断，由该类设备的中断处理程序处理</li>
</ul>
</li>
<li>I&#x2F;O子系统的接口<ul>
<li>在应用层为用户提供I&#x2F;O应用接口<ul>
<li>对设备的控制和操作则由内核I&#x2F;O子系统来实施</li>
</ul>
</li>
<li>对每个通用设备类型都通过一组标准函数(及接口)来访问<ul>
<li>设备间的差异被设备驱动程序所封装，这些设备驱动程序一方面可以定制以适合各种设备，另一方面也提供了一组标准的设备访问接口</li>
<li>设备驱动程序层的作用是隐藏设备控制器之间的差异，它将I&#x2F;O子系统与硬件分离，简化了操作系统开发人员的任务，也有利于设备的设计与制造</li>
</ul>
</li>
</ul>
</li>
<li>I&#x2F;O控制模块的实现方式<ul>
<li>以设备处理进程的方式<ul>
<li>为每一类设备设置一个设备处理进程</li>
<li>没有I&#x2F;O请求时，该进程睡眠；当有I&#x2F;O请求到来时，该进程被唤醒，进行设备驱动工作</li>
</ul>
</li>
<li>由I&#x2F;O控制模块的接口程序负责解释用户的I&#x2F;O系统调用，将其转换称I&#x2F;O控制模块认识的命令形式后，将I&#x2F;O请求发给对应的设备处理进程</li>
<li>将设备与文件一样对待: 将设备与文件一样对待，使用文件系统的系统调用命令进行设备的读写</li>
</ul>
</li>
</ul>
<h3 id="输入输出控制示例"><a href="#输入输出控制示例" class="headerlink" title="输入输出控制示例"></a>输入输出控制示例</h3><h4 id="用户进程请求I-O的系统功能调用"><a href="#用户进程请求I-O的系统功能调用" class="headerlink" title="用户进程请求I&#x2F;O的系统功能调用"></a>用户进程请求I&#x2F;O的系统功能调用</h4><p><code>doio(ldev, mode, amount, addr)</code></p>
<ul>
<li><code>ldev</code>: 逻辑设备名</li>
<li><code>mode</code>: 操作模式</li>
<li><code>amount</code>: 传输数据的数目</li>
<li><code>addr</code>: 传送地址</li>
</ul>
<h4 id="I-O例程"><a href="#I-O例程" class="headerlink" title="I&#x2F;O例程"></a>I&#x2F;O例程</h4><ul>
<li>将逻辑设备转换为物理设备<ul>
<li>获得I&#x2F;O系统调用中给出的逻辑设备名(ldev)</li>
<li>根据逻辑设备描述器，将逻辑设备名转换为物理设备名</li>
</ul>
</li>
<li>合法性检查<ul>
<li>获得I&#x2F;O系统嗲用中给出的操作模式mode</li>
<li>根据DCB中命令转换表中允许的操作，检查操作的合法性</li>
</ul>
</li>
<li>形成I&#x2F;O请求块，发送消息给对应的设备处理进程<ul>
<li>根据请求的参数形成I&#x2F;O请求块(IORB)</li>
<li>将I&#x2F;O请求快(IORB)挂到对应的设备请求队列</li>
</ul>
</li>
<li>输入输出控制示例: 文件操作方式<ul>
<li>用户进程执行I&#x2F;O系统调用，对I&#x2F;O数据进行格式化</li>
<li>独立于设备的文件系统软件实现设备的命名、设备的保护、成块处理、缓冲技术和设备分配</li>
<li>设备驱动程序设置设备寄存器、检查设备的执行状态，驱动I&#x2F;O，I&#x2F;O请求进程进入等待状态</li>
<li>中断处理程序负责I&#x2F;O完成时，唤醒I&#x2F;O请求进程，进行中断处理</li>
<li>硬件层实现物理I&#x2F;O操作</li>
</ul>
</li>
</ul>
<h3 id="Linux设备驱动程序框架"><a href="#Linux设备驱动程序框架" class="headerlink" title="Linux设备驱动程序框架"></a>Linux设备驱动程序框架</h3><ul>
<li>驱动程序的注册和注销</li>
<li>设备的打开和释放</li>
<li>设备的读写操作</li>
<li>设备的控制操作</li>
<li>设备的中断和查询处理</li>
</ul>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><h3 id="缓冲概念"><a href="#缓冲概念" class="headerlink" title="缓冲概念"></a>缓冲概念</h3><ul>
<li>定义: 缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段</li>
<li>缓冲类别<ul>
<li>缓冲器: 缓冲器是用来暂时存放数据的一种存储装置，它容量较小，存取速度快</li>
<li>软件缓冲: 在I&#x2F;O操作期间用来临时存放I&#x2F;O数据的一块存储区域</li>
</ul>
</li>
<li>引入的意义<ul>
<li>处理数据流的生产者与消费者间的速度差异</li>
<li>协调传输数据大小不一致的设备</li>
<li>应用程序的拷贝语义<ul>
<li>e.g. 操作系统为保证系统调用write的正确语义(应用程序要写入磁盘的数据就是write系统调用时发生时候的版本)</li>
<li>方法: 在系统调用返回前将应用程序缓冲区复制到内核缓冲区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="利用缓冲技术如何进行I-O操作"><a href="#利用缓冲技术如何进行I-O操作" class="headerlink" title="利用缓冲技术如何进行I&#x2F;O操作"></a>利用缓冲技术如何进行I&#x2F;O操作</h3><ul>
<li>进程活动期间，请求从某输入设备读入数据<ul>
<li>当用户要求在某个设备进行读操作时，首先从操作系统中获得一个空的缓冲区</li>
<li>操作系统将一个物理记录送到缓冲区中</li>
<li>用户请求这些数据时，操作系统将依据逻辑记录特性从缓冲区中提取数据并发送到用户进程存储区中</li>
<li>当缓冲区空而进程又要从中取用数据时该进程被迫等待。此时操作系统需要重新送数据填满缓冲区，进程才能从中取数据继续运行</li>
</ul>
</li>
<li>进程活动期间，请求从输出设备输出数据<ul>
<li>当用户要求进行写操作时，首先从操作系统中获得一个空的缓冲区</li>
<li>将一个逻辑记录从进程存储区传送到缓冲区中</li>
<li>当缓冲区写满时，操作系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空</li>
<li>只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待</li>
</ul>
</li>
</ul>
<h3 id="常用的缓冲技术"><a href="#常用的缓冲技术" class="headerlink" title="常用的缓冲技术"></a>常用的缓冲技术</h3><ul>
<li>双缓冲<ul>
<li>在双缓冲方案下，为输入或输出分配两个缓冲区buf1, buf2</li>
</ul>
</li>
<li>环形缓冲<ul>
<li>在系统中设置若干缓冲区，并把这些缓冲区连接起来，这样若干个缓冲区就形成了一个环，故称环形缓冲区</li>
</ul>
</li>
<li>缓冲池<ul>
<li>将系统内所有的缓冲区统一管理起来，就形成了能用于输入&#x2F;输出的缓冲池。缓冲池通常由大小相同的缓冲区组成，是系统的公用资源，任何进程都可以申请使用这个缓冲池中的各个缓冲区</li>
</ul>
</li>
</ul>
<h3 id="Unix系统的缓冲区管理"><a href="#Unix系统的缓冲区管理" class="headerlink" title="Unix系统的缓冲区管理"></a>Unix系统的缓冲区管理</h3><ul>
<li>目的<ul>
<li>加快系统相应、增强系统吞吐量</li>
<li>减少对磁盘的I&#x2F;O操作次数</li>
</ul>
</li>
<li>UNIX系统缓冲管理的思路<ul>
<li>当进程要从磁盘读数据时，首先考虑从缓冲区中读</li>
<li>当进程要写数据到磁盘时，先写入缓冲区中</li>
</ul>
</li>
<li>缓冲区数据结构<ul>
<li>缓存数组: 含有磁盘上的数据的存储器数组</li>
<li>缓存首部: 描述缓冲区特性的数据结构<ul>
<li>设备号: 缓冲区所包含的信息所属设备的设备号</li>
<li>快号: 由设备号指出的设备上相对于第0快的块号</li>
<li>状态flag: 描述了缓冲区当前的状态<ul>
<li>BUSY: 缓冲区当前正忙</li>
<li>AVE: 缓冲区包含的数据有效</li>
<li>DELWR: 内核在某缓冲区重新分配出去之前必须把缓冲区内容写到磁盘上</li>
<li>WRITE: 内核当前正把缓冲区的内容写到磁盘</li>
<li>READ: 内核当前正从磁盘往缓冲区写信息</li>
<li>WAIT: 一个进程当前正在等待缓冲区变为空闲</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区队列结构<ul>
<li>设备缓冲区队列: 与某类设备有关的所有缓冲区组成的队列称为设备缓冲区队列，简称b链</li>
<li>空闲缓冲区队列: 可供重新分配使用的缓冲区组成的队列称为空闲缓冲区队列，简称av链</li>
</ul>
</li>
</ul>
</li>
<li>UNIX缓冲管理算法<ul>
<li>一个buf被分配用于读&#x2F;写某设备上的块时<ul>
<li>置B_BUSY&#x3D;1，位于b链上，不在av链上</li>
</ul>
</li>
<li>当读写操作结束时<ul>
<li>释放该buf吗，置B_BUSY&#x3D;0，仍留在b链上，并送入av链尾</li>
</ul>
</li>
<li>若进程需要的信息在buf中时<ul>
<li>在该设备的b链上找到，置B_BUSY&#x3D;1，从av链上摘除，使用完后，送入av链队尾</li>
</ul>
</li>
<li>对空闲buf队列的处理<ul>
<li>当需要一个空闲buf时，总是取av链的首元素；一个使用过的buf释放时，插入到空闲buf队列(av链)的队尾。实现了精确的最久未使用淘汰算法(LRU算法)</li>
</ul>
</li>
<li>对延迟写的处理<ul>
<li>当一个具有延迟标写标记的buf移动到av链头，要用于分配时，立即进行写操作。从av链上摘除，使用完后又送入av头部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><h3 id="独享分配"><a href="#独享分配" class="headerlink" title="独享分配"></a>独享分配</h3><ul>
<li>独享设备<ul>
<li>让一个作业在整个运行期间独占使用的设备</li>
<li>特点<ul>
<li>临界资源</li>
<li>费时的I&#x2F;O操作或需要人工干预</li>
</ul>
</li>
</ul>
</li>
<li>独享分配<ul>
<li>在一个作业执行前，将它所要使用的设备分配给它；当它结束时，将分配给它的这类设备收回</li>
</ul>
</li>
</ul>
<h3 id="共享分配"><a href="#共享分配" class="headerlink" title="共享分配"></a>共享分配</h3><ul>
<li>共享设备<ul>
<li>由多个作业、进程共同使用的设备称为共享设备</li>
<li>特点<ul>
<li>旋转设备，可直接或随机访问</li>
<li>便于共享，转接简单，耗费较少</li>
</ul>
</li>
<li>共享分配<ul>
<li>进程提出资源申请时，将所要使用的设备分配给它；进程使用完毕后，立即将设备收回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟分配"><a href="#虚拟分配" class="headerlink" title="虚拟分配"></a>虚拟分配</h3><ul>
<li>虚拟技术<ul>
<li>在一类物理设备上模拟另一类物理设备的技术，将独占设备转化为共享设备的技术</li>
</ul>
</li>
<li>虚拟分配<ul>
<li>当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配</li>
</ul>
</li>
<li>虚拟设备<ul>
<li>通常把用来代替独占型设备的那部分外存空间(包括有关的控制表格)称为虚拟设备</li>
</ul>
</li>
</ul>
<h3 id="SPOOLING系统"><a href="#SPOOLING系统" class="headerlink" title="SPOOLING系统"></a>SPOOLING系统</h3><p>Simultaneous Peripheral Operations On Line系统，也叫假脱机系统，为用户提供外围设备同时联机操作的功能</p>
<ul>
<li>设计思想<ul>
<li>预输入<ul>
<li>在应用程序需要数据前，OS已将所需数据预先输入到辅存输入井存放。当应用程序(或进程)需要数据时，可直接从辅存中读入主存</li>
</ul>
</li>
<li>缓输出<ul>
<li>在应用程序执行时，将输出数据写入辅存输出井中。当应用程序(或进程)执行完毕(或需要数据时候)，由操作系统将数据输出</li>
</ul>
</li>
</ul>
</li>
<li>SPOOLING<ul>
<li>利用通道和中断技术，在主机控制之下，由通道完成输入输出工作。</li>
<li>系统提供一个软件系统(包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。</li>
<li>它提供输入收存和输出发送的功能，使外部设备可以并性操作</li>
</ul>
</li>
<li>优点<ul>
<li>提供虚拟设备</li>
<li>外围设备同时联机操作</li>
<li>加快作业处理速度</li>
</ul>
</li>
<li>实现<ul>
<li>大容量的辅存空间<ul>
<li>在辅存上需要开辟两个较大的输入和输出井，用以存放大量应用程序的输入信息和输出信息</li>
</ul>
</li>
<li>硬件基础<ul>
<li>通道装置、中断系统</li>
</ul>
</li>
<li>数据结构<ul>
<li>预输入表、缓输出表: 描述辅存输入井和输出井的状态变化</li>
</ul>
</li>
<li>软件<ul>
<li>预输入软件: 控制信息从独占设备输入到辅存</li>
<li>缓输出程序: 控制信息从辅存输出到独占设备</li>
<li>井管理程序: 控制用户程序和辅存之间的信息交换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>文件: 在逻辑上具有完整意义的信息集合，有一个名字以供标识，文件名是由若干约束的字符串<ul>
<li>特点: 可以长期保存、可以在进程间共享、具有内部结构</li>
</ul>
</li>
<li>构成文件的基本单位: 信息项(单个字节或字符)、记录</li>
<li>文件的其它描述<ul>
<li>文件是就有符号名的信息(数据项)的集合</li>
<li>文件是具有符号名的记录的集合</li>
</ul>
</li>
<li>分类<ul>
<li>按文件的性质和用途分类: 系统文件、程序库文件、用户文件</li>
<li>按文件保护级分类: 不保护文件、执行文件、只读文件、读写文件</li>
<li>按文件刘翔分类: 输入文件、输出文件、输入输出文件</li>
</ul>
</li>
<li>文件名与属性<ul>
<li>文件名: 每个文件有一个给定的名字，包括文件符号名和内部标识符</li>
<li>文件扩展名: 表示文件的使用特征</li>
<li>文件属性: 表示文件类别、保护级等信息</li>
</ul>
</li>
</ul>
<h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><ul>
<li>定义: 文件系统是操作系统中负责管理和存取文件信息的软件机构</li>
<li>组成<ul>
<li>管理文件所需的数据结构: 如目录表、文件控制块、存储分配表</li>
<li>管理程序</li>
<li>一组操作</li>
</ul>
</li>
<li>文件系统的功能<ul>
<li>从用户角度看: 文件系统实现了“按名存取”的功能</li>
<li>从系统角度看: 文件系统提供的功能包括: 辅存空间管理、构造文件结构、文件共享、存取文件的方法、文件保护、一组文件操作命令</li>
</ul>
</li>
<li>特点<ul>
<li>使用简单: 使用文件名、一组文件操作命令</li>
<li>安全可靠:<ul>
<li>提供防护措施，在文件遭受破坏时，能及时修复</li>
<li>全量备份、增量备份、动态备份、远程备份</li>
</ul>
</li>
<li>既能共享，又能保密: 身份验证、存取权限验证</li>
</ul>
</li>
</ul>
<h3 id="文件系统的两种结构"><a href="#文件系统的两种结构" class="headerlink" title="文件系统的两种结构"></a>文件系统的两种结构</h3><ul>
<li>逻辑结构<ul>
<li>从用户角度看到的文件面貌，即用户对信息进行逻辑组织的文件结构</li>
<li>为用户提供一种逻辑结构清晰、使用简单的逻辑文件形式</li>
<li>用户按文件的逻辑结构形式取存储、检索和加工文件中的信息</li>
</ul>
</li>
<li>物理结构<ul>
<li>信息在物理存储器上的存储方式，是数据的物理表示和组织</li>
<li>选则工作性能良好、设备利用率高的物理文件形式</li>
<li>系统按照文件的蓄力结构形式和外部设备打交道，控制信息的传输</li>
</ul>
</li>
<li>逻辑记录与物理记录(磁盘块)<ul>
<li>逻辑记录: 文件中按信息在逻辑上的独立含义来划分的信息单位，逻辑记录是对文件进行存取操作的基本单位</li>
<li>物理记录: 在存储截至上，由连续信息所组成的一个区称为块，也叫物理记录</li>
<li>逻辑记录与物理记录的区别与联系<ul>
<li>一个是逻辑的概念，一个是物理的概念</li>
<li>逻辑记录最终要存放到物理记录上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件的逻辑结构与存取方法"><a href="#文件的逻辑结构与存取方法" class="headerlink" title="文件的逻辑结构与存取方法"></a>文件的逻辑结构与存取方法</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ul>
<li>流式文件<ul>
<li>定义: 流式文件是相关的有序字符的集合，是无结构的</li>
<li>存取方法: 流式文件是按信息的个数或以特殊字符为界进行存取的</li>
</ul>
</li>
<li>记录式文件<ul>
<li>定义: 记录式文件是一种有结构的文件，这种文件在逻辑上总是被看成是一组连续顺序的记录的集合</li>
<li>定长记录与变长记录</li>
</ul>
</li>
</ul>
<h3 id="文件存取方法"><a href="#文件存取方法" class="headerlink" title="文件存取方法"></a>文件存取方法</h3><ul>
<li>顺序存取<ul>
<li>后一次存取总是在前一次存取的基础上进行的</li>
<li>顺序存取时不必给出具体的存取位置</li>
</ul>
</li>
<li>随机存取<ul>
<li>用户以任意次序请求某个记录</li>
<li>随机存取时要指出起始存取位置</li>
</ul>
</li>
</ul>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>块是存储介质上连续信息所组成的一个区域，也叫物理记录</li>
<li>间隙是块之间不记录用户代码信息的区域</li>
<li>块是主存和辅存间信息交换的物理单位，每次交换一块或整数块</li>
<li>不同类型的存介质，块的大小常常各不相同；同一类型的存储截至，块的大小也可以不同</li>
<li>块的大小要考虑到用户使用方式、数据传输效率和存储设备类型等多种因素</li>
</ul>
<h3 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h3><ul>
<li>连续文件结构是由一组分配在磁盘连续区域的物理块组成的</li>
<li>特点: <ul>
<li>存取速度较快</li>
<li>文件长度一经固定便不易改变</li>
<li>文件的增生和扩容不易</li>
</ul>
</li>
</ul>
<h3 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h3><ul>
<li>由按属于内需串联的块组成，即文件的信息存于若干个物理块中，每个物理块的最末一个字作为链接字，指出后续块的物理地址。文件的最后一块的链接字为结束标记”^”，它表示文件至本块结束</li>
<li>特点<ul>
<li>能较好利用辅存空间</li>
<li>易于对文件进行增生和扩容</li>
<li>连续存取速度较快，随机存取速度慢</li>
</ul>
</li>
</ul>
<h3 id="文件映照"><a href="#文件映照" class="headerlink" title="文件映照"></a>文件映照</h3><ul>
<li>把串联文件中的链接字集中在一个结构中，既保持了串联文件的优点，也克服了其随机存取速度慢的缺点，就是FAT文件</li>
<li>文件分配表FAT是以链接方式存取文件的系统中记录磁盘分配和跟踪空白磁盘(蔟)的数据结构</li>
<li>该表在文件系统格式化后产生，共包含N个表项，每个表项对应一个蔟，编号从0开始直至N-14(N为磁盘中蔟的总数)</li>
<li>每个表项中的内容为存放文件数据的下一个蔟的蔟号</li>
<li>文件的首地址(第一个蔟号)存放在目录中。因此，从目录中找到文件的首地址后，就能找到文件在磁盘上的所有存放地址</li>
</ul>
<h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><ul>
<li>系统为每个文件建立逻辑块号与物理块号的对照表，这张表称为该文件的索引表</li>
<li>索引文件由数据块和索引表构成</li>
<li>操作<ul>
<li>索引文件在存储区中占两个区<ul>
<li>索引区: 存放索引表</li>
<li>数据区: 存放数据文件</li>
</ul>
</li>
<li>访问索引文件的操作<ul>
<li>查文件的索引表，由逻辑块号查得物理块号</li>
<li>由物理块号而获得所要求的数据</li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li>易于文件的增删</li>
<li>直接读写任意记录</li>
</ul>
</li>
<li>组织<ul>
<li>直接索引: 文件目录项中有一组表项用于索引，登记逻辑记录所在的磁盘块号</li>
<li>一级间接索引: 文件目录项中有一组表项，其内容等级的是第一季索引表块的块号。第一季索引表块号中的索引表项等级的是文件逻辑记录所在的磁盘块号</li>
<li>二级间接索引: 文件目录项中有一组表项，其内容等级的是第二级索引表块的块号。第二季索引表块中的索引表项等级的是第一季索引表块的块号，第一季索引表项中等级的是文件逻辑记录所在的磁盘块号</li>
</ul>
</li>
</ul>
<h3 id="几种文件物理结构的比较"><a href="#几种文件物理结构的比较" class="headerlink" title="几种文件物理结构的比较"></a>几种文件物理结构的比较</h3><ul>
<li>连续文件<ul>
<li>优点: 不需要额外空间开销，顺序访问和随机访问的效率都高</li>
<li>缺点: 动态增长困难；要求用户创建时提供文件大小；存储空间浪费较大</li>
<li>适合长度固定不变的只读文件的存储</li>
</ul>
</li>
<li>串联文件<ul>
<li>克服了连续文件的不足；但随机访问的系统开销过大；适应于顺序访问的文件</li>
<li>DOS及WINDOWS系统中改造了串联文件结构，使其克服了串联文件的不足，但增加了系统的危险性</li>
</ul>
</li>
<li>索引文件<ul>
<li>既适用于顺序访问，也适用于随机访问；但索引表需要存储开销和访问时间开销</li>
<li>UNIX系统是适用索引结构</li>
</ul>
</li>
</ul>
<h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><ul>
<li>功能: 负责辅助存储空间的有效分配和释放<ul>
<li>创建和扩充文件时，确定分配哪些磁盘块</li>
<li>删除文件和缩短文件时，回收磁盘块</li>
<li>随着分配和回收，可能会出现碎片需要整理</li>
</ul>
</li>
<li>常用方法<ul>
<li>位示图</li>
<li>空闲文件目录</li>
<li>空闲块链</li>
</ul>
</li>
</ul>
<h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><ul>
<li>磁盘空间由固定大小的块组成，可方便地适用位示图管理</li>
<li>每一位对应一个物理块，1表示被占用，0表示空闲</li>
<li>优点<ul>
<li>每个盘块仅需要1bit来标识</li>
<li>若盘块长为1KB，则位视图开销位0.012%</li>
</ul>
</li>
<li>缺点: 对于大容量磁盘，位示图的存储和查找考校较大，需要建立辅助存储统计表来提高访问速度</li>
</ul>
<h3 id="空闲文件目录"><a href="#空闲文件目录" class="headerlink" title="空闲文件目录"></a>空闲文件目录</h3><ul>
<li>将空闲区存储块的位置及其连续空闲的块数构成一张表</li>
<li>分配时，依次扫描空闲区表，寻找合适的空闲块并修改登记项</li>
<li>删除文件并释放空闲区时，把空闲位置及连续空闲区长度填入空闲区表，出现邻接的空闲区时，还需要执行合并操作</li>
<li>适用于连续文件结构</li>
<li>缺点: 碎片问题</li>
</ul>
<h3 id="空闲块链"><a href="#空闲块链" class="headerlink" title="空闲块链"></a>空闲块链</h3><ul>
<li>把所有空闲块连接在一起，系统保持指针指向第一个空闲块，每一个空闲块中包含指向下一个空闲块的指针</li>
<li>申请一个空闲块时，从链头取一块修改系统指针</li>
<li>释放占用块时，将其挂到空闲链的链头，并修改系统指针指向它</li>
<li>优点: 几乎不需要占用空间</li>
<li>缺点: 分配多块时效率低(需要I&#x2F;O操作)</li>
<li>UNIX文件系统对这种方法进行了改进，在一个空闲块中保存一组空闲块指针，称链成组链接法</li>
</ul>
<h2 id="文件目录及其结构"><a href="#文件目录及其结构" class="headerlink" title="文件目录及其结构"></a>文件目录及其结构</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><ul>
<li>文件控制块(FCB)是文件系统位每个文件建立的位移的管理数据结构<ul>
<li>文件标识和控制信息: 文件名、用户名、文件存取权限、访问控制权限、文件类型等</li>
<li>文件逻辑结构信息: 记录类型、记录个数、记录长度、成组银子等</li>
<li>文件物理结构信息: 文件所在设备名、文件物理结构类型、记录存放在辅存中的块号或文件信息首块盘块号，文件索引的位置等</li>
<li>文件适用信息: 共享文件的进程数，文件修改情况，文件最大长度和当前大小</li>
<li>文件管理信息: 文件建立日期，最近修改日期，最近访问日期等</li>
</ul>
</li>
</ul>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><ul>
<li>文件系统基于FCB来实现文件的按名存取<ul>
<li>创建文件时，为其建立FCB，用来记录文件的属性信息</li>
<li>存取文件时，先找到其FCB，再来找到文件信息盘块号或首块物理位置</li>
</ul>
</li>
<li>为了加快文件的查找速度，通常将FCB集中起来，组成文件目录</li>
<li>文件目录包含至少两种目录选项: 普通文件的FCB、子目录的目录文件的FCB</li>
<li>目录文件至少包含两个目录项<ul>
<li>当前目录项 <code>.</code></li>
<li>父目录项 <code>..</code></li>
</ul>
</li>
<li>文件目录的基本功能<ul>
<li>将文件名转换成此文件信息在磁盘上的物理位置</li>
<li>有效的组织和管理文件</li>
</ul>
</li>
</ul>
<h4 id="一级文件目录"><a href="#一级文件目录" class="headerlink" title="一级文件目录"></a>一级文件目录</h4><p>系统将已建立的所有文件的文件名、存放地址及有关的说明信息放在一张表中，这张表称为一级文件目录(整个系统中只有一个目录文件)</p>
<ul>
<li>特点<ul>
<li>实现简单</li>
<li>不允许两个文件有相同的名字</li>
<li>在多用户环境中，容易出现重名问题</li>
</ul>
</li>
</ul>
<h4 id="二级文件目录"><a href="#二级文件目录" class="headerlink" title="二级文件目录"></a>二级文件目录</h4><ul>
<li>将文件目录分成主目录和用户文件目录两级</li>
<li>每个用户建立一个用户文件目录，等级该用户建立的所有文件的相关信息</li>
<li>主目录等级系统中各个用户文件目录的相关信息</li>
<li>特点<ul>
<li>解决了命名冲突，允许不同用户目录下的文件名可以相同</li>
</ul>
</li>
<li>方法<ul>
<li>存取一个文件时给出文件路径名</li>
<li>在二级文件目录下，文件的路径名是由用户名和文件名拼起来得到的</li>
</ul>
</li>
</ul>
<h4 id="树型文件目录"><a href="#树型文件目录" class="headerlink" title="树型文件目录"></a>树型文件目录</h4><p>在多级目录系统中(除最末一级外)，任何一级目录的录项可以描述一个目录文件，也可以描述一个非目录文件(数据文件)， 而数据文件一定在树叶上。这样就构成了一个树形层次结构。</p>
<h5 id="文件路径名"><a href="#文件路径名" class="headerlink" title="文件路径名"></a>文件路径名</h5><p>多级目录中文件的路径名，是由根目录到该文件的通路上所有目录文件的符号名和该文件的符号名组成的字符串，中间用分隔符分隔</p>
<h5 id="纯树形目录结构"><a href="#纯树形目录结构" class="headerlink" title="纯树形目录结构"></a>纯树形目录结构</h5><ul>
<li>目录可以有任意多的层次</li>
<li>目录可以包含子目录，也可以包含文件</li>
<li>每个文件只有一个父目录</li>
<li>文件共享较为困难</li>
</ul>
<h4 id="DAG目录结构"><a href="#DAG目录结构" class="headerlink" title="DAG目录结构"></a>DAG目录结构</h4><ul>
<li>一个文件可以有多个父目录</li>
<li>能较方便地实现文件的共享</li>
<li>目录结构的维护较复杂</li>
<li>需要为每个文件维护一个引用计数，以记录文件的父目录个数，仅当引用计数值为1时，删除操作才真正删除文件</li>
</ul>
<h2 id="文件共享与安全"><a href="#文件共享与安全" class="headerlink" title="文件共享与安全"></a>文件共享与安全</h2><ul>
<li>文件共享是指某一个或某一部分文件可以让实现规定的某些用户共同适用</li>
<li>文件安全是指保护文件不得被未经文件主授权的任何用户存取，且对于授权用户也智能在允许的存取权限内适用文件。常见权限包括<ul>
<li>无(None): 用户不知道该文件的存在</li>
<li>知情(Knowledge): 用户可以确定该文件的存在和文件的所有者</li>
<li>执行(Execution): 用户可以加载并执行一个程序文件</li>
<li>读(Reading): 用户可以读文件</li>
<li>追加(Appending): 用户可以在文件末尾追加数据，但不能修改或删除内容</li>
<li>更新(Updating): 用户可以在文件中修改、删除或添加数据</li>
<li>变更保护(Chaning protection): 用户可以变更授予其它用户的访问权限</li>
<li>删除(Deletion): 用户可以从文件系统中删除该文件</li>
</ul>
</li>
</ul>
<h3 id="文件共享与文件保护"><a href="#文件共享与文件保护" class="headerlink" title="文件共享与文件保护"></a>文件共享与文件保护</h3><ul>
<li>保护<ul>
<li>操作前先对用户的权限进行验证</li>
<li>所谓存取权限的验证，是指用户存取文件之前，需要检查用户的存取权限是否符合规定，符合者允许适用，否则据绝</li>
</ul>
</li>
<li>验证用户存取权限的方法<ul>
<li>访问控制矩阵</li>
<li>存取控制表</li>
<li>用户权限表</li>
<li>口令</li>
<li>密码</li>
</ul>
</li>
<li>加快文件的查找<ul>
<li>当前目录(值班目录)<ul>
<li>当指定当前目录后，用户对文件的所有访问都是相对于当前目录进行的</li>
</ul>
</li>
<li>链接技术: 在相应目录表目之间进行连接，即个不路中的表目直接指向另一个目表所在的物理位置</li>
</ul>
</li>
</ul>
<h3 id="Linux的链接文件"><a href="#Linux的链接文件" class="headerlink" title="Linux的链接文件"></a>Linux的链接文件</h3><h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><ul>
<li>创建命令<ul>
<li>硬链接: <code>ln /data/ln/src /data/ln/dst</code></li>
<li>软链接: <code>ln -s /data/ln/src /data/ln/dst</code></li>
</ul>
</li>
<li>硬链接与源文件等价；软链接文件中并不包括实际的文件数据，只包括了它指向文件的路径</li>
<li>删除源文件后，硬链接文件可以照常适用，软链接文件的操作则会失败</li>
<li>硬链接不能连接目录文件，软链接既可以连接到普通文件也可以连接到目录</li>
<li>硬链接只限于本文件系统，软连接可以链接到处于不同文件系统的文件及目录</li>
<li>硬链接可以加快文件查找速度，软链接并不能</li>
</ul>
<h2 id="文件操作与文件备份"><a href="#文件操作与文件备份" class="headerlink" title="文件操作与文件备份"></a>文件操作与文件备份</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>常用的文件操作命令<ul>
<li>create 创建一个新文件</li>
<li>delete 从系统目录中撤销一个文件</li>
<li>rename 在系统目录中改变文件的名字</li>
<li>open 打开文件，在用户和文件(或设备)之间建立一个逻辑通路</li>
<li>close 关闭文件，在用户和文件(或设备)之间撤销一个逻辑通路</li>
<li>write 写到一个文件(或设备)上</li>
<li>read 从一个文件(或设备)读入数据信息</li>
</ul>
</li>
<li>打开文件和关闭文件操作<ul>
<li>打开文件操作: 把该文件的有关目录表目复制到主存中的约定区域，建立文件控制块，建立用户和这个文件的联系</li>
<li>关闭文件操作: 用户宣布这个文件当前不再适用，系统将其在主存中的文件控制块山区，因而也就切断了用户同这个文件的联系</li>
</ul>
</li>
<li>文件备份: 为了能在软、硬件实现的以外情况下恢复文件，保证文件的完整性、数据的连续可利用性，文件系统提供适当的机构，以便复制备份<ul>
<li>周期性转储: 按固定的时间周期把存储器中所有文件的内容转存到某种截至上，通常是磁带或磁盘。在系统失效时，使用这些转存磁盘或磁带，将所有文件重新建立并恢复到最后一次转存时的状态</li>
<li>增量型转储: 只转储从上次转储以后已经改变过的信息，增量转储的信息量较小，故转储可在更短的时间周期内进行</li>
<li>文件备份技术的发展: 动态备份，远程备份技术</li>
</ul>
</li>
</ul>
<h2 id="Unix文件系统的主要结构及实现技术"><a href="#Unix文件系统的主要结构及实现技术" class="headerlink" title="Unix文件系统的主要结构及实现技术"></a>Unix文件系统的主要结构及实现技术</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>特点<ul>
<li>树形文件目录结构</li>
<li>可安装拆卸的文件系统</li>
<li>文件是无结构的字节流式文件</li>
<li>将外部设备与文件一样对待</li>
</ul>
</li>
<li>类型<ul>
<li>普通文件: 用户程序、数据文件</li>
<li>目录文件: 用于组织和形成树形目录结构中的一个单位，由若干目录项组成</li>
<li>特别文件: 与硬件设备有关的文件称为特别文件。包括块设备文件、字符设备文件。与计算机链接每一种输入输出设备都有一个特别文件。它式操作系统核心用于存取输入输出设备的通道，是用户与硬件设备联系的桥梁</li>
<li>命名管道: 管道是一种进程间通信机制。管道中缓存了从输入端接收的数据，这样从输入端读数据的进程就能以先进先出的方式来接收数据</li>
<li>链接文件: 本质上，链接文件是一个已存在的文件的另一个文件名</li>
<li>符号链接: 者是一个数据文件，文件中包含了其所链接的那个文件的名字</li>
</ul>
</li>
</ul>
<h3 id="UNIX系统的索引文件结构"><a href="#UNIX系统的索引文件结构" class="headerlink" title="UNIX系统的索引文件结构"></a>UNIX系统的索引文件结构</h3><ul>
<li>文件索引节点<ul>
<li>UNIX系统把文件目录项中除了名字以外的信息全部存放到一个磁盘的数据块上，这种数据块称为磁盘索引节点(index node)，简称i节点(inode)</li>
<li>结构<ul>
<li>文件所有者标识: 定义对一个文件具有存取权的用户集合，分为文件所有者、文件所有者用户组</li>
<li>文件类型: 分为正规文件、目录文件、字符特殊文件或块特殊文件等</li>
<li>文件存取许可权: 按文件所有者、文件的用户组所有者及其它用户三个类别对文件实行保护，每类都具有读、写、执行该文件的存取全，并且能分别地设置</li>
<li>文件链接数目: 表示在文件目录结构中，有多少个文件名指向该文件。每当增加一个名字时，i_ilink值+1，减少一个名字是其值-1.当其值减为0时，该文件才能真正删除</li>
<li>地址索引表: 文件数据的磁盘地址信息，即地址索引表，</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UNIX系统文件目录结构"><a href="#UNIX系统文件目录结构" class="headerlink" title="UNIX系统文件目录结构"></a>UNIX系统文件目录结构</h3><ul>
<li>目录文件与目录项<ul>
<li>目录文件: 每个目录表为一个目录文件。目录文件由目录项组成</li>
<li>目录项: 每个目录项包含16个字节(UNIX老版本)。在目录项中，低1，2字节为响应文件的辅存i节点号，后14个字节为文件名。一个辅存磁盘块(512B)包含32个目录项</li>
</ul>
</li>
<li>树形目录结构<ul>
<li>每个文件系统都有一个根目录文件，它的辅存i节点是相应文件存储设备上辅存索引区中的第一个</li>
<li>打开某个文件时，从根目录的i节点可以找到根目录文件的索引结构，得到根目录文件的每个数据块</li>
<li>将待打开文件的路径信息与目录文件中的目录项逐一比较，可以得到下级目录的i节点号，并最终得到目标文件的i节点号。从i节点号中的索引表，得到数据文件的存储块号，实现对目标文件的随机存取</li>
</ul>
</li>
<li>文件目录结构中的链接<ul>
<li>Unix文件目录结构中带有交叉连接。用户可以用不同的文件路径名共享一个文件</li>
<li>文件连接在用户看来是为一个已存在的文件另起一个路路径名</li>
<li>文件连接的结果表现为一个文件由多个目录项所指向</li>
</ul>
</li>
</ul>
<h3 id="Unix系统的打开文件机构"><a href="#Unix系统的打开文件机构" class="headerlink" title="Unix系统的打开文件机构"></a>Unix系统的打开文件机构</h3><ul>
<li>为了提高系统效率，减少主存空间的占用，系统设置了打开文件和关闭文件操作。当打开一个文件时，建立用户与该文件的联系</li>
<li>文件系统中管理这一工作的结构称为打开文件机构。打开文件机构由活动i节点表、打开文件表和用户文件描述符表组成</li>
<li>活动i节点表<ul>
<li>当执行打开文件操作时，将文件辅存i节点的有关信息拷贝到主存，形成活动i节点(主存索引节点)，若干个活动i节点组成活动i节点</li>
</ul>
</li>
<li>系统打开文件表<ul>
<li>一个文件可以被同一进程或不同进程，用同一或不同路径名，相同的或互异的操作要求(读、写)同时打开。为了记录打开文件所需的附加信息，文件系统设置了一个内核结构: 系统打开文件表</li>
</ul>
</li>
<li>用户文件描述符表<ul>
<li>用户进程扩充块user中的一个数组u_ofile[NOFILE]称为用户文件描述符表，其中的每一项(指针)指向系统打开文件表的一个表项</li>
<li>一个打开文件在用户文件描述表中所占的文职就是它的文件描述符(或称打开文件号)。进程可以打开不同的文件，也可以对统一文件以不同的操作方式打开</li>
</ul>
</li>
</ul>
<h5 id="父子进程对文件的共享"><a href="#父子进程对文件的共享" class="headerlink" title="父子进程对文件的共享"></a>父子进程对文件的共享</h5><ul>
<li>子进程共享父进程的”系统打开文件表项”,该表项的文件打开技术fcount+1，子进程直接使用父进程open()操作返回的fd即可访问该文件</li>
<li>父进程的close()操作不影响子进程对该文件的使用，反之亦然</li>
<li>父子进程独立运行后，各自open的文件就不再共享了，跟两个独立进程打开文件情况一样</li>
</ul>
<h3 id="文件存储器空闲块的管理"><a href="#文件存储器空闲块的管理" class="headerlink" title="文件存储器空闲块的管理"></a>文件存储器空闲块的管理</h3><ul>
<li>文件卷和卷管理块: 一个文件系统就是逻辑设备，每个逻辑设备占用一片连续的磁盘存储空间。文件卷上存放UNIX文件系统。<br>文件卷的结构<table>
<thead>
<tr>
<th align="left">引导块</th>
<th align="left">管理块</th>
<th align="left">索引节点区</th>
<th align="left">数据区</th>
</tr>
</thead>
<tbody><tr>
<td align="left">大小为一个磁盘块，包含引导程序</td>
<td align="left">记录文件系统各种数据，如文件系统大小、空闲块数目等</td>
<td align="left">索引节点结构组成</td>
<td align="left">数据文件占用的区域</td>
</tr>
</tbody></table>
</li>
<li>空闲磁盘块的管理<ul>
<li>UNIX的空闲磁盘块管理采用成组连接法，即将空闲表和空闲连两种方法相结合</li>
<li>系统初启动时，文件存储区是空闲的，将空闲块从尾倒向前，每100块分为一组(最后一组99块)，每一组的最后一块作为索引表，用来等级下一组100块的物理块号和块数</li>
<li>最前面一组(可能不足100块)的物理块号和块数存放在管理块的s_free[100]和s_nfree中</li>
</ul>
</li>
<li>空闲块的分配算法<ul>
<li>检查管理块的空闲块号栈是否已经上锁(邻接资源)，若已上锁则进程睡眠等待</li>
<li>给空闲磁盘块号栈上锁后，将s_nfree减1，若s_nfree仍大于0，即栈中还剩布置一个空闲块，则将s_free[s_nfree]中等级的空闲盘块分配出去</li>
<li>若s_nfree为0，即当前空闲盘块号栈中只剩下最后一个空闲盘块，必须先将该盘块的内容读入管理块的空闲盘块号栈中，然后再将该盘块分配湖区。若s_nfree为0，而且栈底等级的盘块号为0，则表示系统中无空闲盘块可分配</li>
</ul>
</li>
<li>空闲块的回收<ul>
<li>再系统回收空闲盘块时，将回收盘块的盘块号计入空闲盘块号栈的顶部，并执行空闲盘块数加1操作</li>
<li>当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号，记如新回收的盘块中，再将盘块号作为新栈底</li>
</ul>
</li>
</ul>
<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><h2 id="绪论-1"><a href="#绪论-1" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>存储程序式计算机的特点: 集中、顺序、过程控制</li>
<li>计算机系统的组成及操作系统的地位</li>
<li>操作系统的定义: 一个大型软件系统，负责计算机系统软硬件资源的分配，控制和协调并发活动，提供给用户和其它软件方便的接口和环境，使用户获得良好的工作环境</li>
<li>操作系统的特征: 并发、共享、不确定性、虚拟性</li>
<li>操作系统的四大资源管理功能: 处理机调度、内存管理、设备管理、软件资源管理</li>
<li>多道程序设计<ul>
<li>定义: 在计算机主存中同时存放寄到相互独立的程序。这些程序在管理程序控制之下，相互穿插的运行。当谋道程序因&#x3D;某种原因不能继续运行下去时(如等待外部设备传输数据),管理程序便将另一道程序投入运行</li>
<li>特征: <ul>
<li>多道(内存中存放多个相互独立的程序)</li>
<li>宏观上并性(相互川沙运行)</li>
<li>微观上穿行(CPU永远只能执行单个程序)</li>
</ul>
</li>
</ul>
</li>
<li>分时技术<ul>
<li>定义: 把处理机时间分成很短的时间片，轮流分配给各个应用程序使用，如果某个程序在分配的时间片用完之前计算还未完成，该程序就暂停执行，等待下一次获得时间片之后再继续计算</li>
<li>特点: 联机交互、独占使用、响应时间块</li>
</ul>
</li>
<li>操作系统的几个基本类型: 批量操作系统、分时操作系统、实时操作系统、网络操作系统</li>
</ul>
<h2 id="操作系统的结构和硬件支持"><a href="#操作系统的结构和硬件支持" class="headerlink" title="操作系统的结构和硬件支持"></a>操作系统的结构和硬件支持</h2><ul>
<li>处理机的状态及区别<ul>
<li>内核态: 操作系统的管理程序执行时机器所处的状态，在此状态下处理机可以使用全部指令(包括特权指令)和全部系统资源(包括整个存储区域)</li>
<li>用户态: 用户程序执行时机器所处的状态。在此状态下，禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域</li>
</ul>
</li>
<li>中断<ul>
<li>定义: 某个事件发生后系统终止现行程序的运行，引出处理事件程序对该事件进行处理，处理完毕后返回断点继续执行的过程</li>
<li>类型: 外部中断、异常、系统调用</li>
<li>中断响应的实质: 交换指令地址及处理机的状态信息(PSW)</li>
</ul>
</li>
<li>向量中断: 当中断发生时，由中断源自己引导处理机进入中断服务程序的中断过程称为向量中断<ul>
<li>中断向量: 每类中断类型都有自己的中断向量，包含: 中断服务例程的入口地址和程序状态字</li>
<li>中断向量表: 主存中用于存放中断向量服务地址的一组存储单元组成的表</li>
</ul>
</li>
</ul>
<h2 id="操作系统的用户接口-1"><a href="#操作系统的用户接口-1" class="headerlink" title="操作系统的用户接口"></a>操作系统的用户接口</h2><ul>
<li>用户工作环境(系统安装、引导)</li>
<li>处理应用程序的步骤(编辑、编译、链接、运行)<ul>
<li>链接的类型: 静态链接 &amp; 动态链接</li>
</ul>
</li>
<li>操作系统提供的接口: 操作命令、系统功能调用</li>
<li>系统调用: 用户在程序一级请求操作系统服务的一种手段，它是带有一定功能的访管指令。其功能是由操作系统中的程序完成的，即由软件方法实现的<ul>
<li>系统调用 VS 库函数<ul>
<li>系统调用代码属于OS(驻留在内存)，一般库函数由开发软件提供，由编译工具链链入用户程序</li>
<li>系统调用代码的执行引起CPU状态的变化，一般库函数的执行不会引起CPU状态的变化</li>
<li>系统调用减小了用户程序的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程及进程管理-1"><a href="#进程及进程管理-1" class="headerlink" title="进程及进程管理"></a>进程及进程管理</h2><ul>
<li>程序的顺序执行<ul>
<li>定义: 一个计算的若干操作必须按照严格的先后次序顺序的执行</li>
<li>特点: 顺序性、封闭性、可再现性</li>
</ul>
</li>
<li>程序的并发执行<ul>
<li>定义: 若干程序段同时在系统中运行，并且程序的执行时间上是重叠的。</li>
<li>特点: <ul>
<li>程序与计算不再一一对应</li>
<li>程序并发执行的相互制约</li>
<li>失去程序的封闭性和可再现性</li>
</ul>
</li>
</ul>
</li>
<li>进程<ul>
<li>定义: 一个具有一定独立功能的程序关于某个数据集合的一次运行活动</li>
<li>VS 程序<ul>
<li>程序是静态 概念，进程是动态的概念</li>
<li>进程是一个独立运行的活动单位</li>
<li>进程是竞争系统资源的基本单位</li>
<li>一个程序可以对应多个进程，一个进程至少包含一个程序</li>
</ul>
</li>
</ul>
</li>
<li>进程的三个基本状态: 运行、就绪、等待</li>
<li>进程的组成: 程序控制块PCB + 程序与数据<ul>
<li>程序控制块: 描述进程与其它进程、系统资源的概念以及进程在各个不同时期所处的状态的数据结构。</li>
<li>程序数据: 描述进程本身应完成的功能</li>
</ul>
</li>
<li>基本进程控制原语: 创建原语、撤销原语、等待原语、唤醒原语</li>
<li>进程间制约: 临界资源、临界区、互斥、同步</li>
<li>同步机构: 锁、信号灯</li>
<li>用PV操作或上锁&#x2F;开锁实现进程互斥</li>
<li>合作进程的执行次序</li>
<li>共享缓冲区的合作进程的同步</li>
<li>生产者-消费者问题的解答</li>
<li>进程通信</li>
<li>线程的概念</li>
<li>Linux进程、线程基本控制接口</li>
</ul>
<h2 id="资源分配与调度-1"><a href="#资源分配与调度-1" class="headerlink" title="资源分配与调度"></a>资源分配与调度</h2><ul>
<li>资源分配机制: 资源描述器、资源信息块</li>
<li>常用的资源分配策略: 先请求先服务、优先调度</li>
<li>死锁的定义及举例</li>
<li>引起死锁的原因: 系统资源不足，进程推进顺序非法</li>
<li>产生死锁的必要条件: 互斥条件，不剥夺条件，部分分配，环路条件</li>
<li>死锁的处理<ul>
<li>预防、避免与检测: 静态资源分配、有序资源分配、银行家算法</li>
</ul>
</li>
</ul>
<h2 id="处理机调度-1"><a href="#处理机调度-1" class="headerlink" title="处理机调度"></a>处理机调度</h2><ul>
<li>多级调度(作业调度、进程调度)<ul>
<li>作业调度: 先来先服务、短作业优先、响应比高优先</li>
<li>进程调度算法<ul>
<li>剥夺&#x2F;非剥夺</li>
<li>静态优先数、动态优先数</li>
<li>基于优先数的调度算法</li>
<li>循环轮转调度算法</li>
<li>多队列循环轮转调度</li>
</ul>
</li>
</ul>
</li>
<li>进程状态变迁图</li>
</ul>
<h2 id="主存管理-1"><a href="#主存管理-1" class="headerlink" title="主存管理"></a>主存管理</h2><ul>
<li>地址映射的概念及类型<ul>
<li>概念: 将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程</li>
<li>类型: 编译时确定地址映射、程序装如时确定地址映射(静态地址映射)、程序运行时确定地址映射(动态地址映射)</li>
</ul>
</li>
<li>虚拟存储器: 由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度，让计算机好像为用户提供了一个比实际主存大得多的存储器，称为虚拟存储器<ul>
<li>核心: 逻辑地址与物理地址分开、存储空间与虚地址空间分开、提供地址变换机构</li>
<li>物质基础: 有大容量辅存、地址变换机构</li>
</ul>
</li>
<li>界地址保护方法: 上下界保护、基址限长保护</li>
<li>动态分区存储管理<ul>
<li>自由主存(空闲区)队列机构: 地址-&gt;flag+size+next_addr</li>
<li>首次适应算法、最佳适应、最坏适应</li>
</ul>
</li>
<li>页式存储管理</li>
<li>页面、内存块、页表</li>
<li>页式地址变换、快表、多级页表</li>
<li>请调策略的扩充页表: 页号+主存块号+中断位+辅存地址</li>
<li>淘汰策略的扩充页表: 页号+主存块号+中断位+辅存地址+引用位+改变位</li>
<li>最佳置换算法(不可能)、先进先出、LRU、LRU近似</li>
<li>段式与段页式系统及其地址结构</li>
</ul>
<h2 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I&#x2F;O管理"></a>I&#x2F;O管理</h2><ul>
<li>设备独立性的定义及优点<ul>
<li>定义: 用户在程序中使用的设备与实际使用的设备无关，也就是用户程序中仅使用逻辑设备名</li>
<li>优点: 方便用户、改善设备利用率、提高系统的可扩展性和可适应性</li>
</ul>
</li>
<li>设备控制块: 系统为每一台设备都配置了一个用来记录设备的硬件特性、链接和使用情况的一组数据</li>
<li>缓冲技术: 两种不同速度的设备之间传输信息时平滑传输过程的常用手段</li>
<li>常用的缓冲技术: 双缓冲、环形缓冲、缓冲池</li>
</ul>
<h2 id="文件系统-2"><a href="#文件系统-2" class="headerlink" title="文件系统"></a>文件系统</h2><ul>
<li>文件概念: 在逻辑上具有完整意义的集合，有一个名字以标识，文件名是有若干约束的字符串</li>
<li>文件系统的主要功能: 按名存取</li>
<li>文件的逻辑结构: 流式文件 &amp; 记录式文件</li>
<li>文件存取方法: 顺序存取、随机存取</li>
<li>文件的物理结构<ul>
<li>连续文件、串联文件、FAT文件、索引文件</li>
</ul>
</li>
<li>文件存储空间(磁盘)管理</li>
<li>文件目录项和目录文件</li>
</ul>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST_CS_数据库整理</title>
    <url>/2024/07/06/HUST-CS-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><ul>
<li>数据<ul>
<li>数据是信息的符号表示或载体,信息则是数据的内涵,是对数据的语义解释</li>
</ul>
</li>
<li>数据库<ul>
<li>数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合</li>
<li>数据是数据库中存储的基本对象</li>
<li>数据库的基本特征:<ul>
<li>数据按一定的数据模型组织、描述和存储</li>
<li>可为各种用户共享</li>
<li>冗余度小</li>
<li>数据独立性高</li>
<li>容易扩展</li>
</ul>
</li>
</ul>
</li>
<li>数据库管理系统<ul>
<li>DBMS是对数据库进行管理的大型系统软件,是数据库系统的核心组成部分<ul>
<li>位于用户与操作系统之间的一层数据管理软件</li>
<li>是基础软件,是一个大型复杂的软件系统</li>
</ul>
</li>
<li>用途:科学的组织和存储数据、高效的获取和维护数据</li>
<li>用户在数据库系统中的一切操作,包括数据定义、查询、更新一集各种控制,都是通过DBMS进行的</li>
<li>主要功能:<ul>
<li>数据定义</li>
<li>数据组织、存储和管理</li>
<li>数据操纵功能</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护功能(实用程序)</li>
<li>其它(如和其它系统的通信、交换)</li>
</ul>
</li>
</ul>
</li>
<li>数据库系统<ul>
<li>构成<ul>
<li>数据库</li>
<li>数据库管理系统(及开发工具)</li>
<li>应用系统</li>
<li>数据库管理员</li>
</ul>
</li>
<li>目的:<ul>
<li>给用户提供整体数据的抽象视图,将磁盘上的所有物理数据集合抽象成整体结构化的虚拟数据,隐藏了细节</li>
</ul>
</li>
<li>文件系统与数据库系统的区别<ul>
<li>文件系统,关注的是系统功能的设计,因此程序设计处于主导地位,数据服从于程序设计</li>
<li>数据库系统阶段,数据的结构设计成为信息系统首先关心的问题</li>
</ul>
</li>
<li>数据库系统的特点:<ul>
<li>数据结构化<ul>
<li>整体结构话是数据库的主要特征之一.数据面向全组织,不仅数据内部结构化,整体是结构化的,数据之间具有联系</li>
<li>数据库中实现的事数据的真正结构化<ul>
<li>数据的结构用数据模型描述,无需程序定义和解释</li>
<li>数据可以变长</li>
<li>数据的最小存取单位是数据项</li>
</ul>
</li>
</ul>
</li>
<li>数据的共享性高,冗余度低,易扩充<ul>
<li>数据面向整个系统,数据集中管理,冗余度低</li>
<li>节省存储空间,减少存取时间,避免数据之间的不一致性</li>
<li>每个应用自己选数据库的子集</li>
<li><em>数据库中并非完全消除荣誉</em>.有时为了提高数据的存取效率,可保留多个副本</li>
</ul>
</li>
<li>数据独立性高<ul>
<li>逻辑独立性:数据总体逻辑结构改变,数据的局部逻辑结构不变</li>
<li>无力独立性:数据的存储结构改变,数据的逻辑结构不变,从而应用程序也不需要改变</li>
</ul>
</li>
<li>数据由DBMS统一管理和控制<ul>
<li>统一的数据管理和控制功能:<ul>
<li>安全性</li>
<li>完整性</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型:是一种描述数据、数据联系、数据语义及一致性约束的抽象工具,对显示世界数据特征的描述</p>
<ul>
<li><p>概念模型</p>
<ul>
<li>按照用户的观点对数据建模<ul>
<li>特点:语义表达能力强、便于直接表示应用语义、简单、清晰、易于理解</li>
</ul>
</li>
<li>e.g. E-R模型</li>
</ul>
</li>
<li><p>信息学基本概念</p>
<ul>
<li>实体entity:客观存在可相互区别的事物、事件和概念</li>
<li>属性Attribute:实体具有的特征</li>
<li>码&#x2F;键key:唯一标识一个实体集中任何实体值又不含多余属性的属性集</li>
<li>实体型entity type:具有相同特征和性质的实体与属性命名序列</li>
<li>实体值entity value:实体型的具体实例</li>
<li>实体集entity set:具有相同类型及相同性质(属性)的实体集合</li>
<li>联系:一对一、一对多、多对多</li>
</ul>
</li>
<li><p>数据模型的组成要素</p>
<ul>
<li>数据结构:描述数据库的组成对象及对象之间的关系<ul>
<li>描述系统的静态特性</li>
<li>数据结构是所研究的对象类型的结合,是刻画一个数据模型性质最重要的方面</li>
</ul>
</li>
<li>数据操作:对数据库中各种对象(型)对实例(值)允许执行的操作的集合,包括操作及有关的操作规则<ul>
<li>描述系统的动态特性</li>
<li>对数据库中各种数据操作的集合,包括操作及相应的操作规则</li>
<li>数据模型必须定义这些操作的确切含义、操作规则以及实现操作的语言</li>
</ul>
</li>
<li>数据的约束条件<ul>
<li>是一组完整性规则的集合</li>
<li>完整性规则是给定的数据模型中数据及器联系所具有的制约和遗存规则,用以限定符合数据模型的数据库状态以及状态的变化,以保证数据的正确、有效、相容</li>
<li>数据模型还应该提供定义完整心约束条件的机制,以反映具体应用所涉及的数据结构必须遵守的特定的语义约束条件</li>
</ul>
</li>
</ul>
</li>
<li><p>层次模型</p>
<ul>
<li>用树形结构表示实体及实体间联系</li>
<li>特点：<ul>
<li>节点的双亲是唯一的：根节点没双亲，其它节点只有一个双亲</li>
<li>只能直接处理一对多的实体联系</li>
<li>每个记录类型可以定义一个排序字段，也称为码字段</li>
<li>任何记录值只有按其路径查看时，才能显出它的全部意义</li>
<li>没有一个子女记录值能够脱离双亲记录值而独立存在</li>
</ul>
</li>
<li>存储结构<ul>
<li>邻接法：前序遍历记录</li>
<li>子女-兄弟链接法</li>
<li>层次序列链接发</li>
</ul>
</li>
</ul>
</li>
<li><p>网状模型</p>
<ul>
<li>特征<ul>
<li>可以有多个节点无父节点</li>
<li>至少有一个节点有多个父节点</li>
</ul>
</li>
</ul>
</li>
<li><p>关系模型</p>
<ul>
<li>关系必须是规范化的，满足一定的规范条件<ul>
<li>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表</li>
</ul>
</li>
<li>数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合<ul>
<li>查询、插入、删除、更新</li>
</ul>
</li>
<li>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</li>
<li>关系的完整性约束条件<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><ul>
<li>数据模型中的“型”和“值”<ul>
<li>型：对某一数据的结构和属性的说明</li>
<li>值：型的具体赋值</li>
</ul>
</li>
</ul>
<h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><ul>
<li>模式schema<ul>
<li>数据库中全体数据的逻辑结构和特征的描述</li>
<li>仅仅是型的描述，与具体的值无关</li>
<li>反应的是数据的结构及其联系</li>
<li>模式是相对稳定的</li>
</ul>
</li>
<li>实例Instance<ul>
<li>模式的一个具体值；反应数据库某一时刻的状态</li>
<li>同一个模式可以有很多实例</li>
<li>实例随数据库中数据的更新而变动</li>
</ul>
</li>
</ul>
<h3 id="数据库系统的三级模式"><a href="#数据库系统的三级模式" class="headerlink" title="数据库系统的三级模式"></a>数据库系统的三级模式</h3><p>模式、外模式、内模式，三级模式之间有两级映像</p>
<p>提高了数据的逻辑独立性和物理独立性</p>
<ul>
<li>模式（逻辑模式）(schema)<ul>
<li>数据库中全体数据的逻辑结构和特征的描述</li>
<li>所有用户的公共数据视图——全局逻辑视图，综合了所有用户的需求</li>
<li>一个数据库只有一个模式</li>
<li>模式的地位：是数据库模式结构的中间层，独立于数据库的其它层次</li>
<li>定义：<ul>
<li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li>
<li>数据之间的联系</li>
<li>数据有关的安全性、完整性要求</li>
</ul>
</li>
<li>模式一般由多个“记录”组成，包含数据库的所有信息</li>
<li>设计数据库模式结构应该首先确定数据库的逻辑模式</li>
<li>模式的作用是为了支持数据的少冗余共享</li>
</ul>
</li>
<li>外模式（子模式subschema、用户模式）<ul>
<li>数据库用户使用的局部数据的逻辑结构和特征的描述</li>
<li>数据库用户的数据视图，面向具体的应用程序，是与某一应用有关的数据的逻辑标识</li>
<li>定义再逻辑模式之上</li>
<li>独立于存储模式和存储设备</li>
<li>当应用需求发生较大变化，相应外模式不能满足视图要求时，该外模式就得做相应改动</li>
<li>设计外模式时应充分考虑到应用的扩充性</li>
<li>地位：介于模式与应用之间<ul>
<li>模式与外模式的关系：一对多<ul>
<li>外模式通常是模式的子集</li>
<li>一个数据库可以由多个外模式。</li>
<li>对模式中同一数据，再外模式中的结构、类型、长度、保密级别等都可以不同</li>
</ul>
</li>
<li>外模式与应用的关系：一对多<ul>
<li>同一外模式页可以为某一用户的多个应用系统锁时使用</li>
<li>但一个引用程序只能使用一个外模式</li>
</ul>
</li>
</ul>
</li>
<li>用途：<ul>
<li>支持不同用户建立适应局部应用特征的结构，每个用户只能看见和访问锁对应的外模式中的数据</li>
<li>简化应用处理</li>
<li>提高安全性，保证数据库安全性的一个有力措施</li>
</ul>
</li>
</ul>
</li>
<li>内模式（internal schema，存储模式storage schema，物理模式）<ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的标识方式</li>
<li>一个数据库只有一个内模式</li>
</ul>
</li>
</ul>
<h3 id="数据库的二级映像与数据独立性"><a href="#数据库的二级映像与数据独立性" class="headerlink" title="数据库的二级映像与数据独立性"></a>数据库的二级映像与数据独立性</h3><p>二级映像在DBMS内部实现这三个抽象层次的联系和转换</p>
<ul>
<li><p>外模式&#x2F;模式映像：定义某一个外模式和模式之间的对应关系</p>
<ul>
<li>作用：保证数据的逻辑独立性<ul>
<li>当模式改变时，数据库管理员修改有关的外模式&#x2F;模式影响，使外模式保持不变</li>
<li>应用程序使依赖数据的外模式编写的，所以应用程序不必修改，保证了数据与程序的逻辑都要理性，简称数据的逻辑独立性</li>
</ul>
</li>
</ul>
</li>
<li><p>模式&#x2F;内模式映像：定义了数据全局逻辑结构与存储结构之间的对应关系</p>
<ul>
<li>数据库中模式&#x2F;内模式映像使唯一的</li>
<li>该映像定义通常包含在模式描述中</li>
<li>保证数据的物理独立性：<ul>
<li>当数据库的存储结构改变了，数据库管理员修改模式&#x2F;内模式映像，使模式保持不变</li>
<li>存储结构变化的映像被限制在模式之下，这使数据的存储结构和存储方法独立于应用程序而不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li>
</ul>
</li>
</ul>
</li>
<li><p>三级模式结构的优点</p>
<ul>
<li>保证数据的独立性（物理独立性&amp;逻辑独立性）</li>
<li>简化了用户接口：<ul>
<li>按照外模式编写应用系统或敲入命令，不需要了解数据库内部的存储结构，</li>
</ul>
</li>
<li>有利于数据共享<ul>
<li>在不同的外模式下可由多个用户共享系统中数据，减少了数据冗余</li>
</ul>
</li>
<li>利于数据安全保密<ul>
<li>在外模式下根据要求操作，不能对限定的数据操作，保证了其它数据的安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="关系数据库结构及形式化定义"><a href="#关系数据库结构及形式化定义" class="headerlink" title="关系数据库结构及形式化定义"></a>关系数据库结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li><p>单一的数据结构——关系</p>
<ul>
<li>显示世界的实体以及实体间的各种联系均用关系来标识</li>
</ul>
</li>
<li><p>逻辑结构——二维表</p>
<ul>
<li>从用户角度，关系模型中数据的逻辑结构是一张二维表</li>
</ul>
</li>
<li><p>关系模型建立在集合代数的基础上</p>
<ul>
<li>域(domain)</li>
<li>笛卡尔积</li>
<li>关系</li>
</ul>
</li>
<li><p>域：是一组具有相同数据类型的值的集合</p>
<ul>
<li>域中锁包含的值的个数称为域的基数</li>
<li>关系中用域标识属性的取值范围</li>
</ul>
</li>
<li><p>笛卡尔积</p>
<ul>
<li>给定一组域$D_1,D_2,…,D_n$，这些域中可以有相同的，则$D_1,D_2,…,D_n$的笛卡尔积为</li>
<li>$$ D_1 \times D_2 \times … \times D_n &#x3D; {(d_1,d_2,…,d_n) | d_i \in D_i, i&#x3D;1,2,…,n } $$</li>
<li>笛卡尔积中每一个元素$(d_1,…,d_n)$叫做一个n元组</li>
<li>笛卡尔积元素$(d_1,…,d_n)$中的每一个值$d_i$叫做一个分量</li>
<li>若$D_i$为有限集，基数$m_i$，则$D_1 \times D_2 \times … \times D_n$的基数M为$M&#x3D;\Pi _{i&#x3D;1}^{n}m_i$</li>
<li>笛卡尔积是一个集合；是所有域的所有取值的一个组合</li>
<li><strong>不能重复</strong></li>
</ul>
</li>
<li><p>关系</p>
<ul>
<li>笛卡尔积的自己叫做在域$D_1,D_2,…,D_n$上的关系，用$R(D_1,…,D_n)$表示</li>
<li>R是关系的名字，n是关系的度或目(Degree)</li>
<li>关系中的每个元素称为元组</li>
<li>关系中不同列可以对应相同的域，为了加以区分，必须对每列其一个名字，称为属性</li>
<li>n目关系必有n个属性</li>
<li>候选码：<ul>
<li>若关系中的某一属性组的值能唯一地表示一个元组，若从属性组中去掉任意属性，它就不再具有这一性质，则称该属性组为候选码</li>
<li>主码：若有一个关系又多个候选码，则选定其中一个为主码<ul>
<li>每个关系又且仅有一个主码</li>
</ul>
</li>
<li>主属性：候选码的诸属性</li>
<li>非主属性或非码属性：不包含在任何候选码中的属性</li>
</ul>
</li>
<li>三类关系：<ul>
<li>基本关系（基本表或基表）<ul>
<li>实际存在的表，是实际存储数据的逻辑表示</li>
</ul>
</li>
<li>查询表<ul>
<li>查询结果对应的表</li>
</ul>
</li>
<li>视图表<ul>
<li>由基本表或其它视图表到处的表，是虚表，不对应实际存储的数据</li>
</ul>
</li>
</ul>
</li>
<li>关系与二维表的区别：关系是规范化了的二维表中行的集合，为了使相应的数据操作简化，在关系模型中对关系做了限制</li>
<li>基本关系的6大特性<ul>
<li>列是同质的(Homogeneous)</li>
<li>不同的列可出自同一个域，其中的每一列称为一个属性，不同的属性要基于不同的属性名</li>
<li>列的顺序无所谓，列的次序可以任意交换</li>
<li>任意两个元组的候选码不能相同</li>
<li>行的顺序无所谓，行的次序可以任意交换</li>
<li>分量必须取原子值，即每个分量是都不可分的数据项</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><ul>
<li>关系模式是型，相对静态，稳定</li>
<li>关系是值，是关系模式在某一时刻的状态或内容，是动态的、随时间不断变化的</li>
<li>关系模式是对关系的描述<ul>
<li>元组集合的结构：<ul>
<li>属性构成</li>
<li>属性来自的域</li>
<li>属性与域之间的映像关系</li>
</ul>
</li>
<li>元组语义以及完整性约束条件</li>
<li>属性间的数据依赖关系集合</li>
</ul>
</li>
<li>关系模式，记作R(U,D,DOM,F)<ul>
<li>R:关系名</li>
<li>U:R中的属性名集合</li>
<li>D:属性组U中属性锁来自的域（取值范围）</li>
<li>DOM:属性到域的映像集（属性类型、长度）</li>
<li>F：属性间数据的依赖关系集合</li>
</ul>
</li>
</ul>
<h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li>在关系中的所有元组在码上的取值满足<ul>
<li>主属性非空</li>
<li>主码各不相同</li>
</ul>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li>若属性（组）F是基本关系R的外码，它域基本关系S的主码Ks相对应（R和S不一定是不同的关系），则uiyuR中每个元组在F上的值必须为<ul>
<li>空值（F的每个属性值均为空）</li>
<li>S中某个元组的主码值</li>
</ul>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><p>除笛卡尔积外，要求参加运算的关系必须具备相容性</p>
<ul>
<li><p>相容性</p>
<ul>
<li>具有相同的度n</li>
<li>R中的第i个属性和S中的第i个属性来自同一个域</li>
</ul>
</li>
<li><p>并</p>
</li>
<li><p>差</p>
</li>
<li><p>交</p>
</li>
<li><p>笛卡尔积</p>
</li>
</ul>
<h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><ul>
<li>选择<ul>
<li>$\sigma _F(R) &#x3D; {t|t\in R \cap F(t)&#x3D;true }$</li>
<li>其中，$\sigma$为选择运算符，F为条件表达式。$\sigma _F(R)$表示从R中挑选满足公式F的元组所构成的关系</li>
</ul>
</li>
<li>投影<ul>
<li>从R中选择处若干属性列组成新的关系</li>
<li>$\pi _{A(R)}&#x3D;{t[A]|t \in R }$</li>
<li>投影的结果要去掉相同的行（避免重复行）<ul>
<li>投影之后不仅取消了原关系中的某些列，还可能取消某些元组</li>
</ul>
</li>
</ul>
</li>
<li>连接：从两个关系的笛卡尔积中选取满足连接条件的元组<ul>
<li>等值连接：从关系R域S的广义笛卡尔积中选取A、B属性值相等的哪些元素</li>
<li>自然连接：特殊的等值连接<ul>
<li>两个关系中进行比较的分量必须是相同的属性组</li>
<li>在结果中把重复的属性列去掉</li>
<li>当R和S无相同属性时，自然连接就是做笛卡尔积</li>
<li>本质是将两张由关联的表，按照元组之间在属性B（外码）上的等值关系，合并为一张表</li>
<li>问题：会丢失信息，如丢失一个未选课的学生</li>
</ul>
</li>
<li>外连接：把舍弃的元组页保存在结果关系中，而在其它属性上填空值null</li>
<li>左外连接：只把左边关系R中要舍弃的元组保留(left join)</li>
<li>右外连接：只把右边关系S中要舍弃的元组保留(right join)</li>
</ul>
</li>
<li>除 $R\div S$<ul>
<li>$T&#x3D;\pi _{1,…,r-s}(R)$</li>
<li>$W&#x3D;(T\times S)-R$</li>
<li>$V&#x3D;\pi_{1,..,r-s}(W)$</li>
<li>$R\div S&#x3D;T-V$</li>
<li>即$R\div S&#x3D;\pi_{1,…,r-s}(R)-\pi _{1,…,r-s}((\pi _{1,…,r-s}(R)\times S)-R)$</li>
</ul>
</li>
</ul>
<h2 id="关系演算-不重要"><a href="#关系演算-不重要" class="headerlink" title="关系演算(不重要)"></a>关系演算(不重要)</h2><ul>
<li>关系演算:以处理逻辑中的谓词演算为基础</li>
<li>按谓词变元不同进行分类<ul>
<li>元祖关系演算:以远足变量作为谓词变元的基本对象</li>
<li>域关系演算:以域变量作为谓词变元的基本对象</li>
</ul>
</li>
</ul>
<h1 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h1><h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><ul>
<li>SQL是非过程化语言</li>
<li>核心动词<ul>
<li>数据查询(DQL): select</li>
<li>数据定义(DDL): create, drop, alter</li>
<li>数据操纵(DML): delete, update, insert</li>
<li>数据控制(DCL): grant, revoke</li>
</ul>
</li>
</ul>
<h3 id="SQL的基本概念"><a href="#SQL的基本概念" class="headerlink" title="SQL的基本概念"></a>SQL的基本概念</h3><ul>
<li><p>基本表(base table)</p>
<ul>
<li>独立存在的表,SQL中一个关系就对应一个基本表</li>
<li>一个(或多个)基本表对应一个存储文件</li>
<li>一个表可以带若干索引,索引也放在存储文件中</li>
</ul>
</li>
<li><p>存储文件(stored file)</p>
<ul>
<li>逻辑结构组成了关系数据库的内模式</li>
<li>无力结构是任意的,对用户透明</li>
</ul>
</li>
<li><p>视图(view)</p>
<ul>
<li>从一个或几个基本表导出的表</li>
<li>数据库中之存放视图的定义而不存放视图对应的数据,视图是一个虚表</li>
<li>用户可以在视图上再定义视图</li>
</ul>
</li>
<li><p>在一个目录下可以建立多个模式</p>
</li>
<li><p>在一个模式下可以建立多个关系表</p>
</li>
</ul>
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL的数据定义语言DDL功能:模式定义、表定义、视图和索引定义</p>
<table>
<thead>
<tr>
<th align="left">操作对象</th>
<th align="left">创建</th>
<th align="left">删除</th>
<th align="left">修改</th>
</tr>
</thead>
<tbody><tr>
<td align="left">模式</td>
<td align="left">create schema</td>
<td align="left">drop schema</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">表</td>
<td align="left">create table</td>
<td align="left">drop table</td>
<td align="left">alter table</td>
</tr>
<tr>
<td align="left">视图</td>
<td align="left">create view</td>
<td align="left">drop view</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">索引</td>
<td align="left">create index</td>
<td align="left">drop index</td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>层次化数据库对象命名机制</li>
<li>1个DBMS实例:多个DB<ul>
<li>1个DB中:多个模式<ul>
<li>1个模式下:多个表、视图、索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><ul>
<li>定义模式<ul>
<li>语句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">authorization</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span></span><br><span class="line">    [<span class="operator">&lt;</span>表定义子句<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>视图定义子句<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>授权定义子句<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li>
<li>语义:为某用户创建一个模式.定义模式实际上定义了一个命名空间,其中可以定义该模式包含的数据库对象,例如基本表、视图、索引等</li>
<li>在create schema中可以接受create table, create view和grant子句</li>
</ul>
</li>
<li>删除模式<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> schema <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span><span class="operator">&lt;</span>cascade<span class="operator">|</span>restrict<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cascade(级联):删除模式等同事把该模式中所有的数据库对象全部删除</li>
<li>restrict(限制):如果该模式中定义了下属的数据库对象(如表,视图等),则拒绝该删除语句的执行.当该模式中没有任何下属的对象时才能执行</li>
</ul>
</li>
</ul>
<h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><ul>
<li>定义基本表:SQL DDL不仅运行定义一组关系,也要说明每个关系的信息<ul>
<li>每个关系的模式</li>
<li>每个属性的值域</li>
<li>完整性约束</li>
<li>每个关系的安全性和权限</li>
<li>每个关系需要的索引集合</li>
<li>每个关系在磁盘上的无力存储结构</li>
</ul>
</li>
<li>基本表的定义(创建)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (</span><br><span class="line">  <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[列级完整性约束条件]</span><br><span class="line">  [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,<span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[列级完整性约束条件]]</span><br><span class="line">  ...</span><br><span class="line">  [,<span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;表名&gt;:所要定义的基本表的名字</li>
<li>&lt;列名&gt;:组成该表的各个属性(列)</li>
<li>&lt;列级完整性约束条件&gt;:设计相应属性列的完整性约束条件</li>
<li>&lt;表级完整性约束条件&gt;:设计一个活多个属性列的完整性约束条件</li>
</ul>
</li>
<li>创建基本表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">  列名 数据类型 [<span class="keyword">default</span> 缺省值] [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  [,列名 数据类型 [<span class="keyword">default</span> 缺省值][<span class="keyword">not</span> <span class="keyword">null</span>]...]</span><br><span class="line">  [, <span class="keyword">primary</span> key(列名[,列名]...)]</span><br><span class="line">  [<span class="keyword">foreign</span> key(列名[,列名]...) <span class="keyword">references</span> 表名(列名[,列名]...)]</span><br><span class="line">  [, <span class="keyword">check</span> (条件表达式)]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>常用的完整性约束<ul>
<li>主码: primary key</li>
<li>唯一性约束: unique</li>
<li>非空值约束: not null</li>
<li>参照完整性约束: foreign key</li>
<li>自定义的完整性约束: check(逻辑表达式)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char(n)</td>
<td align="left">长度为n的定长字符串</td>
</tr>
<tr>
<td align="left">varchar(n)</td>
<td align="left">最大长度为n的变长字符串</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">长整数</td>
</tr>
<tr>
<td align="left">smallint</td>
<td align="left">短整数</td>
</tr>
<tr>
<td align="left">numeric(p,d)</td>
<td align="left">定点数,由p位数字(不包括符号、小数点)组成,小数点后有d位</td>
</tr>
<tr>
<td align="left">real</td>
<td align="left">取决于机器精度的浮点数</td>
</tr>
<tr>
<td align="left">double precision</td>
<td align="left">取决于机器精度的双精度浮点数</td>
</tr>
<tr>
<td align="left">float(n)</td>
<td align="left">浮点数,精度至少为n位数字</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">日期,包含年、月、日,格式为YYY-MM-DD</td>
</tr>
<tr>
<td align="left">time</td>
<td align="left">时间,格式HH:MM:SS</td>
</tr>
<tr>
<td align="left">interval</td>
<td align="left">两个date或time类型数据之间的差</td>
</tr>
</tbody></table>
<h4 id="模式与表"><a href="#模式与表" class="headerlink" title="模式与表"></a>模式与表</h4><ul>
<li>每一个基本表都属于某一模式</li>
<li>一个模式包含多个基本表</li>
<li>定义基本表所属模式<ul>
<li>在表名中明显给出模式名<ul>
<li><code>create table &quot;S-T&quot;.Student (...);</code></li>
</ul>
</li>
<li>在创建模式语句中同时创建表</li>
</ul>
</li>
</ul>
<h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">  [<span class="keyword">add</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[完整性约束]]</span><br><span class="line">  [<span class="keyword">add</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">  [<span class="keyword">drop</span> [<span class="keyword">column</span>]<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[cascade<span class="operator">|</span>restrict]]</span><br><span class="line">  [<span class="keyword">drop</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[cascade<span class="operator">|</span>restrict]]</span><br><span class="line">  [<span class="keyword">alter</span> <span class="keyword">column</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>语义:<ul>
<li>对名为&lt;表名&gt;的表做add、drop或alter column操作</li>
<li>add可以增加一个新的列</li>
<li>drop只能删除表上的完整性约束?(~也可以删除列啊)</li>
<li>alter只能更改列上的数据类型</li>
</ul>
</li>
</ul>
<h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[restrict<span class="operator">|</span>cascade];</span><br></pre></td></tr></table></figure>
<ul>
<li>restrict<ul>
<li>欲删除的基本表不能被其他表的约束所引用</li>
<li>如果存在依赖该表的对象,啧此表不能被删除</li>
</ul>
</li>
<li>cascade:删除的时候,相关的依赖对象一起删除(包括其他表和视图)</li>
</ul>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><ul>
<li>建立索引的目的:加快查询速度</li>
<li>谁建立索引<ul>
<li>DBA或表的属主</li>
<li>DBMS一般会自动为主码和uniqe属性的列创建索引</li>
</ul>
</li>
<li>谁维护索引:DBMS自动完成</li>
<li>谁使用索引:SQL用户不直接使用索引. DBMS自动选择是否使用索引以及使用哪些索引</li>
</ul>
<h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][cluster] index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">on</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>][,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]]...);</span><br><span class="line">  <span class="comment">-- 其中,&lt;次序&gt;指升序或降序,缺省为升序</span></span><br></pre></td></tr></table></figure>
<ul>
<li>坏处:过多或不当的索引会耗费空间,且降低插入、删除、更新的效率</li>
<li>说明:<ul>
<li>unique(单一索引):<ul>
<li>唯一索引,表示索引项值对应元祖唯一,不允许存在索引值相同的两行</li>
</ul>
</li>
<li>cluster(聚集索引):<ul>
<li>索引项的顺序与表中记录的物理顺序一致,表中如果有多个记录在索引字段上相同,这些记录构成一簇,只有一个索引值</li>
</ul>
</li>
<li>在最经常查询的列上建立聚簇索引以提高查询效率</li>
<li>经常更新的列不宜建立聚簇索引</li>
</ul>
</li>
</ul>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> index <span class="operator">&lt;</span>旧索引名<span class="operator">&gt;</span> rename <span class="keyword">to</span> <span class="operator">&lt;</span>新索引名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">drop</span> index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>数据字典:关系 DBMS内部的一组系统表,记录数据库中所有的定义信息</p>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><ul>
<li>select语句的基本句法<br>$$ \pi _{A_1,…,A_n}(\sigma _F (R_1 \times … \times R_m)) $$<br>对应的语句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A1,...,An</span><br><span class="line"><span class="keyword">from</span> R1,...,Rm</span><br><span class="line"><span class="keyword">where</span> F</span><br></pre></td></tr></table></figure></li>
<li>select语句的完整句法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">all</span><span class="operator">|</span>distinc]<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>]...</span><br><span class="line">  <span class="keyword">from</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>]...</span><br><span class="line">  [<span class="keyword">where</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">  [<span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">having</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">  [<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]]</span><br></pre></td></tr></table></figure>
<ul>
<li>where子句称为行条件子句</li>
<li>group子句称为分组子句</li>
<li>having子句称为组条件子句</li>
<li>order子句称为排序子句</li>
</ul>
</li>
</ul>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><ul>
<li>字符匹配<ul>
<li>通配符<ul>
<li>百分号% 代表任意长度的字符串</li>
<li>下划线_ 代表任意一个字符</li>
<li>escape’&#39; 表示”&quot;是一个换码字符</li>
</ul>
</li>
</ul>
</li>
<li>对于空值的时候,只能是<code>is null</code>,不能用等号</li>
<li>聚集函数<ul>
<li>计数<ul>
<li>count([distinct|all]*):统计元祖个数</li>
<li>count([distinct|all]&lt;列名&gt;):统计一列中值的个数</li>
</ul>
</li>
<li>计算总和<ul>
<li>sum([distinct|all]&lt;列名&gt;)</li>
</ul>
</li>
<li>计算平均值<ul>
<li>avg([distinct|all]&lt;列名&gt;)</li>
</ul>
</li>
<li>最大值最小值<ul>
<li>max([distinct|all]&lt;列名&gt;)</li>
<li>min([distinct|all]&lt;列名&gt;)</li>
</ul>
</li>
<li>集函数只能用于select子句和having子句中</li>
<li>当集函数遇到null的时候,除了count(*),都跳过空值</li>
</ul>
</li>
<li>where子句域having子句的区别：作用对象不同<ul>
<li>where子句作用域于基本表或视图，从中选择满足条件的元组</li>
<li>having短语作用于组，从中选择满足条件的组</li>
</ul>
</li>
</ul>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><ul>
<li><p>子查询不能使用order by子句</p>
</li>
<li><p>反应了SQL语言的结构化</p>
</li>
<li><p>有些嵌套查询可以用连接运算代替</p>
</li>
<li><p>应用场景：</p>
<ul>
<li>属于运算：该成员t是否属于某个select结果集合R；in谓词</li>
<li>比较运算：该成员是否比某个select即中所有成员或至少一个成员大或小；</li>
<li>逻辑运算：该成员是否能使得集合逻辑式成立；</li>
</ul>
</li>
<li><p>当子查询的返回值只有一个的时候，可以使用比较运算符将父查询和子查询连接起来</p>
</li>
</ul>
<h4 id="子查询执行方式"><a href="#子查询执行方式" class="headerlink" title="子查询执行方式"></a>子查询执行方式</h4><ul>
<li>非相关子查询的执行顺序：<ul>
<li>首先执行子查询</li>
<li>父查询设计的所有元组都与子查询的查询结果进行比较，以确定查询结果集合</li>
</ul>
</li>
<li>相关子查询的执行顺序<ul>
<li>首先选取夫查询表中的一个元组，内部的子查询利用此元组中相关的属性值进行查询</li>
<li>然后夫查询根据子查询返回的结果判断此行是否满足查询条件，如果满足条件，则把该行放入父查询结果集合中</li>
<li>重复执行以上，指导处理完夫查询表中的所有元组</li>
</ul>
</li>
<li>非相关子查询只执行一次；而相关子查询的执行次数是由夫查询表的行数决定的</li>
</ul>
<h4 id="带有exists谓词的子查询"><a href="#带有exists谓词的子查询" class="headerlink" title="带有exists谓词的子查询"></a>带有exists谓词的子查询</h4><p>最重要的就是掌握双否表肯定</p>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><ul>
<li>并操作union</li>
<li>交操作intersect</li>
<li>差操作except</li>
</ul>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="插入元组"><a href="#插入元组" class="headerlink" title="插入元组"></a>插入元组</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 基本表[(列名[,列名]...)]<span class="keyword">values</span>(元组值);</span><br></pre></td></tr></table></figure>
<p>作用：将一条元组值插入到表中</p>
<h4 id="查询结果的插入"><a href="#查询结果的插入" class="headerlink" title="查询结果的插入"></a>查询结果的插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>基本表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名表<span class="operator">&gt;</span>)] 子查询;</span><br></pre></td></tr></table></figure>
<p>作用：将子查询返回的结果数据插入到表中。查询语句的目标列必须与into子句匹配</p>
<p>RDBMS在执行插入&#x2F;更新语句时回检查所插元组是否破坏表上已定义的完整性规则，包括实体、参照和用户定义的完整性</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure>
<p>作用:从表中删除符合where子句中删除条件的元组;若where子句缺省,啧阐述表中所有元组</p>
<ul>
<li>不带条件的delete语句和drop table语句的区别<ul>
<li>drop table语句删除表和表中的所有数据</li>
<li>delete语句指删除表中的数据,表仍然保留</li>
</ul>
</li>
</ul>
<p>带子查询的删除语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span> (</span><br><span class="line">  <span class="keyword">select</span> sno</span><br><span class="line">  <span class="keyword">from</span> student</span><br><span class="line">  <span class="keyword">where</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="operator">&lt;</span>基本表名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">set</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span>值表达式[,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span>值表达式...]</span><br><span class="line">  [<span class="keyword">where</span> 条件表达式]</span><br></pre></td></tr></table></figure>
<p>作用:对表中满足where条件的远足,按set子句修改相应列的值</p>
<p>也可以带字查询,语法和上面类似</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li>视图是从一个活几个基本表(或视图)中导出的一个虚表<ul>
<li>数据库中只存放视图的定义二不存放视图的数据,这些数据仍放在原来的基表中.当基表中的数据发生变化时从视图中查出的数据也随之改变了</li>
<li>视图一经定义就可以对其进行查询,单对视图的更新操作有一定的限制</li>
</ul>
</li>
</ul>
<h3 id="视图的定义"><a href="#视图的定义" class="headerlink" title="视图的定义"></a>视图的定义</h3><h4 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名[(列名,[列名]...)]</span><br><span class="line"><span class="keyword">as</span> 子查询</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>
<ul>
<li>说明: 视图的列名为可选项,缺省时,其列名即为字查询的查询目标列.但在以下情况下,视图列名不可省略<ul>
<li>视图由多个表连接得到,在不同的表中存在同名列,需要指定列名字</li>
<li>当视图的列名为表达式或集函数的计算结果,而不是单纯的属性名时,需要制定列名</li>
<li>在字查询中,不许使用order by子句,如果需要排序,则可在视图定义后,对视图查询时再进行排序</li>
<li>如果指明了<code>with check option</code>选项,则在对视图进行更新时,所影响的元组必须满足视图定义中的where条件</li>
</ul>
</li>
<li>行列子集视图:从一个基本表中导出,只是去掉了某些行或列(保留原表的主码),这样的视图称为行列子集视图</li>
<li>多表视图:从多个基本表或视图中导出</li>
<li>带表达式的视图,即带虚拟列的视图</li>
<li>分组视图,子查询带集函数和group by分组的视图</li>
</ul>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [cascade];</span><br></pre></td></tr></table></figure>
<p>作用:从数据库中删除一个视图的定义信息,cascade表示把该视图和它导出的视图一起删除</p>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><ul>
<li>用户角度:查询视图与查询基本表相同</li>
<li>DBMS执行对视图的查询时<ul>
<li>首先进行有效性检查,检查查询设计的表、视图等是否在数据库中存在</li>
<li>如果存在,则从数据字典中取出查询设计的视图的定义</li>
<li>把定义中的子查询和用户对视图的查询结合起来,转换成等价的基本表的查询</li>
<li>然后再执行这个经过修正的查询</li>
</ul>
</li>
<li>将对视图的查询转换为对基本表的查询的过程称为视图的消解</li>
</ul>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><ul>
<li><p>视图的更新操作包括插入、修改和删除数据,语法格式同基本表的更新</p>
</li>
<li><p>因为视图是一张虚表,所以对视图的更新,最终实际上是转换成对基本表的更新</p>
</li>
<li><p>一些视图是不可更新的,因为这些视图的更新不能唯一地有意义地转换成对应基本表的更新</p>
<ul>
<li>字段由表达式或常数组哼,不允许执行insert和该字段上dupdate,但可以执行delete</li>
<li>字段由机函数组成,不允许更新</li>
<li>视图定义含有group by或distinct,不允许更新</li>
<li>有潜逃查询,且内外查询使用相同表时,不允许更新</li>
<li>定义中有多表链接时,不允许更新</li>
<li>由不允许更新的视图导出的视图,不允许更新</li>
</ul>
</li>
<li><p>视图的作用</p>
<ul>
<li>简化用户的操作</li>
<li>使用户能以多种角度看待同一数据</li>
<li>对重构数据库提供一定程度的逻辑独立性</li>
<li>是数据共享与保密的一种安全机制</li>
<li>适当的利用视图可以更清晰的查询表达</li>
</ul>
</li>
</ul>
<h1 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h1><h2 id="安全性概述"><a href="#安全性概述" class="headerlink" title="安全性概述"></a>安全性概述</h2><ul>
<li>定义:<ul>
<li>数据库的安全性是只保护数据库以防止不合法的使用所造成的数据泄漏、更改或破坏</li>
</ul>
</li>
<li>重要性<ul>
<li>数据库系统中大量数据集中存放,许多用户直接共享</li>
<li>系统的安全保护措施是否有效是数据库系统的主要性能指标之一</li>
</ul>
</li>
</ul>
<h3 id="数据库的不安全因素"><a href="#数据库的不安全因素" class="headerlink" title="数据库的不安全因素"></a>数据库的不安全因素</h3><ul>
<li>非授权用户对数据库的恶意存取和破坏<ul>
<li>安全措施:用户身份鉴别、存取控制和视图等</li>
</ul>
</li>
<li>数据库中重要或敏感数据被泄漏<ul>
<li>安全措施:审计、日志、入侵检测等</li>
</ul>
</li>
<li>安全环境的脆弱性</li>
</ul>
<h2 id="数据库安全控制技术"><a href="#数据库安全控制技术" class="headerlink" title="数据库安全控制技术"></a>数据库安全控制技术</h2><h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><ul>
<li>系统提供的最外层安全保护措施</li>
<li>系统提供一定的方式让用户标识自己的名字和身份,系统进行核实,通过鉴定后才提供系统使用权</li>
</ul>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><ul>
<li>对于获得上机权的用户还要根据系统预先定义好的外模式(视图)或用户权限进行存取控制,保证用户只能存取他有权存取的数据</li>
<li>方法<ul>
<li>定义用户权限,登记到DD中</li>
<li>合法权限检查</li>
</ul>
</li>
<li>常用存取控制方法<ul>
<li>自主存取控制(Discretionary Access Control, DAC),C2级,灵活<ul>
<li>用户或DBA定义存取权限的一种控制策略,通过SQL的grant语句和revoce语句实现</li>
<li>访问权限由两个要素组成:数据对象和操作.类型系统通过控制数据对象的访问权限防止非授权访问</li>
<li>缺点:<ul>
<li>可能存在数据的“无意泄漏”</li>
<li>DAC容易受到特洛伊木马攻击</li>
<li>原因:这种机制仅仅通过对数据的存取权限来进行安全控制,而数据本身并没无安全性标记</li>
<li>解决:对系统控制下的所有主客体实施强制存取控制策略</li>
</ul>
</li>
</ul>
</li>
<li>强制存取控制(Mandatory Access Control, MAC),B1级,严格</li>
</ul>
</li>
</ul>
<h3 id="授权与回收"><a href="#授权与回收" class="headerlink" title="授权与回收"></a>授权与回收</h3><h4 id="授权grant"><a href="#授权grant" class="headerlink" title="授权grant"></a>授权grant</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line">  [<span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]</span><br><span class="line">  <span class="keyword">to</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">  [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure>
<ul>
<li>语义:将对指定操作对象的指定操作权限授予指定用户</li>
<li>with grant option: 若指定:可以再授予;否则,不能传播</li>
<li>不允许循环授权</li>
</ul>
<h4 id="回收revoke"><a href="#回收revoke" class="headerlink" title="回收revoke"></a>回收revoke</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line">  [<span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]</span><br><span class="line">  <span class="keyword">from</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">  [cascade<span class="operator">|</span>restrict]</span><br></pre></td></tr></table></figure>
<h4 id="创建数据库模式的权限"><a href="#创建数据库模式的权限" class="headerlink" title="创建数据库模式的权限"></a>创建数据库模式的权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br><span class="line">  [<span class="keyword">with</span>][dba<span class="operator">|</span>resource<span class="operator">|</span><span class="keyword">connect</span>];</span><br></pre></td></tr></table></figure>
<h3 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h3><ul>
<li>角色:被命名的一组与数据库操作相关的权限</li>
<li>角色是权限的集合</li>
<li>可以为一组具有相同权限的用户创建一个角色,简化授权的过程</li>
</ul>
<p>角色的创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>给角色授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line">  <span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span>对象名</span><br><span class="line">  <span class="keyword">to</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]...</span><br></pre></td></tr></table></figure>
<p>将一个角色授予其他的角色或用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>角色<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="number">2</span><span class="operator">&gt;</span>]...</span><br><span class="line">  <span class="keyword">to</span> <span class="operator">&lt;</span>角色<span class="number">3</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span>]...</span><br><span class="line">  [<span class="keyword">with</span> admin option]</span><br></pre></td></tr></table></figure>
<p>角色权限的收回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line">  <span class="keyword">on</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">from</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]...</span><br></pre></td></tr></table></figure>
<h3 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h3><p>管理员管理访问控制、制定策略,用户不能直接感知或进行控制</p>
<ul>
<li>实体类别<ul>
<li>主体:系统中的活动实体,包括用户和用户的进程</li>
<li>客体:系统中的被动实体,受主体操纵的基表、索引、视图等</li>
</ul>
</li>
<li>敏感度标记(label):<ul>
<li>绝密</li>
<li>机密</li>
<li>可信</li>
<li>公开</li>
</ul>
</li>
<li>强制存取控制规则:<ul>
<li>仅当主体的许可证级别大于或等于客体的密级时,该主体才能读相应的客体</li>
<li>仅当主体的许可证级别等于或小于客体的密级时,该主体才能写相应的客体</li>
</ul>
</li>
<li>优点<ul>
<li>禁止拥有高许可证级别的主体更新低密级的数据对象,从而保证了敏感数据的可靠性</li>
<li>禁止低许可证级别的主体浏览高密级的数据,避免了敏感数据的泄漏</li>
<li>MAC对数据本身进行密级标记,无论数据如何复制,标记与数据是不可分割的整体.只有符合密级标记的要求的用户才可以操作响应数据,提高了安全性级别</li>
</ul>
</li>
<li>兼容关系<ul>
<li>安全级别之间具有篇序乡下兼容关系,较高安全性级别的安全保护措施要包含较低安全级别的所有保护措施,同时应提供更多完善的保护能力.因此实现MAC必须先实现DAC,DAC和MAC共同构成DBMS的安全机制</li>
</ul>
</li>
</ul>
<h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><ul>
<li>用户可以通过视图访问基表,也可以直接访问基表,但对安全级别要求较高的数据一般通过视图进行访问,从而避免直接访问基表中其他数据</li>
<li>对于终端用户,虽然数据库中的数据是面向全局的,但通过视图隔离他只能看到专门为他定义的视图中与自己相关的数据.其他与他无关的数据被子模式,即视图隔离或屏蔽了</li>
</ul>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><ul>
<li>审计:对用户使用系统资源情况的登记和审查<ul>
<li>审计日志:将用户对数据库的所有操作记录在上面</li>
<li>DBA可以利用审计日志,找出非法存取数据的人、时间和内容</li>
<li>C2以上安全级别的DBMS必须具有</li>
</ul>
</li>
<li>审计分类<ul>
<li>用户级审计<ul>
<li>用户对自己拥有的数据库对象上发生的操作进行审计</li>
<li>记录所有用户对这些表或视图的一切成功和(或)不成功的访问要求以及各种类型的SQL操作</li>
</ul>
</li>
<li>系统级审计<ul>
<li>DBA设置</li>
<li>监测成功或失败的登陆请求</li>
<li>监测grant和revoke操作以及其他数据库级权限下的操作</li>
</ul>
</li>
</ul>
</li>
<li>audit语句:设置审计功能</li>
<li>noaudit语句:取消审计功能</li>
</ul>
<h2 id="数据机密"><a href="#数据机密" class="headerlink" title="数据机密"></a>数据机密</h2><h1 id="第五章-数据库完完整性"><a href="#第五章-数据库完完整性" class="headerlink" title="第五章 数据库完完整性"></a>第五章 数据库完完整性</h1><ul>
<li>数据库的完整性<ul>
<li>数据的正确性和相容性<ul>
<li>正确性指数据库中数据与现实世界的实际情况是享福的</li>
<li>相容性指数据库中数据自身不存在自相矛盾的现象</li>
</ul>
</li>
</ul>
</li>
<li>完整性 VS 安全性<ul>
<li>完整性<ul>
<li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li>
<li>防范对象：不合语义、不正确的数据</li>
</ul>
</li>
<li>安全性：<ul>
<li>保护数据库防止恶意的破坏和非法的存取</li>
<li>防范对象：非法用户和非法操作</li>
</ul>
</li>
</ul>
</li>
<li>DBMS的完整性控制功能<ul>
<li>为用户提供定义完整性约束条件的机制</li>
<li>监督系统中执行的操作是否违反完整性限制条件(insert, delete, update)</li>
<li>对违反完整性约束的情况进行相应处理(拒绝执行&#x2F;级联操作)</li>
</ul>
</li>
</ul>
<h2 id="实体完整性-1"><a href="#实体完整性-1" class="headerlink" title="实体完整性"></a>实体完整性</h2><ul>
<li>实体完整性在关系模型中通过关系的主码来体现</li>
<li>有列级约束和表级约束两种，如果主码由多个列构成，只能用第二种方法定义主码</li>
<li>实体完整性的检查<ul>
<li>对基表插入数据或对主码列进行更新时，DBMS将自动对该操作进行实体完整性检查，包括<ul>
<li>主码值是否唯一，否则拒绝执行该操作</li>
<li>各主码列的值是否为空，否则拒绝执行该操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参照完整性-1"><a href="#参照完整性-1" class="headerlink" title="参照完整性"></a>参照完整性</h2><ul>
<li>参照完整性在关系模型中通过关系的外码来想体现</li>
<li>参照完整性的检查</li>
</ul>
<table>
<thead>
<tr>
<th align="left">被参照表</th>
<th align="left">参照表</th>
<th align="left">违约处理</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可能破坏参照完整性</td>
<td align="left">插入元组</td>
<td align="left">拒绝</td>
</tr>
<tr>
<td align="left">可能破坏参照完整性</td>
<td align="left">修改外码值</td>
<td align="left">拒绝</td>
</tr>
<tr>
<td align="left">删除元组</td>
<td align="left">可能破坏参照完整性</td>
<td align="left">拒绝&#x2F;级联删除&#x2F;设置为空值</td>
</tr>
<tr>
<td align="left">修改主码值</td>
<td align="left">可能破坏参照完整性</td>
<td align="left">拒绝&#x2F;级联修改&#x2F;设置为空值</td>
</tr>
</tbody></table>
<ul>
<li>在子表中插入元组<ul>
<li>仅当父表中存在与插入元组相应的元组时，系统执行在子表中插入元组的操作，否则拒绝此插入操作</li>
</ul>
</li>
<li>修改子表外码<ul>
<li>如果父表中存在待修改的值，则执行；否则不允许执行此类修改操作</li>
</ul>
</li>
<li>修改父表主码（若子表中由相关参照记录）<ul>
<li>拒绝修改：拒绝执行</li>
<li>级联修改：将子表中相关记录在外码上的值一起自动修改</li>
<li>置空修改：将子表中相关记录在外码上的值全部置为null</li>
</ul>
</li>
<li>删除父表元组（若子表中由相关参照记录）<ul>
<li>拒绝删除</li>
<li>级联删除：删除附表中元组的同时，自动删除子表中的相关元组</li>
<li>置空删除：删除附表中元组的同时，自动将子表中的相关元组的外码置空</li>
</ul>
</li>
</ul>
<p>指定在删除或修改父表时的违约处理动作：<br>在定义参照完整性约束的时候，可同时指定删除或修改时的违约处理动作，如<code>not action</code>,<code>set null</code>或<code>cascade</code>。缺省动作为<code>not action</code>。<br><code>no action</code>是据绝操作的意思哦</p>
<h2 id="用户定义的完整性约束"><a href="#用户定义的完整性约束" class="headerlink" title="用户定义的完整性约束"></a>用户定义的完整性约束</h2><ul>
<li>空值约束（列级）<ul>
<li><code>not null</code></li>
</ul>
</li>
<li>唯一性约束（列级&#x2F;表级）<ul>
<li><code>unique</code></li>
</ul>
</li>
<li>check约束（列级&#x2F;表级）<ul>
<li><code>check(&lt;条件表达式&gt;)</code></li>
<li>如果条件表达式涉及的对象只有一个，那么就可以使用列级</li>
</ul>
</li>
</ul>
<h2 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h2><ul>
<li>完整性约束与列一样是关系模式的构成元素</li>
<li>关系中的列是必须命名的，但是约束不一定要命名<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span><span class="operator">&lt;</span>约束说明<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
其中，约束说明可以是<code>primary key</code>子句，<code>foreign key</code>子句，<code>not null</code>子句，<code>unique</code>子句和<code>check</code>子句</li>
</ul>
<p>在<code>alter table</code>语句中通过约束名删除约束，也可添加新的约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">drop</span> <span class="keyword">constraint</span> C1</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> S <span class="keyword">add</span> <span class="keyword">constraint</span> C2 <span class="keyword">check</span>(Age<span class="operator">&gt;=</span><span class="number">15</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span><span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p><strong>增加新约束，数据库不会对已经在库里的数据检查一遍约束条件</strong></p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul>
<li>申明性断言：指定更具一般性约束，可涉及多表或聚集操作的交复杂的完整性约束<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="keyword">check</span>子句<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是定义在基表上的一种数据库对象，它指定：在执行对表的某些操作的时候，另一些操作也同时被执行</p>
<h3 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span></span><br><span class="line">  [before<span class="operator">|</span>after]<span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span><span class="keyword">on</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> &#123;<span class="type">row</span><span class="operator">|</span>statement&#125;</span><br><span class="line">  [<span class="keyword">when</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>]</span><br><span class="line">  <span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<ul>
<li>&lt;触发事件&gt;:可以是insert,delete,update，或者这些事件的组合，update后面可以带of&lt;触发列,…&gt;，指明只当哪些列被修改时才激活触发器。before和after表示触发器是在触发事件之前还是之后被激活</li>
<li><code>for each row</code>表示该触发器为行级触发器，触发事件没映像一条元组都将激活一次触发器</li>
<li><code>for each statement</code>表示该触发器为语句级触发器，触发事件只激活一次触发器</li>
</ul>
</li>
<li>DBMS如何执行触发器<ul>
<li>触发器被激活后，先检查&lt;触发条件&gt;，当其值为真时，&lt;触发动作体&gt;才执行；如果没有指定&lt;触发条件&gt;，则&lt;触发动作体&gt;在触发器被激活后立即执行</li>
<li>&lt;触发动作体&gt;是一段程序，如果触发器是行级触发器，则这段程序中还可以使用new和old分别引用触发事件发生前后的元组值</li>
</ul>
</li>
</ul>
<h3 id="激活触发器"><a href="#激活触发器" class="headerlink" title="激活触发器"></a>激活触发器</h3><ul>
<li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li>
<li>一个数据表上可能定义了多个触发器，同一个表上的多个触发器激活时遵循以下顺序<ul>
<li>执行该表上的before触发器</li>
<li>激活触发器的sql语句</li>
<li>执行该表上的after触发器</li>
</ul>
</li>
<li>多个触发器执行时，这些触发器按创建事件顺序依次执行</li>
<li>任意触发器的执行失败都将中止整个操作</li>
</ul>
<h3 id="触发器的撤销"><a href="#触发器的撤销" class="headerlink" title="触发器的撤销"></a>触发器的撤销</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：触发器必须是一个已创建的触发器，并且只能由具有相应权限的用户删除</p>
<p>注：触发器是与表相关联的，因此，表的撤销将引起该表上的所有触发器同时被撤销</p>
<h3 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h3><ul>
<li>强制实现由逐渐和外键所不能保证的参照完整性和数据的一致性</li>
<li>实现比check语句更复杂的约束（涉及多表）</li>
<li>找到数据修改前后表状态的差异，并基于此差异采取行动</li>
<li>级联运行修改数据库中相关表，自动触发相关操作</li>
<li>跟踪变化，禁止&#x2F;回滚不合规则的操作，防止非法修改数据</li>
<li>返回自定义的错误消息（约束做不到）</li>
<li>自动调用存储过程</li>
</ul>
<h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>一个完整的关系模式用五元组表示：<code>R(U, D, DOM, F)</code><ul>
<li>R：关系名称</li>
<li>U：一组属性</li>
<li>D：U中属性所来自的域</li>
<li>DOM：属性到域的映射</li>
<li>F：属性组U上的一组数据依赖</li>
</ul>
</li>
<li>关系模式涉及中起主要作用的是U和F,简化的关系模式为三元组<code>R&lt;U,F&gt;</code><ul>
<li>表示：仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;上的一个关系</li>
</ul>
</li>
</ul>
<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>定义：设R(U)是一个属性集U上的关系模式，$X,Y\subseteq U$,r是R(U)上的任意一个关系，如果成立<br>$$ \forall t,s \in r, if t[X]&#x3D;s[X], then y[Y]&#x3D;s[Y] $$<br>则称“X函数确定Y”或“Y函数依赖于X”，记作X-&gt;Y。X称为这个函数依赖的决定属性集。</p>
<ul>
<li>说明<ul>
<li>函数依赖不是指关系模式R的某个或某些关系实力满足的约束条件，而是指R的所有瓜西实力均要满足的约束条件</li>
<li>函数依赖是语义范畴的概念，只能根据语义来确定一个函数依赖，而不能按照其形式定义来证明一个函数依赖是否成立</li>
<li>函数依赖关系的存在于时间无关</li>
<li>属性间联系于函数依赖的对应关系<ul>
<li>1:1联系：存在函数依赖X-&gt;Y,且Y-&gt;X,即X&lt;–&gt;Y</li>
<li>1:m联系：存在函数依赖X-&gt;Y，但不存在Y-&gt;X</li>
<li>m:n联系：不存在函数依赖</li>
</ul>
</li>
</ul>
</li>
<li>平凡函数依赖与非平凡函数依赖<ul>
<li>平凡函数依赖<ul>
<li>设有关系模式R(U,F)，X,Y都是U的子集，若X-&gt;Y,$Y \subseteq X$，则称X-&gt;Y是平凡函数依赖</li>
</ul>
</li>
<li>非平凡函数依赖<ul>
<li>设有关系模式R(U,F),X,Y都是U的自己，若X-&gt;Y,$Y \subsetneq X$,则称X-&gt;Y是非平凡函数依赖</li>
</ul>
</li>
<li>说明：对于任何R，平凡函数依赖总是成立的。</li>
</ul>
</li>
<li>完全函数依赖于部分函数依赖<ul>
<li>定义：设关系模式R(U)，U是属性全集，X和Y是U的子集<ul>
<li>如果X-&gt;Y，并且对于X的任何一个真子集X’，都有X’!-&gt;Y，则称Y完全函数依赖于X，记作X-F&gt;T </li>
<li>如果对于X的某个真子集X’，有X’-&gt;Y，则称Y部分函数依赖于X，记作X-P&gt;Y</li>
</ul>
</li>
</ul>
</li>
<li>传递函数依赖<ul>
<li>定义：再关系模式R(U)中，如果X-&gt;Y,Y-&gt;Z，且$Y \subsetneq X,Y \subsetneq X, Z \subsetneq Y$,则称Z传递函数依赖于X，记作X-T&gt;Z</li>
<li>注：如果还有Y-&gt;X,即X&lt;–&gt;Y,则Y直接依赖于X</li>
</ul>
</li>
</ul>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><ul>
<li>设K为关系模式R&lt;U,F&gt;中的属性或属性组合，若K-F&gt;U，则K称为R的一个候选码。若关系模式R有多个候选码，则选定其中的一个作为主码<ul>
<li>主码：任意候选码之一</li>
<li>主属性：包含在任何一个候选码中的属性。</li>
<li>超码：若K-P&gt;U,则K称为超码</li>
</ul>
</li>
<li>关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码，也称外码</li>
<li>主码和外码一起提供了表示关系间联系的手段</li>
</ul>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul>
<li>范式：关系数据库的规范化过程中为不同程度的规范化要求设立的不同标准</li>
<li>通过模式分解将一个低级范式转换为若干个高级范式的过程陈佐规范化</li>
</ul>
<h4 id="第一范式1NF"><a href="#第一范式1NF" class="headerlink" title="第一范式1NF"></a>第一范式1NF</h4><ul>
<li>如果关系模式R，其所有的属性均为简单属性，即每个属性都是不可再分的，则称R属于第一范式，简称1NF,记作$R \in 1NF$</li>
<li>第一范式是最基本的规范形式，满足这个条件的关系称为规范化关系</li>
<li>关系DBS中，所有关系模式都必须是1NF</li>
<li>将非1NF转换为1NF的方法：<ul>
<li>去掉嵌套属性上层</li>
<li>重写行交叉处的值</li>
</ul>
</li>
<li>1NF存在的问题：数据容易，具有插入异常、删除异常、更新复杂<ul>
<li>原因：非主属性部分函数依赖于候选码</li>
</ul>
</li>
<li>解决方法（投影分解）<ul>
<li>消除非主属性对码的部分FD（函数依赖）<ul>
<li>所有完全函数依赖于码的属性组成一个关系模式</li>
<li>所有部分函数依赖于码的属性组成一个关系模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><ul>
<li>如果关系模式$R \in 1NF$，且每个非主属性都完全函数依赖于R的码，则称R属于第二范式2NF，记作$R \in 2NF$</li>
<li>即：不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性的主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。简而言之，第二范式就是属性完全依赖于主键。 </li>
<li>推论：若$R \in 1NF$，且其候选码为单个属性，则$R \in 2NF$</li>
<li>2NF存在的问题：非主属性对码的传递依赖</li>
<li>解决方法：投影分解，消去非主属性对码的传递依赖</li>
</ul>
<h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><ul>
<li>如果关系模式$R(U,F) \in 1NF$,其中不存在码X,属性组Y及非主属性Z($Z \subseteq Y$)，使得X-&gt;Y(Y !-&gt; X), Y!-&gt;Z成立，则称R属于第三范式3NF,记作$R\in 3NF$</li>
<li>3NF建立在2NF之上，要求所有的非主键列都必须直接依赖于主键，不包括任何传递依赖</li>
<li>若$R \in 3NF$，则每一非主属性既不部分依赖于码也不传递依赖于码</li>
<li>若$R \in 3NF$，则必有$R \in 2NF$</li>
<li>采用投影分解法将一个2NF的关系分解为多个3NF关系，可以在一定程度上解决原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题</li>
<li>推论1：若$R \in 2NF$,且之多存在一个非主属性，则$R \in 3NF$</li>
<li>推论2：任何二元关系模式R(A,B)必为3NF</li>
<li>说明：<ul>
<li>部分FD和传递FD是用户及操作异常的重要根源</li>
<li>3NF不存在非主属性对候选码的部分FD和传递FD</li>
<li>3NF消去了大部分冗余及操作异常</li>
<li>但并非所有的3NF都能完全消除冗余及操作异常</li>
</ul>
</li>
<li>3NF可能存在的问题：存在主属性对候选码的不良依赖</li>
</ul>
<h4 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h4><ul>
<li><p>定义：如果关系模式$R(U,F)\in 1NF$，且对于所有的非平凡函数依赖X-&gt;Y，X必包含了R的一个码，则称R属于BC范式，记作$R\in BCNF$</p>
</li>
<li><p>定理：如果$R \in BCNF$，则$R \in 3NF$</p>
</li>
<li><p>性质：</p>
<ul>
<li>所有非主属性都完全依赖于候选码</li>
<li>所有非主属性都不传递依赖于候选码</li>
<li>所有主属性都完全依赖于不包含它的候选码；（主属性不依赖于主属性）</li>
<li>所有主属性都不传递依赖于候选码</li>
</ul>
</li>
<li><p>推论：若一个关系达到了第三范式，并且它只有一个候选码，或它的每个候选码都是但属性，则该关系是BCNF</p>
</li>
<li><p>$$ BCNF\subseteq 3NF \subseteq 2NF \subseteq 1NF $$</p>
</li>
<li><p>如果一个关系DB中所有关系模式都属于3NF，则已在很大程度上消除了插入异常和删除异常，但仍然可能存在主属性对候选键的部分依赖和传递依赖</p>
</li>
<li><p>如果一个关系数据库中所有关系模式都属于BCNF，那么在函数依赖的范畴内，已经实现了模式的彻底分解，完全消除了产生插入异常和删除异常的根源，而且数据冗余也减少到极小程度</p>
</li>
</ul>
<h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><ul>
<li><p>设R(U)是一个属性集U上的一个关系模式，X,Y,Z是U上的子集，并且Z&#x3D;U-X-Y，多值依赖X-&gt;-&gt;Y成立，当且仅当</p>
<ul>
<li>对R的任一关系r，r在(X,Z)上的每个值对应一组Y的值</li>
<li>这组值仅仅决定于X而于Z值无关</li>
</ul>
</li>
<li><p>多值依赖 VS 函数依赖</p>
<ul>
<li>函数依赖是多汁依赖的特里，若X-&gt;Y,则X-&gt;-&gt;Y</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>函数依赖规定某些元组不能出现在关系中</li>
<li>多值依赖要求某种形式的其它元组必须在关系中</li>
<li>有效性与属性集的范围不同<ul>
<li>X-&gt;Y的有效性仅决定于X,Y属性集上的值</li>
<li>X-&gt;-&gt;Y不仅涉及属性组X和Y，而且涉及U中其余属性Z</li>
<li>若X-&gt;Y在R(U)上成立，则对于任何$Y’ \subseteq Y$,均有X-&gt;Y’成立</li>
<li>多值依赖X-&gt;-&gt;Y若在R(U)上成立，不能断言对于任何$Y’ \subseteqq Y$有X-&gt;-&gt;Y’成立</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h3><ul>
<li>定义：关系模式$R&lt;U,F&gt; \in 1NF$,如果对于R的每个非平凡多值依赖X-&gt;-&gt;Y($y \subsetneq X$),X都含有候选码，则$R \in 4NF$</li>
<li>含义：不允许同一表内有多对多关系</li>
<li>如果$R \in 4NF$,则$R \in BCNF$</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>3NF必定为2NF和1NF，反之不一定</li>
<li>4NF必定为BCNF,BCNF一定为3NF,反之不一定</li>
<li>3NF已在很大程度上控制了数据容易、很大程度上消去了插入和删除操作异常；但3NF分解仍不够彻底（可能存在主属性对候选码的部分fd和传递fd）</li>
<li>在fd范围内，BCNF下已完全消去了插入删除异常</li>
<li>4NF是多值依赖范畴内最高程度的规范化</li>
<li>范式并非越高约好。理论上数据库涉及一般硬规范到3NF，但实际应用中为减少连接运算，提高查询效率，不一定都达到3NF</li>
<li>适可而止（垃圾，连接运算）</li>
<li>分解不唯一</li>
</ul>
<h2 id="数据依赖的公理系统"><a href="#数据依赖的公理系统" class="headerlink" title="数据依赖的公理系统"></a>数据依赖的公理系统</h2><ul>
<li>逻辑蕴含：对于关系模式R&lt;U,F&gt;，其任何一个关系r，若函数依赖X-&gt;Y都成立（即r中任意两元组s,t,若t[X]&#x3D;s[X],则t[Y]&#x3D;s[Y]），则称函数依赖集F逻辑蕴含X-&gt;Y，或X-&gt;Y从F推导出来的，或X-&gt;Y逻辑蕴含于F</li>
<li>在关系模式R(U,F)中为F所逻辑蕴含的函数依赖的全体叫做F的闭包，记作F+</li>
<li>Armstrong公里的内容<ul>
<li>设有关系模式R(U,F)，U为属性全集，F是U上的函数依赖集，$X,Y,Z \subseteq U$。则有</li>
<li>自反律：若$Y \subseteq X \subseteq U$,则X-&gt;Y为F所蕴含（给出平凡的函数依赖）</li>
<li>增广律：若X-&gt;Y为F所蕴含，则$Z \subseteq U$,则XZ-&gt;YZ为F所蕴含</li>
<li>传递律：若X-&gt;Y及Y-&gt;Z为F所蕴含，则X-&gt;Z为F所蕴含</li>
</ul>
</li>
<li>Armstrong公理的推论<ul>
<li>合成规则：若X-&gt;Y,X-&gt;Z,则X-&gt;YZ</li>
<li>分解规则：若X-&gt;YZ,则X-&gt;Y,X-&gt;Z</li>
<li>伪传递规则：若X-&gt;Y,YW-&gt;Z,则XW-&gt;Z</li>
</ul>
</li>
<li>引理：如果Ai是关系模式R的属性，则X-&gt;A1…AN的充要条件是X-&gt;Ai均成立</li>
<li>属性闭包：设有关系模式R(U,F)，U&#x3D;{A1,…,An},$X \subseteq U$,F是U上的一个函数依赖集，则称所有用Armstrong公理从F推导处的函数依赖X-&gt;Ai中所有Ai的属性集合为属性集X关于F的闭包，记$X_{F^+}$</li>
<li>引理：函数依赖X-&gt;Y能由F根据Armstrong公理推导出来的充要条件是$Y \subseteq X_{F^+}$</li>
<li>由引理可知道，判断X-&gt;Y是否能由F根据Armstrong公理导出，可转化为：求$X_{F^+}$，判定$Y \subseteq X_{F^+}$</li>
<li>计算属性闭包的算法<ul>
<li>输入X,F,输出$X_{F^+}$</li>
<li>方法：<ul>
<li>X(0)&#x3D;$\phi$,X(1)&#x3D;X</li>
<li>如果X(0)!&#x3D;X(1),置X(0)&#x3D;X(1),否则转4</li>
<li>对于F中的每个函数依赖Y-&gt;Z，若$Y \subseteq X(0)$,置$X(1)&#x3D;X(1) \cup Z$，即将Y的右部并入X(1)中，转(2)</li>
<li>输出X(1)，即为$X_{F^+}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="函数依赖的等价和覆盖"><a href="#函数依赖的等价和覆盖" class="headerlink" title="函数依赖的等价和覆盖"></a>函数依赖的等价和覆盖</h3><ul>
<li>等价：若F和G是R的两个函数依赖集，如果$F^+&#x3D;G^+$，则称F等价于G</li>
<li>覆盖：若F和G是两个等价的函数依赖集$F^+&#x3D;G^+$,则称F覆盖G，同时G也覆盖F</li>
<li>引理：设F和G是R的两个函数依赖集，则F和G等价的充分必要条件是$F \subseteq G^+$且$G \subseteq F^+$</li>
</ul>
<h3 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h3><ul>
<li>若函数依赖F满足下列条件，则F为一个最小函数依赖集记作$F_m$<ul>
<li>F中每个函数依赖的右部都是单属性</li>
<li>对于F中的任一函数依赖X-&gt;A，F-{X-&gt;A}与F是不等价的（即F中不存在多余的依赖）</li>
<li>对于F中的任一函数依赖X-&gt;A，不存在X的子集Z，使得F与$(F-{X-&gt;A}) \cup {Z-&gt;A}$等价（即左部无多余属性）</li>
</ul>
</li>
<li>F的最小依赖集求解算法<ul>
<li>用分解规则将F中所有函数依赖的右部分解为单属性的函数依赖，去掉重复依赖</li>
<li>去掉多余依赖：对每个依赖X-&gt;Y，令G&#x3D;F-{X-&gt;Y},求$X_{G^+}$,若$Y \subseteq X_{G^+}$,则X-&gt;Y为多余依赖，将其从F中去掉</li>
<li>去掉依赖左部的多余属性：对每个左部为多属性的依赖，如果X-&gt;A，设X&#x3D;B1…BM,逐一考察Bi，若$A \in (X-B_i)_{F^+}$,则Bi是多余属性，用X-Bi代替X</li>
<li>重复2，3，直到Fm不再改变</li>
</ul>
</li>
<li>注：F的最小函数依赖集不是唯一的，与计算顺序有关</li>
</ul>
<h2 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h2><ul>
<li>设由关系模式R(U,F)，称$\rho &#x3D; {R_1(U_1,F_1),…,R_n(U_n,F_n)}$为R的一个分解<ul>
<li>$U&#x3D;U_1 \cup U2 \cup … \cup U_n$</li>
<li>$U_i$与$U_j$可以相交，但不允许$U_i \subseteq U_j$</li>
<li>$F_i$是F在$U_i$上的投影（也可记作$\Pi R_i (F)$</li>
</ul>
</li>
<li>函数依赖集合${X\rightarrow Y|X \rightarrow Y \in F^+ &amp; XY \subseteq U_i}$的一个覆盖$F_i$称为F在属性集$$U-i$上的投影</li>
<li>分解的目标<ul>
<li>达到更高级范式</li>
<li>分解后数据可以还原</li>
<li>分解后属性间的依赖关系保持不变</li>
</ul>
</li>
</ul>
<h3 id="分解的正确性标准"><a href="#分解的正确性标准" class="headerlink" title="分解的正确性标准"></a>分解的正确性标准</h3><ul>
<li>无损连接性:分解所得到的各个关系模式经过自然链接可以还原成被分解的关系模式,既不增加原来没有的元组也不丢失原有的元组</li>
<li>依赖保持性:分解所得到的哥哥关系模式上的函数依赖的集合与被分解关系模式原油的函数依赖集等价,没有被丢失的现象</li>
</ul>
<h3 id="分解的无损连接性和保持函数依赖性"><a href="#分解的无损连接性和保持函数依赖性" class="headerlink" title="分解的无损连接性和保持函数依赖性"></a>分解的无损连接性和保持函数依赖性</h3><ul>
<li>任何关系模式R(U,F),$\rho&#x3D;{R_1,…,R_n}$是R的一个分解.若对R的任意关系r都有<br>$$ \rho &#x3D; \Pi _{R_1}(r) ⋈ \Pi _{R_2}(r) … ⋈ \Pi _{R_n}(r) $$<br>则称分解$\rho$是一个无损分解</li>
<li>即:无损分解可通过自然连接运算还原</li>
<li>定义:任给定R(U,F),$\rho&#x3D;{R_1,…,R_n}$是R的一个分解,若<br>$$F \leftrightarrow \Pi _{R_1}(F_1) \cup \Pi _{R_2}(F_2)\cup … \cup \Pi _{R_n}(F_n)$$<br>,则称$\rho$具有函数依赖保持性</li>
</ul>
<h4 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h4><ul>
<li>算法:判定一个分解的无损连接性<ul>
<li>输入:$R(A_1,…,A_n),F,\rho&#x3D;{R_1,…,R_k},F&#x3D;{FD_1,…,FD_{\rho}}$,设$FD_i$为$X_i \rightarrow A_i$</li>
<li>输出:分解$\rho$是否具有无损连接性</li>
<li>步骤:<ul>
<li>建立k*n的矩阵S,列j对应属性Aj,行i对应分解中的一个关系模式Ri  若属性Aj属于Ui,啧在j列i行出填写aj,否则填写bij</li>
<li>逐个检查F中的每个函数依赖,利用fd数据间的等值关系,修改表中元素</li>
<li>如果S中存在一行全为a类符号,啧$\rho$具有无损连接性,否则不具有</li>
</ul>
</li>
</ul>
</li>
<li>判断分解无损连接性的简单算法<ul>
<li>定理:设R(U,F),$\rho&#x3D;{R_1,R_2}$是R的一个分解,F是R上的函数依赖集,$\rho$具有无损连接性的充要条件是<br>$$ (R_1 \cap R_2) \rightarrow (R_1-R_2) \in F^+ \quad or \quad (R_1 \cap R_2 ) \rightarrow (R_2 - R_1) \in F^+ $$</li>
</ul>
</li>
</ul>
<h4 id="依赖保持性"><a href="#依赖保持性" class="headerlink" title="依赖保持性"></a>依赖保持性</h4><ul>
<li>设R(U,F),$\rho&#x3D;{R_1(U_1,F_1),…,R_k(U_k,F_k)}$是R的一个分解,若$F^+&#x3D;(F_1 \cap … \cap F_k)^+$,则称$\rho$具有函数依赖保持性</li>
</ul>
<h3 id="模式分解算法"><a href="#模式分解算法" class="headerlink" title="模式分解算法"></a>模式分解算法</h3><ul>
<li><p>要求分解保持函数依赖,模式分离总可以达到3NF, 不一定能达到BCNF</p>
</li>
<li><p>要求分解既保持函数依赖又具有无损连接性,可以达到3NF,不一定能达到BCNF</p>
</li>
<li><p>要求分解具有无损连接性,一定可以达到4NF</p>
</li>
<li><p>算法(合成法)达到3NF且保持函数依赖的分解算法</p>
<ul>
<li>输入:给定关系模式R&lt;U,F&gt;</li>
<li>输出:$\rho&#x3D;{R_1,…,R_k},R_i \in 3NF, i&#x3D;1,…,k$</li>
<li>步骤:<ul>
<li>求R的最小函数依赖集F’</li>
<li>找出不在F’中出现的属性$U_0$,将他们构成一个关系模式$R_0&lt;U_0,F_0&gt;$,并从U中去掉它们(剩余属性仍记为U)</li>
<li>若有X-&gt;A,且AX&#x3D;U,则$\rho&#x3D;{R}$,算法终止</li>
<li>否则,对于F’中的每个X-&gt;A,构成一个关系模式XA.如果F’中有(左部相同)A-&gt;A1,X-&gt;A2,…,X-&gt;An,则可以用XA1…An代替掉n个模式XA1,…,XAn,$U_i&#x3D;{XA_1…A_n}$;如果发现某个$U_i \subseteq U_j$,则应将$U_i$去掉</li>
<li>$$ \rho &#x3D; {R_1&lt;U_1,F_1&gt;,…,R_k&lt;U_k,F_k&gt;} \cup R_0&lt;U_0,F_0&gt; $$</li>
</ul>
</li>
</ul>
</li>
<li><p>算法：达到3NF既保持函数依赖又无损连接的分解</p>
<ul>
<li>设$\rho&#x3D;{R_1&lt;U_1,F_1&gt;,…,R_k&lt;U_k,F_k&gt;}$是R&lt;U,F&gt;的一个保持函数依赖的3NF分解（由上面一个算法获得）</li>
<li>设X为R&lt;U,F&gt;的码，<ul>
<li>若有某个$U_i, X \subseteq U_i$，则$\rho$即为所求</li>
<li>否则令$\tau&#x3D;\rho \cup {R^*&lt;X,F_x&gt;}$,$\tau$即为所求</li>
<li>如果发现某个$U_i \subseteq X$,则应将$U_i$去掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><h2 id="数据库设计的基本任务"><a href="#数据库设计的基本任务" class="headerlink" title="数据库设计的基本任务"></a>数据库设计的基本任务</h2><ul>
<li>概述<ul>
<li>数据库设计是指对于一个给定的应用环境，构造优化的数据库模式，建立数据库及其应用系统，使之能够有效的存储和管理数据，满足用户的应用需求（包括信息要求和处理要求）</li>
<li>数据库设计通常使在已有硬件和OS平台上，利用一个通用的DBMS来建立能够实现系统目标的数据库</li>
</ul>
</li>
<li>数据库设计的内容<ul>
<li>数据库的结构设计（静态）<ul>
<li>根据给定的应用环境，进行数据库的模式&#x2F;子模式的设计</li>
<li>包括数据库的概念设计、逻辑设计和物理设计</li>
<li>数据库模式是各个应用程序共享的结构，是静态的、稳定的，一经形成后通常情况下是不容易改变的。</li>
</ul>
</li>
<li>数据库的行为设计（动态）<ul>
<li>确定数据库用户的行为和动作。而在数据库系统中，用户的行为和动作指用户对数据库的操作，这些要通过应用程序来实现，所以数据库的行为设计就是应用程序的设计。</li>
<li>用户的行为总是使数据库的内容发生变化，所以行为设计是动态的，行为设计又被称为动态模型设计。</li>
</ul>
</li>
</ul>
</li>
<li>数据库设计的特点<ul>
<li>结构设计与行为设计相结合<ul>
<li>面向数据的设计方法（以信息需求为主）</li>
<li>面向过程的设计方法（以处理需求为主）</li>
</ul>
</li>
<li>分步进行<ul>
<li>数据库设计分为多个阶段</li>
<li>前一阶段的设计结果作为后一阶段设计的依据</li>
<li>后一阶段也可向前面的设计阶段反馈其要求</li>
</ul>
</li>
<li>反复性</li>
<li>多解</li>
</ul>
</li>
<li>数据库设计方法<ol>
<li>直观设计（手工凑）</li>
<li>规范设计法</li>
<li>计算机辅助设计法</li>
<li>自动化设计法</li>
</ol>
</li>
<li>数据库设计的步骤<ul>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理设计</li>
<li>数据库实施</li>
<li>数据库运行与维护<ul>
<li>需求分析和概念设计独立于任何数据库管理系统</li>
<li>逻辑设计和物理设计与选用的DBMS密切相关</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>需求分析的任务<ul>
<li>调查的重点<ul>
<li>信息要求</li>
<li>处理要求</li>
<li>安全与完整性要求</li>
</ul>
</li>
</ul>
</li>
<li>需求分析的方法<ul>
<li>自顶向下的分析方法，简称SA方法，是最简单使用的方法<ul>
<li>从最上层的系统组织机构入手</li>
<li>采用逐层分解的方式分解系统</li>
<li>用数据流图Data Flow Diagram, DFD 和 数据字典Data Dictionary, DD 描述系统</li>
</ul>
</li>
</ul>
</li>
<li>需求分析过程<ol>
<li>首先把任何一个系统都抽象为<img src="/../img/HUST_CS_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1.png" alt="需求分析系统抽象"></li>
<li>分解处理功能和数据：<ul>
<li>将处理功能和具体内容分解为若干子功能</li>
<li>处理功能逐步分解同时，逐级分解所用数据，形成若干层次的数据流图DFD </li>
<li>表达方法：<ul>
<li>处理逻辑：用判定表或判定树来描述</li>
<li>数据：用数据字典DD描述</li>
</ul>
</li>
</ul>
</li>
<li>将分析结果再次提交给用户，获得认可</li>
</ol>
</li>
<li>数据字典<ul>
<li>数据字典是对系统中数据的详细描述，是各类数据结构和属性的清单。与数据流图互为注释</li>
<li>数据字典贯穿于数据库需求分析直到数据库运行的全过程，在不同阶段其内容和用途各有区别</li>
<li>在需求分析阶段，包含以下五部分<ol>
<li>数据项：不可再分的数据单位<ul>
<li>数据项是数据的最小单位</li>
<li>包括{数据项名、含义说明、别名、类型、长度、取值范围、与其它数据项的关系等}。</li>
<li>其中，取值范围、与其它数据项的关系：定义了完整性约束条件，是设计数据检验共嗯那个的依据。</li>
</ul>
</li>
<li>数据结构：反应了数据之间的组合关系<ul>
<li>一个数据结构可以由若干个数据项组成，也可以由若干个数据项和数据结构混合组成</li>
<li>内容包括：{数据结构名、含义说明，组成:{数据项或数据结构}}</li>
</ul>
</li>
<li>数据流：表示某一处理过程中数据在系统内传输的路径<ul>
<li>内容包括：{数据流名、说明、流出过程、流入过程、组成：{数据项或数据结构},平均流量、高峰值}</li>
<li>其中，流出过程说明该数据流由什么过程而来，流入过程说明该数据流到什么过程</li>
</ul>
</li>
<li>数据存储：数据的存放场所 <ul>
<li>也是数据流的来源和去向之一。</li>
<li>包括：{数据存储名，说明，输入数据流，输出数据流，组成:{数据项或数据结构},数据量，存取频度，存取方式。存取方法：批处理&#x2F;联机处理；检索&#x2F;更新}</li>
</ul>
</li>
<li>处理过程：具体处理逻辑<ul>
<li>处理逻辑通常用判定表或判定树来描述</li>
<li>处理过程包括{处理过程名，说明，输入：{数据流},输出：{数据流},处理:{简要说明}} </li>
<li>其中，简要说明：说明处理过程的功能及处理要求</li>
<li>功能是指该处理过程用来做什么（不是怎么做），处理要求指该处理频度要求，如单位时间里处理多少事务、多少数据量、响应时间要求等，这些处理要求是后面物理设计的输入及性能评价的标准。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>数据流图DFD<img src="/../img/HUST_CS_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="数据流图DFD"></li>
</ul>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><p>概念设计就是将需求分析得到的用户需求抽象为信息结构，即概念模型</p>
<ul>
<li><p>描述工具：E-R图</p>
</li>
<li><p>特征：独立于硬件，也独立于软件</p>
</li>
<li><p>E-R图</p>
<ul>
<li>E-R数据模型提供了实体、属性和联系三个主要的抽象概念</li>
<li>E-R数据模式：用E-R数据模型对一个系统的模拟</li>
<li>E-R图： <ul>
<li>矩形：实体集</li>
<li>椭圆：属性</li>
<li>菱形：联系集</li>
<li>线段：将属性连接到实体集或将实体集联系到联系集，无向边上标明联系的类型(1:1,1:n,m:n)</li>
</ul>
</li>
<li>实体与属性<ul>
<li>实体：客观存在并可相互区分的事物；一类实体具有相同或相似的特性</li>
<li>属性：实体所具有的某一方面的特性<ul>
<li>单一属性和复合属性<ul>
<li>在关系模型中，复合属性一定要转化为单一属性(1NF)</li>
</ul>
</li>
<li>单值属性和多值属性<ul>
<li>关系模型中，多值属性一定要转化为单值属性(1NF)</li>
</ul>
</li>
<li>可空值属性和非空值属性</li>
<li>导出属性：由其它属性计算而得</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>概念模型设计的方法和步骤</p>
<ol>
<li>概念结构设计的方法<ol>
<li>自顶向下：先定义全局框架，再逐步细化  –&gt; 常用需求分析</li>
<li>自底向上：先定义局部E-R图，然后将它们集成，得到全局E-R模型  –&gt; 常设计概念结构</li>
<li>逐步扩张：先定义核心概念E-R模型，然后以滚雪球的方式逐步生成其它概念结构E-R模型</li>
<li>混合策略：自顶向下和自底向上结合的方法</li>
</ol>
</li>
<li>步骤<ol>
<li>数据抽象和局部设计：利用抽象机制对需求分析阶段收集的数据进行分类、组织形成实体、实体的属性，标识实体的码，确定实体之间的联系类型，设计分E-R图<ul>
<li>设计分E-R图：选择局部应用，确定范围原则：<ul>
<li>相对独立</li>
<li>内部联系较紧密</li>
<li>与外部联系相对较少</li>
</ul>
</li>
<li>逐步设计分E-R图：利用抽象机制形成实体、属性，确定联系等。 </li>
<li>划分实体和属性的准则：<ul>
<li>实体具有描述信息，而属性没有。属性必须是不可分的，不能包含其它属性。可再分者为实体。</li>
<li>联系只能发生在实体之间。</li>
<li>~一般情况下，凡能作为属性对待的，应尽量作为属性，以简化E-R图的处理</li>
</ul>
</li>
</ul>
</li>
<li>集成局部设计，生成全局概念结构<ul>
<li>集成的方式：<ul>
<li>多元集成法：一次性将多个局部E-R图合并为一个全局E-R图（复杂）</li>
<li>二元集成法：首先集成两个重要的局部视图，以后用累加的方法逐步将一个新的视图集成进来。</li>
</ul>
</li>
<li>无论使用哪一种方法，集成均分为两个步骤：<ol>
<li>合并：消除局部E-R图之间的冲突，生成初步E-R图</li>
<li>优化：消除不必要的冗余，生成基本E-R图</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>全局ER模型设计</p>
<ul>
<li>E-R图中的冲突有三种：属性冲突、命名冲突和结构冲突</li>
<li>属性冲突：<ul>
<li>属性值冲突：类型、取值范围或取值集合不同</li>
</ul>
</li>
<li>命名冲突：<ul>
<li>命名不一致可能发生在实体名、属性名或联系名之间，其中属性的命名冲突更常见</li>
</ul>
</li>
<li>结构冲突：同一对象在不同应用中有不同的抽象，可能为实体，也可能为属性。<ul>
<li>解决方法：统一抽象级别</li>
<li>同一实体在不同应用中属性组成不同，可能是属性个数或属性次序不同。解决办法：取局部E-R图中的同名实体属性的并集，然后再适当调整属性的次序</li>
<li>同一联系在不同应用中呈现不同的类型。解决办法：根据应用予以对实体联系的类型进行综合调整。</li>
</ul>
</li>
<li>消除不必要的冗余，生成基本E-R图<ul>
<li>冗余包括冗余的数据和冗余的联系<ul>
<li>冗余的数据是指可由基本的数据导出的数据</li>
<li>冗余的联系是由其它的联系导出的联系</li>
</ul>
</li>
<li>消除了冗余的初步E-R图称为基本E-R图</li>
<li>通常采用分析的方法消除冗余。数据字典是分析冗余数据的依据，还可以通过是数据流图分析出冗余的联系。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><ul>
<li>逻辑设计的任务<ul>
<li>将概念结构转换成特定的DBMS所支持的数据模型</li>
<li>进入“实现设计”阶段，需考虑具体DBMS性能，具体数据模型特点</li>
<li>关系数据库的逻辑设计问题：E-R图如何向关系模型进行转换</li>
</ul>
</li>
<li>E-R图向关系模式的转换<ol>
<li>转换原则<ol>
<li>一个实体型转化为一个关系模式<ul>
<li>关系属性&#x3D;实体的属性</li>
<li>关系的码&#x3D;实体的码</li>
</ul>
</li>
<li>联系转换方式1：<ol>
<li>联系为1：1，联系实体可以消失，每个实体的键都是关系的候选键</li>
<li>联系为1：n，联系实体可消化到”m”方中去，n端实体的键是关系的键</li>
<li>联系为n:m或多元联系，联系实体转化为一个关系，各实体键的组合是关系的键</li>
</ol>
</li>
<li>联系的转换方式2：一个联系转换为一个关系模式，与该联系相连的各实体的键以及联系的属性均转换为该关系的属性<ol>
<li>联系为1:1，则每个实体键都是关系的候选键</li>
<li>联系为1:n，则n端实体的键是关系的键</li>
<li>联系为n:m，则各实体键的组合是关系的键</li>
</ol>
</li>
<li>具有相同码的关系模式可以合并</li>
</ol>
</li>
</ol>
</li>
<li>数据模型的优化<ul>
<li>数据库逻辑设计的结果不是唯一的，得到初步数据模型后，还应适当修改、调整数据模型的结构，以进一步提高数据库应用系统的性能</li>
<li>关系数据模型的优化通常以规范化理论为指导</li>
<li>优化方法为：<ul>
<li>确定数据依赖</li>
<li>消除冗余联系</li>
<li>确定所属范式级别</li>
<li>检验生成的模式是否合适应用环境实施规范化处理，是否需要对某些模式进行合并或分解</li>
</ul>
</li>
<li>并不是规范化程度越高的关系就越优</li>
<li>优化：<ul>
<li>确定函数依赖</li>
<li>得到函数依赖集合FL</li>
<li>求FL的最小覆盖GL，差集为D＝FL-GL</li>
<li>逐一考察D中的函数依赖，确定是否是冗余的联系，如果是，就把它去掉</li>
</ul>
</li>
<li>对关系模式进行必要分解，提高数据操作效率和存储空间利用率<ul>
<li>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系<ul>
<li>经常进行大量数据的分类条件查询的关系，可进行水平分解，可以减少应用系统每次查询需要访问的记录数，提高查询性能</li>
<li>适用范围：20％的常用数据分解出来作为子关系　＆ 并发事务经常存取不相交的数据：分解为每个事务存取的数据对应一个关系</li>
</ul>
</li>
<li>垂直分解：把关系模式的属性分解为若干字集合，形成若干子关系模式<ul>
<li>原则：把经常一起使用的属性分解出来，形成一个子关系模式</li>
<li>有点：提高某些事务的效率</li>
<li>缺点：由可能使另一些事务不得不执行连接操作，降低了效率</li>
<li>衡量标准：分解后的总效率是否得到提高？还要保证分解后的关系具有无损链接性和函数依赖保持性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设计用户子模式</li>
</ul>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><ul>
<li>对于给定的逻辑数据模型，选取一个最适合应用环境的物理结构的过程，称为数据库物理设计</li>
<li>任务：以逻辑设计的结果为输入，结合具体DBMS的特点与存储设备特性进行设计，选定数据库在物理设备上的存储结构和存取方法</li>
<li>两步：<ul>
<li>确定物理结构：在关系数据库中主要指存取方法和存储结构</li>
<li>评价物理结构：评价的重点是时间和空间效率、维护代价和各种用户 要求进行权衡</li>
</ul>
</li>
<li>数据库物理设计的内容和方法<ul>
<li>准备工作：分析所需要的参数<ul>
<li>数据查询事务：关系、查询条件所涉及的属性、连接条件所涉及的属性、查询投影属性</li>
<li>数据更新事务：关系、更新条件所涉及所有属性，每个事务的频率和性能要求</li>
</ul>
</li>
<li>关系模式存取方法选择<ul>
<li>索引：经典存取方法 - B+树索引</li>
<li>聚簇Cluster</li>
<li>HASH方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关系模式存取方法"><a href="#关系模式存取方法" class="headerlink" title="关系模式存取方法"></a>关系模式存取方法</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li>索引是根据某些属性的值建立的值与对应记录的存储位置间的映射关系表，它可以提供对数据的快速访问</li>
<li>选择索引存取方法的一般规则：<ul>
<li>如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）</li>
<li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li>
<li>如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引</li>
</ul>
</li>
<li>关系上定义的索引数过多会带来较多的额外开销<ul>
<li>维护索引的开销</li>
<li>查找索引的开销</li>
</ul>
</li>
</ul>
<h4 id="聚簇"><a href="#聚簇" class="headerlink" title="聚簇"></a>聚簇</h4><ul>
<li>聚簇：为提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块称为聚簇。</li>
<li>聚簇有两个作用：<ul>
<li>聚簇码相同的元组集中在一起，因而聚簇值不必在每个元组中重复，只要在一组中存储1次即可，因此可以节省存储空间</li>
<li>聚簇功能可以大大提高按聚簇进行查询的效率</li>
</ul>
</li>
<li>设计候选聚簇：<ul>
<li>对经常在一起进行连接操作的关系可以建立聚簇</li>
<li>如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可以建立聚簇</li>
<li>如果一个关系的一个（或一组）属性上的值重复率很高，则此单个关系可建立聚簇，即对应每个聚簇码值的平均组数不太少。太少则聚簇效果不明显</li>
</ul>
</li>
<li>优化聚簇设计<ul>
<li>从聚簇中删除经常进行全表扫描的关系</li>
<li>从聚簇中删除更新操作远多于连接操作的关系</li>
<li>不同的聚簇中可能包含相同的关系，一个关系可以在某一个聚簇中，但不能同时加入多个聚簇</li>
<li>从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小</li>
</ul>
</li>
<li>适用范围：<ul>
<li>既适用于单个关系独立聚簇，也适用于多个关系组合聚簇</li>
<li>当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其它访问很少或者是次要的时候，可以使用聚簇<ul>
<li>尤其是当SQL语句中包含有聚簇码有关的order by, group by, union, distinct等子句或短语时，使用聚簇特别有利，可以省去对结果集进行排序操作。</li>
</ul>
</li>
</ul>
</li>
<li>局限性：<ul>
<li>聚簇只能提高某些特定应用的性能</li>
<li>建立与维护聚簇的开销很大<ul>
<li>对已有关系建立聚簇，将导致关系中元组移动其物理存储位置，并使此关系上原有的索引无效，必须重建</li>
<li>当一个元组的聚簇码改变时，该元组的存储位置也要做相应移动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HASH存取"><a href="#HASH存取" class="headerlink" title="HASH存取"></a>HASH存取</h4><ul>
<li>规则：<ul>
<li>当一个关系满足下面两个条件时候，可以选择hash存取方法:<ul>
<li>该关系的属性主要出现在等值连接条件中或主要出现在相等比较选择条件中</li>
<li>关系的大小可以预知，而且不变</li>
<li>或 该关系大小动态改变，但所选用的DBMS提供了动态hash存取方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="确定数据库存储结构"><a href="#确定数据库存储结构" class="headerlink" title="确定数据库存储结构"></a>确定数据库存储结构</h3><ul>
<li>确定数据的存放位置<ul>
<li>为了提高系统性能，应该根据应用情况将数据的易变部分、稳定部分、经常存取部分和存取频率较低部分分开存放</li>
</ul>
</li>
<li>确定系统配置</li>
</ul>
<h3 id="评价物理结构"><a href="#评价物理结构" class="headerlink" title="评价物理结构"></a>评价物理结构</h3><ul>
<li>存储空间</li>
<li>存取时间</li>
<li>维护代价</li>
</ul>
<h1 id="第八章-关系数据库引擎基础"><a href="#第八章-关系数据库引擎基础" class="headerlink" title="第八章 关系数据库引擎基础"></a>第八章 关系数据库引擎基础</h1><h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><h3 id="数据存储概述"><a href="#数据存储概述" class="headerlink" title="数据存储概述"></a>数据存储概述</h3><p>面向内存 VS 面向磁盘</p>
<ul>
<li>数据库存储管理目标<ul>
<li>允许DBMS管理可超过内存大小的数据库</li>
<li>由于读写磁盘代价很高，存储管理要能够避免大的延时和性能下降</li>
<li>由于磁盘随机访问比顺序访问慢很多，DBMS希望能最大化顺序访问</li>
</ul>
</li>
<li>磁盘块访问的优化<ul>
<li>缓冲</li>
<li>预读取</li>
<li>调度</li>
<li>文件组织</li>
<li>非易失写缓冲区</li>
<li>日志磁盘</li>
</ul>
</li>
<li>面向磁盘的DBMS<ul>
<li>特征：<ul>
<li>数据库文件存储在磁盘上，数据被组织成”页“，第一页是目录页</li>
<li>缓冲池管理和磁盘的内存间数据交换：磁盘I&#x2F;O对性能影响巨大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库存储结构"><a href="#数据库存储结构" class="headerlink" title="数据库存储结构"></a>数据库存储结构</h3><ul>
<li>文件存储<ul>
<li>DBMS通常按一定的自有、专有格式组织并将数据库存储在一个或多个磁盘文件中。OS并不知晓这些文件的组织形式和内容。</li>
<li>DBMS的存储管理器：负责数据库文件的管理，将文件组织为”页“的集合，追踪页面数据的读写操作，追踪可用的存储空间</li>
</ul>
</li>
<li>页设计<ul>
<li>数据库的页是一个固定大小的数据块</li>
<li>页可以容纳<ul>
<li>不同类型数据：元组、元数据、索引、日志记录等</li>
<li>数据一般不能混合存放，即一个页只存放一类信息（比如元组）。</li>
<li>一些DBMS要求页面是“自包含”的</li>
</ul>
</li>
<li>页ID：每个页具备唯一ID<ul>
<li>当数据库只有单文件时，页面ID可以就是文件中的偏移地址</li>
<li>当有多个文件时，大部分DBMS会有个间接层来映射页面ID到文件的路径和偏移地址，系统访问页面号时，存储管理器将其转换为文件路径和偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>页的堆文件组织方式<ul>
<li>关系是记录的集合，这些记录在数据库文件中可以有3中组织方式<ul>
<li>堆文件组织</li>
<li>顺序文件组织</li>
<li>散列文件组织</li>
</ul>
</li>
<li>Heap文件是一个无序的page集合，其中的元组可按随机顺序存放<ul>
<li>支持page的创建、读、写和删除操作</li>
<li>支持遍历所有pages的操作</li>
</ul>
</li>
<li>堆文件的2种表示方式<ul>
<li>链表<ul>
<li>以链表的形式将文件中的空闲页和数据页分别勾连起来</li>
<li>堆文件头部设立一个header page,并存放俩个指针，分别指向<ul>
<li>空页列表头部</li>
<li>数据页列表头部</li>
</ul>
</li>
<li>每个page均记录当前空闲的空槽slot</li>
</ul>
</li>
<li>页目录<ul>
<li>维护一种特殊的页面（页目录），用于记录所有的数据页的存放位置</li>
<li>该目录页同时记录每个页面的空槽信息</li>
<li>页目录将页面的状态信息集中u村南方在一起，可提高查找特定页面的速度</li>
<li>DBMS必须保持目录页于所有页的&lt;page_id, relative_offset, free_space_size&gt;同步</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>页的组织结构<ul>
<li>页头：包含有关页内容的元数据信息<ul>
<li>页大小 校验 DBMS版本 事务可见性 压缩信息</li>
<li>有些系统要求页面是自包含的</li>
</ul>
</li>
<li>数据区：存放数据的区域，其存放方式：<ul>
<li>面向元组型<ul>
<li>strawman idea<ul>
<li>记录页内的元组数，类似数组的方式进行存储</li>
<li>每次添加的元组放在已有元组的后面</li>
<li>存在问题：<ul>
<li>删除元组时会产生碎片</li>
<li>变长元组可能产生其它更多问题，比如元组的查询开销</li>
</ul>
</li>
</ul>
</li>
<li>槽页：slot数组将槽位映射到元组开始的位置的偏移量<ul>
<li>Header记录已经占用的槽位 和 最后一次使用的槽的起始位置偏移</li>
<li>元组：在页内倒序存放</li>
<li>元组在内部的唯一标识符：page_id+offset&#x2F;flot，页可包含文件位置信息</li>
<li>定长和变长元组都可处理</li>
</ul>
</li>
<li>元组设计<ul>
<li>一个元组在页中本质上是一个“字节序列”</li>
<li>DBMS负责将这些字节解释为各个属性的类型和值</li>
<li>记录包括：记录头、记录数据</li>
<li>tuple header:每个元组有一个前缀为header的元数据<ul>
<li>页中无需存放关系模式信息，专门的catalog page可有效减少重复信息</li>
</ul>
</li>
<li>tuple data:实际数据，基本上按属性顺序存放</li>
<li>定长记录：全部由定长字段组成<ul>
<li>定长记录的插入和删除容易实现</li>
<li>注意内存对齐问题</li>
</ul>
</li>
<li>变长记录：允许记录中存在一个或多个变长字段。变长字段在记录中的偏移位置不确定<ul>
<li>将所有定长字段放在边长字段之前，记录头增加：记录长度+非第一个变长字段的offset</li>
<li>保持记录定长，变长部分放在另一个溢出页</li>
</ul>
</li>
<li>物理上非规范化元组设计：（预连接）将相关的元组存放在一个页或相邻页中<ul>
<li>可以有效减少相应查询的I&#x2F;O次数</li>
<li>也可能带来额外的数据维护开销</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>日志结构型<ul>
<li>DBMS不存储元组，值存储日志记录</li>
<li>系统添加日志记录来反应数据库更新的结果<ul>
<li>插入：存放整个元组</li>
<li>删除：标记该元组被删除</li>
<li>更新：记录被修改的属性的变化</li>
</ul>
</li>
<li>当需要读取日志记录，DBMS可以反向扫描日志，重新创建元组，还可以“回滚”</li>
<li>日志可定期压缩（通过删除不必要的记录来合并日志文件）</li>
<li>日志文件组织<ul>
<li>不同数据通常可能在不同的page，如果将更新信息写到数据页，需要访问多个page</li>
<li>将数据更新信息写道一个或者连续页效率更高</li>
<li>可建立“日志索引”，方便查找相关的日志记录</li>
<li>定期压缩日志，取出不必要的记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h3><ul>
<li>DBMS将数据库的元数据（描述信息）存放在内部的目录（数据字典）中<ul>
<li>表、列、索引、视图</li>
<li>用户、权限</li>
<li>数据的统计信息</li>
<li>存储过程、触发器等</li>
</ul>
</li>
</ul>
<h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><ul>
<li>联机事务处理OLTP –&gt; 行存储</li>
<li>联机分析处理OLAP –&gt; 列存储</li>
<li>复合事务分析处理HTAP<br>为了适应OLTP或OLAP不同的工作负载，DBMS可采用不同方式进行元组存储</li>
<li>NSM 行存储<ul>
<li>行存储模型非常适合OLTP</li>
<li>单个元组读所有属性连续分布在一个page中，查询往往涉及单个实体（工作量较烧），并能够适应较为繁重的“更新”工作量</li>
</ul>
</li>
<li>DSM 列存储<ul>
<li>DBMS将单个属性的值连续组织在一个page中，按列存储</li>
<li>更是个OLAP ，可以很好的适应大数据量、复杂查询语义、高负载查询<ul>
<li>如何进行“元组标识”</li>
<li>选择1：固定长度偏移，对某个属性每个值具备相同宽度</li>
<li>元组ID嵌入，每个值于其元组ID一起存放</li>
</ul>
</li>
<li>优点：<ul>
<li>由于只读取需要的数据，减少了对无用数据的I&#x2F;O</li>
<li>更便捷的查询处理</li>
<li>有利于数据压缩的实现</li>
</ul>
</li>
<li>缺点：<ul>
<li>数据被拆分，有些查询需要缝合，影响查询速度，也同时影响增删改效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>执行引擎在语句处理过程中需要使用某个数据页时，会像缓冲池提出请求</li>
<li>缓冲池管理器负责将该页面从磁盘读入内存，并向执行引擎提供该页面在内存中的指针</li>
<li>当执行引擎操作那部分内存时，缓冲池管理器必须确保该页面始终在内存区域中</li>
</ul>
<p>本节重点：DBMS如何管理数据在磁盘和缓存之间的交互，缩小CPU速度与磁盘速度之间的鸿沟</p>
<ul>
<li>缓冲池的作用<ul>
<li>减少磁盘I&#x2F;O，提升页面读写效率<ul>
<li>读操作时，若所需页面已加载到缓冲池，就不需要从磁盘读了</li>
<li>写操作时，如果多次修改了同一页面，只需要写一次磁盘</li>
</ul>
</li>
<li>缓冲池管理目标：尽可能减少磁盘I&#x2F;O带来的延时</li>
</ul>
</li>
</ul>
<h3 id="缓冲池结构"><a href="#缓冲池结构" class="headerlink" title="缓冲池结构"></a>缓冲池结构</h3><ul>
<li><p>缓冲池是在DBMS内部分配的一大片内存区域，用于存储从磁盘获取的页面</p>
</li>
<li><p>用于缓存页面的内存空间被粗制为一个数组，其中每个数组向被称为一个帧，一个真正好能放置一个页面</p>
</li>
<li><p>页表是缓冲池管理器用于维护缓冲池元数据的数据结构</p>
</li>
<li><p>缓冲池页表：</p>
<ul>
<li>页表：是一个内存散列表，用于等级当前已加载到缓冲池中的页面的信息</li>
</ul>
</li>
<li><p>页表为缓冲池中每个页面维护以下信息：</p>
<ul>
<li>位置信息：页面在缓冲池中对应帧的位置</li>
<li>脏标志：页面被修改过的标志。如果一个页面被设置了脏标志，则缓冲池管理器必须确保将其写回磁盘</li>
<li>引用计数：当前正在访问该页的线程数量。如果某页的引用计数大于零，则不允许淘汰该页(pin)</li>
</ul>
</li>
</ul>
<h3 id="缓冲池管理策略"><a href="#缓冲池管理策略" class="headerlink" title="缓冲池管理策略"></a>缓冲池管理策略</h3><ul>
<li><p>锁lock vs 闩 latch</p>
</li>
<li><p>锁和闩分别用于DBMS中两个级别的并发控制</p>
</li>
<li><p>锁：事务级</p>
<ul>
<li>保护的是数据库中的逻辑对象，如表、元组等</li>
<li>持锁时间较长，一般直到事务提交才释放</li>
<li>上锁期间对上锁对象的修改可以回滚</li>
</ul>
</li>
<li><p>闩：（进程）线程级</p>
<ul>
<li>保护的是DBMS中多线程&#x2F;进程共享的内部数据结构（临界资源），如帧</li>
<li>一般用OS的同步机制（如信号量）实现，加闩时间短，操作完立刻释放</li>
<li>加闩期间的修改无需考虑回滚</li>
</ul>
</li>
<li><p>分配策略：关于缓冲池中的内存空间如何分配的问题，缓冲池管理器采取2中策略：</p>
<ul>
<li>全局策略</li>
<li>局部策略</li>
</ul>
</li>
</ul>
<h3 id="缓冲池替换算法"><a href="#缓冲池替换算法" class="headerlink" title="缓冲池替换算法"></a>缓冲池替换算法</h3><ul>
<li><p>LRU算法：为每个页面维护其最后一次被访问的时间戳，需要淘汰页面时，DBMS总是选择淘汰时间戳最早的页面</p>
<ul>
<li>把入缓冲池的页放在LRU的头部，作为最近访问的元素，从而最晚被淘汰。为了减少数据移动，一般用链表实现<ul>
<li>页已经在缓冲池里：只把页面移动至LRU头部的动作，没有页面被淘汰</li>
<li>页不在缓冲池里：除了放入LRU头部的动作，还要淘汰LRU尾部页的动作</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>CLOCL算法：页称为近似LRU算法，为每个页面维护一个引用位，当某个页面被访问时，就将其引用位置为1。需要淘汰页面时候，循环扫描缓冲池中的页面检查各页面的引用位是否为1.如果是，则将引用位置为0并移动指针到下一个页面；否则淘汰当前页。</p>
</li>
<li><p>LRU算法和CLOCK算法的缺点：</p>
<ul>
<li>预读失效：由于预读，提前把页放入了缓冲池，但最终DBMS并没有从页中读取数据</li>
<li>顺序洪泛：因一次顺序扫描需要将表的所有页面读入缓存，导致缓存污染</li>
</ul>
</li>
<li><p>LRU-K算法</p>
<ul>
<li>核心思想：将淘汰页面时锁考察的最近访问次数由1提升为K</li>
<li>维护两个队列：<ul>
<li>历史队列：保存着新进入内存的页面及其访问次数，还有每一次的访问时间，当一个页面的访问次数达到K此，则将该页面保存至缓存队列；若历史队列满了，则根据一定的淘汰策略淘汰</li>
<li>缓存队列：保存着已经访问过K此的页面，当该队列满了之后，则根据LRU策略淘汰倒数第K次访问距离现在最久的那个页面</li>
</ul>
</li>
</ul>
</li>
<li><p>要优化预读失效</p>
<ul>
<li>让预读失败的页，停留在缓冲池LRU里时间尽可能短</li>
<li>让真正被读取的页，才挪到缓冲池LRU的头部</li>
</ul>
</li>
<li><p>具体方法：</p>
<ul>
<li>将LRU分为新生代、老生代</li>
<li>新老生代首尾相连</li>
<li>新页加入缓冲池时，只加入到老生代头部</li>
<li>若数据真正被读取（预读成功），才会加入新生代头部</li>
</ul>
</li>
<li><p>脏页的处理：</p>
<ul>
<li>快速：优先淘汰非脏的页（可能留着用不到的脏页）</li>
<li>慢速：写回磁盘再淘汰</li>
<li>后台写：定时写</li>
</ul>
</li>
</ul>
<h3 id="缓冲池的优化"><a href="#缓冲池的优化" class="headerlink" title="缓冲池的优化"></a>缓冲池的优化</h3><ul>
<li>多缓冲池<ul>
<li>DBMS维护多个用于不同目的的缓冲池</li>
<li>可以是多个缓冲池实力，每个数据库使用一个缓冲池每种页面类型使用一个缓冲池</li>
<li>各缓冲池可以采用量身定制的管理策略</li>
</ul>
</li>
<li>预取<ul>
<li>再处理第一组页面时，DBMS优先将第二组页面读取到缓冲池中</li>
<li>顺序访问的时候使用该方法</li>
</ul>
</li>
<li>扫描共享：某些查询结果可以公用<ul>
<li>将多个查询附加到一个游标上，查询游标可以重用从磁盘读入的数据或操作符的计算结果，减少重复访问的次数</li>
</ul>
</li>
<li>缓冲池旁路<ul>
<li>为避免开销，顺序扫描操作符不会将获取的页存储再缓冲池中，而是使用正在运行的查询的本地内存</li>
<li>如果操作符需要读取磁盘上连续的大量页序列，那么这种方法可以很好的工作</li>
<li>缓冲池旁路页可以用于临时数据，入排序、连接</li>
</ul>
</li>
</ul>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><ul>
<li><p>B+树性质</p>
</li>
<li><p>B+树是一种自评很的树型数据结构：它保持数据排列，允许在$O(logn)$的复杂度内进行搜索、顺序访问、插入和删除</p>
</li>
<li><p>二叉搜索树的泛化，一个节点可以有2个以上的子节点</p>
</li>
<li><p>针对读写大数据快的系统进行优化</p>
</li>
<li><p>B+树只在叶子节点中存储值，。内部节点无data域，仅用于引导搜索过程，内节点每个节点能索引的范围更大更精确。B+树更是适合外部存储</p>
</li>
<li><p>B+树的内部节点结构（阶为M）</p>
<ul>
<li>对于每个形如$&lt;P_1,K_1,P_2,K_2,…,P_{c-1},K_{c-1},P_c&gt;$的内部节点，其中$c&lt;M$,每一个$P_i$表示指向子树跟节点的指针，$K_i$表示关键字值</li>
<li>内部节点的关键字由小到大排列</li>
<li>对于一个位于$P_i$所指向的子树中的节点X而言，<ul>
<li>当$1&lt;i&lt;c$，均有$K_{i-1}&lt;X&lt;&#x3D;K_I$</li>
<li>当i&#x3D;c时，$X&gt;K_c-1$</li>
<li>当i&#x3D;1时，$X&lt;&#x3D;K_1$</li>
</ul>
</li>
<li>每一个内部节点最多有M个指向子树的指针，即c最大取M</li>
<li>根节点至少包含两个指向子树的节点指针，对于根节点而言，$2&lt;&#x3D;c&lt;&#x3D;M$。</li>
<li>除了根节点之外的每个节点都包含最少$ceil(\frac{M}{2})$个指向子树的指针，完全平衡树</li>
<li>如果任意一个内部节点包含c个指向孩子节点的指针而且$c&lt;&#x3D;M$，则该节点包含c-1的关键字</li>
</ul>
</li>
<li><p>B+树的叶子节点结构（阶为N）</p>
<ul>
<li>对每一个形如$&lt;&lt;K_1,D_1&gt;,&lt;K_2,D_2&gt;,…,&lt;K_{C-1},D_{C-1}&gt;,P_{next}&gt;$的叶子节点，其中c&lt;&#x3D;N，$D_i$是一个数据指针（指向磁盘上的值等于$K_i$的真是记录的指针，或者包含记录仪$K_i$的磁盘文件块），$K_i$是一个关键字，$P_{next}$表示B+树中指向下一个叶子节点的指针</li>
<li>对任意一个叶子节点，均有<ul>
<li>$K_1&lt;K_2&lt;…&lt;K_{C-1}$</li>
<li>c&lt;&#x3D;N</li>
</ul>
</li>
<li>每一个叶子节点至少包含$ceil(\frac{M}{2})$个值</li>
<li>所有的叶子节点在同一层</li>
<li>使用$P_{next}$指针可以遍历所有的叶子节点，就和单链表一样，从而实现对磁盘上记录的有序访问</li>
</ul>
</li>
<li><p>选择条件</p>
<ul>
<li>如果查询提供了B+树搜索关键字的任何属性的值，DBMS就可以使用B+树索引<ul>
<li>全值匹配</li>
<li>匹配最左前缀</li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>只访问索引的查询</li>
</ul>
</li>
<li>索引的分类<ul>
<li>主键索引&#x2F;唯一索引&#x2F;普通索引&#x2F;全文索引&#x2F;组合索引</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树插入操作</p>
<ul>
<li>若为空树，创建一个叶子节点，将记录插入其中，此叶子节点为根节点，插入操作结束</li>
<li>针对叶子节点<ul>
<li>根据key值去欸的那个叶子几点L，将排序后的关键字插入此节点L</li>
<li>如果空间充足（即节点L含有的关键字数目小于阶数ｍ），则插入结束</li>
<li>否则将节点L分裂为左右两个叶子节点$L$和$L_2$<ul>
<li>左叶子几点包含前$\frac{m}{2}$个记录</li>
<li>右叶子节点包含剩下的记录</li>
<li>将第$\frac{m}{2}+1$个记录的key进位到父节点中，并完成在父（内）节点的插入 （可能引起分裂递归）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树删除操作</p>
<ul>
<li>如果叶子节点中没有相应的key，则删除失败，否则执行</li>
<li>如果跟节点除法找到该关键字所在节点L，删除该关键字</li>
<li>如果节点L的关键字数目不少于$\frac{M}{2}$，则删除完成，结束</li>
<li>如果节点L仅有$\frac{M}{2}-1$个关键字数目，向兄弟节点借一个关键字（兄弟节点指与L有相同父节点的相邻节点）</li>
<li>否则将节点L与兄弟节点合并，合并时需要删除父节点中的关键字（指向L或其兄弟节点，可能引起删除内节点的级联合并）</li>
</ul>
</li>
<li><p>B+树的重复键</p>
<ul>
<li>附加记录ID作为键的一部分：每个元组的记录ID是唯一的，确保了所有键都是可识别的</li>
<li>允许叶节点溢出至包含重复键的溢出节点</li>
</ul>
</li>
<li><p>索引适用场景</p>
<ul>
<li>如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）</li>
<li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li>
<li>如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引</li>
</ul>
</li>
<li><p>聚簇适用场景（第七章就有了）</p>
</li>
</ul>
<h1 id="第九章-关系查询处理及优化"><a href="#第九章-关系查询处理及优化" class="headerlink" title="第九章 关系查询处理及优化"></a>第九章 关系查询处理及优化</h1><h2 id="关系数据库系统的查询处理"><a href="#关系数据库系统的查询处理" class="headerlink" title="关系数据库系统的查询处理"></a>关系数据库系统的查询处理</h2><h3 id="查询处理步骤"><a href="#查询处理步骤" class="headerlink" title="查询处理步骤"></a>查询处理步骤</h3><ul>
<li><p>查询分析</p>
</li>
<li><p>查询检查</p>
</li>
<li><p>查询优化</p>
</li>
<li><p>查询执行</p>
</li>
<li><p>查询计划：</p>
<ul>
<li>操作算子以树的形式进行组织</li>
<li>数据流从叶子节点流向根节点</li>
<li>根节点的输出是查询的结果</li>
</ul>
</li>
</ul>
<h3 id="查询处理模型"><a href="#查询处理模型" class="headerlink" title="查询处理模型"></a>查询处理模型</h3><p>处理模型定义系统如何执行一个查询计划，不同的任务负载对应不同的权衡结果</p>
<ul>
<li><p>迭代模型：每个查询计划的算子执行一个next函数</p>
<ul>
<li>也称作火山模型&#x2F;流水线模型</li>
<li>该计算模型将关系代数中的每一个操作抽象为一个operator，将整个SQL构建成一个operator树，查询树子顶向下的调用<code>next()</code>接口，数据则自底向上的被拉取处理</li>
<li>每次调用<code>next</code>得到一个元组，或者一个空值标记</li>
<li>算子通过循环调用它的子节点的<code>next</code>函数用于获取元组进行，当处理完成后再通过<code>next</code>函数获取下一个元组处理组进行处理，直到得到一个<code>null</code></li>
<li>获取磁盘数据代价太大，需要它在内存中做足够多的操作</li>
<li>特点<ul>
<li>几乎所有的DBMS都采用该模型，允许元组流水线</li>
<li>流水线的好处<ul>
<li>消除读和写临时关系的代价，从而减少查询计算代价</li>
<li>流水线产生查询结果，边生成边输出给用户，提高相应时间。很容易控制输出，如limit操作</li>
</ul>
</li>
<li>有些算子会阻塞数据的流动，直到其子节点发送所有的元组，如join操作，子查询操作，排序操作</li>
</ul>
</li>
</ul>
</li>
<li><p>物化模型</p>
<ul>
<li>算子一次性获取它所有的输入，当处理完成后再返回给它的父节点</li>
<li>算子能物化其输出作为一整个结果</li>
<li>为了避免下层算子返回的数据量过大，上层算子可以尽可能提供多的过滤条件.DBMS会将一些参数传递到操作符中，防止处理过多的数据</li>
<li>输出可以是整个元组(NSM存储模式)，或属性自己(DSM存储模式)</li>
<li>特点：<ul>
<li>适合OLTP，一次处理少量数据</li>
<li>相对火山模型，较少的函数调用，能减少不必要的执行、调度成本</li>
<li>不适合OLAP，AP查询可能产生较大的中间结果</li>
</ul>
</li>
</ul>
</li>
<li><p>向量&#x2F;批量模型</p>
<ul>
<li>执行框架同火山模型</li>
<li>不同之处是每次调用Next函数，返回的是一批batch元组而不是一个元组。操作符内部的循环每次也是一批一批的处理</li>
<li>特点：</li>
<li>介于火山模型和物化模型之间</li>
<li>适用于OLAP</li>
<li>允许用户适用向量化的SIMD指令处理批量元组</li>
</ul>
</li>
<li><p>查询树处理的方向</p>
<ul>
<li>自顶而下：从根节点开始不断的向子节点拉去数据，元组通过函数调用传递</li>
<li>自底向上：从叶子系欸但开始获取数据不断的向父节点推送数据</li>
</ul>
</li>
</ul>
<h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><ul>
<li><p>数据存取方法：访问存储在表中的数据的方法。并没有在关系代数中被定义</p>
</li>
<li><p>顺序扫描</p>
<ul>
<li>对于表的每一个page<ul>
<li>加载到bufferpool中</li>
<li>对bufferpool的page中符合条件的tuple依次进行处理</li>
<li>DBMS内部维持一个游标指向上次访问的page&#x2F;slot</li>
</ul>
</li>
<li>优化<ul>
<li>zone map：预先计算一个页中的属性统计值（最大值，最小值，平均值），并存入zonema品种，在顺序扫描中根据zonemap来决定是否读取该页</li>
<li>late materialization：延迟缝合元组，直到查询计划的上层才缝合</li>
</ul>
</li>
</ul>
</li>
<li><p>索引扫描：通过索引来访问查询所需要的数据页</p>
</li>
<li><p>多索引扫描（位图扫描）</p>
<ul>
<li>对每个索引进行扫描，获取哪些指向满足单个条件的元组ID（或元组指针）</li>
<li>根据谓词求取这些元组ID集合的交集或并集</li>
<li>根据剩余的谓词（没有索引）过滤这些元组</li>
</ul>
</li>
<li><p>连接操作典型实现方法</p>
<ul>
<li>嵌套循环方法<ul>
<li>对外层循环的每一个元组，检索内存循环中的每一个元组sc</li>
<li>检查这连个元组在连接属性上是否先庚</li>
<li>如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止</li>
</ul>
</li>
<li>排序-合并方法<ul>
<li>适合连接的诸表已经排好序的情况</li>
<li>如果已经有序，O(m+n)</li>
<li>否则O(mlog(m)+nlog(n))</li>
</ul>
</li>
<li>索引连接方法<ul>
<li>在内关系上建立连接属性的索引（如果原来没有）</li>
<li>对外关系中每个元组，由连接属性的值通过内关系的索引查找相应的内关系元组</li>
<li>把这些内关系元组和外关系元组连接起来，循环执行上一条和本条语句，直到外关系的元组处理完为止</li>
<li>若I&#x2F;O开销为C，则总开销M+(m*C)</li>
<li>如果两个关系上均由索引时，一般把元组较少的关系作外关系效果比较好</li>
</ul>
</li>
<li>hash join方法<ul>
<li>把连接属性作为hash码，用同一个hash函数把R和S中的元组散列到同一个hash文件中</li>
<li>步骤<ul>
<li>划分阶段</li>
<li>试探阶段，也称为连接阶段</li>
</ul>
</li>
<li>设内关系被划分成X个散列桶，$创建散列表的成本(m)+散列函数的计算开销*n+(m&#x2F;X)*n$</li>
</ul>
</li>
</ul>
</li>
<li><p>连接算法的选择</p>
<ul>
<li>空闲内存：内存不够则无法适用内存中的hash连接</li>
<li>连个数据集的大小<ul>
<li>若一个大表连接一个很小的表，则嵌套循环连接就比散列连接快</li>
<li>若两个表都很大，则嵌套循环连接的CPU成本就比较搞</li>
</ul>
</li>
<li>是否由索引：单一有，选择索引连接。若连接属性上有两个B+树的索引的话，合并连接是好选择</li>
<li>关系是否已经排序：有则选用合并连接</li>
<li>结果是否需要排序：即使参与连接的是未排序的数据集，也可以考虑适用成本较高的合并连接</li>
<li>连接的类型：等值？内连接？外连接？笛卡尔积？子连接？有些连接算法在某些情况下是不适用的</li>
<li>数据的分布：若连接条件的数据是倾斜的，hash连接不是好选择</li>
<li>多表连接：连接顺序的选择很重要</li>
</ul>
</li>
</ul>
<h2 id="关系数据库系统的查询优化"><a href="#关系数据库系统的查询优化" class="headerlink" title="关系数据库系统的查询优化"></a>关系数据库系统的查询优化</h2><ul>
<li>有选择和连接操作时候，先做选择操作，这样参加连接的元组就可以大大减少，这就是代数优化，及通过对关系嗲书表达式的等价变换来提高查询效率。</li>
<li>如果估算索引扫描比全表扫描更好，使用索引扫描和index join，就是物理优化</li>
</ul>
<h2 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h2><p>通过对关系代数表达式的等价变换来提高查询效率</p>
<h3 id="关系代数表达式等价转换规则"><a href="#关系代数表达式等价转换规则" class="headerlink" title="关系代数表达式等价转换规则"></a>关系代数表达式等价转换规则</h3><ul>
<li>笛卡尔积、自然连接的交换律和结合律<ul>
<li>$$E_1 \times E_2 \equiv E_2 \times E_1; \quad (R\times S)\times T \equiv R \times (S\times T)$$ </li>
<li>$$E_1 ⟗ E_2 \equiv E_2 ⟗ E_1; \quad (R ⟗ S) ⟗ T \equiv R ⟗ (S ⟗ T)$$</li>
</ul>
</li>
<li>投影的串接律<ul>
<li>$$ \pi_{A1,A2,…,An}(\pi_{B1,B2,…,Bm}(E)) \equiv \pi_{A1,…,An}(E)$$</li>
<li>在同一个关系上，只需要做依次投影运算，且一次投影时选择多列同时完成</li>
</ul>
</li>
<li>选择的串接律<ul>
<li>$$ \sigma_{F1}(\sigma_{F2}(E)) \equiv \sigma_{F1 \land F2}(E)  $$</li>
<li>选择条件可以合并，使得一次选择运算就可检查全部条件，而不必多次过滤元组</li>
</ul>
</li>
<li>选择与投影的交换律<ul>
<li>假设：选择条件F只设计属性A1,…,An –&gt; 先选择，后投影</li>
<li>$$ \sigma_F (\pi_{A1,…,An}(E)) \equiv \pi_{A1,…,An}(\sigma_F(E))  $$ </li>
<li>假设：F中有不属于A1,…,An的属性B1,…,Bm  –&gt; 先做带选择条件中的列投影，然后选择，再完成最外层投影</li>
<li>$$ \pi_{A1,…,An}(\sigma_F (E)) \equiv \pi_{A1,…,An}(\sigma_F(\pi_{A1,…,An,B1,…,Bm}(E))) $$</li>
</ul>
</li>
<li>选择与笛卡尔积的交换律<ul>
<li>若F中设计的属性都是$E1$中的属性</li>
<li>$$ \sigma_F (E_1 \times E_2) \equiv \sigma_F(E_1) \times E_2 $$</li>
<li>若$F&#x3D;F_1 \land F_2$,并且$F_1$只涉及$E_1$中的属性，$F_2$中只涉及$E_2$中的属性，则：</li>
<li>$$ \sigma_F(E_1 \times E_2) \equiv \sigma_{F_1}(E_1) \times \sigma_{F_2}(E_2) $$</li>
<li>若$F&#x3D;F_1 \land F_2$,$F_1$只涉及$E_1$中的属性，$F_2$涉及$E_1$和$E_2$的属性，则：</li>
<li>$$ \sigma_F(E_1 \times E_2) \equiv \sigma_{F_2}(\sigma_{F_1}(E_1)\times E_2) $$</li>
<li>部分选择再笛卡尔积之前先做</li>
<li>条件下推到相关的关系上，先做选择后做笛卡尔积运算，这样可以减小中间结果的大小</li>
</ul>
</li>
<li>选择与并的分配律<ul>
<li>假设：$E&#x3D; E_1 \cup E_2$,$E_1,E_2$有相同的属性名，</li>
<li>$$ \sigma_F(E_1 \cup E_2) \equiv \sigma_F(E_1) \cup \sigma_F (E_2) $$</li>
<li>条件下推到相关的关系上，先选择后做并运算，可以减小每个关系输出结果的大小</li>
</ul>
</li>
<li>选择与差的分配律<ul>
<li>假设$E_1,E_2$有相同的属性名</li>
<li>$$ \sigma_F(E_1-E_2) \equiv \sigma_F(E_1)-\sigma_F(E_)2 $$</li>
<li>先选择后做差运算</li>
</ul>
</li>
<li>选择与自然连接的分配律<ul>
<li>假设：$E_1,E_2$使两个关系表达式</li>
<li>$$ \sigma_F(E_1 ⟗ E_2) \equiv \sigma_F(E_1) ⟗ \sigma_F(E_2) $$</li>
<li>先选择后做自然连接运算</li>
</ul>
</li>
<li>投影与笛卡尔积的分配律<ul>
<li>设$E_1,E_2$是两个关系表达式，$A_1,…A_n$是$E_1$的属性，$B_1,…,B_m$是$E_2$的属性，则</li>
<li>$$ \pi_{A_1,…,A_n,B_1,…,B_m}(E_1 \times E_2) \equiv \pi_{A_1,…,A_n}(E_1) \times \pi_{B_1,…,B_m}(E_2) $$</li>
<li>先投影后做笛卡尔积</li>
</ul>
</li>
<li>投影与并的分配律<ul>
<li>设$E_1,E_2$有相同的属性名</li>
<li>$$ \pi_{A_1,…,A_n}(E_1 \cup E_2) \equiv \pi_{A_1,…,A_n}(E_1) \cup \pi_{A_1,…,A_n}(E_2) $$</li>
<li>先投影后做并操作</li>
</ul>
</li>
</ul>
<h3 id="查询树的启发式规则"><a href="#查询树的启发式规则" class="headerlink" title="查询树的启发式规则"></a>查询树的启发式规则</h3><ul>
<li><p>转换的最终目的</p>
<ul>
<li>减少查询的开销（I&#x2F;O次数）</li>
</ul>
</li>
<li><p>转换的直接目的</p>
<ul>
<li>减少中间关系的元组数、元组大小</li>
</ul>
</li>
<li><p>规则1：选择运算尽早执行（减小中间结果的规模）</p>
</li>
<li><p>规则2：将选择、投影运算同时进行（避免重复扫描）</p>
</li>
<li><p>规则3：把投影同其前或其后的双目运算结合（避免重复扫描次数）</p>
</li>
<li><p>规则4：把选择运算与其前面的笛卡尔积运算结合起来一起计算（避免重复扫描并减小中间结果集的规模）</p>
</li>
<li><p>规则5：把公共子表达式的运算结果存放在外存，作中间结果，使用时读入主存。如：视图表达式（避免重复计算）</p>
</li>
<li><p>关系表达式代数优化算法</p>
<ul>
<li>运用选择的串接定律，得到选择运算“串”</li>
<li>对每个选择运算符，利用等价变换尽量将其移至树的叶端</li>
<li>对每个投影运算符，利用等价变换尽量将其移至树的叶端</li>
<li>尝试将选择和投影串接合并成单个选择或投影，或选择后跟一个投影</li>
<li>上述得到的语法树内节点分组：双目运算和它的父节点为一组。若其后代直至叶节点全部是单目运算，也合并为一组。笛卡尔积的子节点如果不能组合成等值的连接的选择，则二者不合并</li>
</ul>
</li>
</ul>
<h2 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h2><ul>
<li>代数优化改变拆线呢语句中操作的次序和组合，不涉及底层的存取路径</li>
<li>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的计划。常常先使用启发式规则选取若干较优的候选查询方案，然后分别估算这些候选方案的执行代价，从而选取代价最小的作为执行计划</li>
</ul>
<h3 id="基于启发式规则的优化"><a href="#基于启发式规则的优化" class="headerlink" title="基于启发式规则的优化"></a>基于启发式规则的优化</h3><ul>
<li>选择操作的启发式规则：<ul>
<li>对于小关系，使用全表扫描了，即 使选择列上有索引</li>
<li>对大关系<ul>
<li>如果是主码值上的等值查询“主码&#x3D;值”，使用主码索引</li>
<li>如果是非主码值上的等值查询，在选择比例&lt;10%的情况下，使用索引（如果有）；否则使用全表扫描</li>
<li>如果非等值或范围查询，在选择比例&lt;10%的情况下是，使用索引（如果有）；否则使用全表扫描</li>
<li>对于用AND连接的合取选择条件，如果有涉及折写属性的组合索引，优先采用组合索引扫描方法；如果某些属性上有一般索引，则可以用索引扫描方法；否则使用全表顺序扫描</li>
<li>对于用OR连接的析取选择条件，一般使用全表顺序扫描</li>
</ul>
</li>
</ul>
</li>
<li>连接操作的启发式规则<ul>
<li>如果2个表都已经按照连接属性排序，使用选择-合并方法</li>
<li>如果一个表在连接属性上有索引，选择索引连接方法</li>
<li>如果上面两个规则都不使用，其中一个表较小，使用hash join方法</li>
<li>可以选用嵌套循环方法，并选择其中占用块较小的表，作为外表（外循环的表）</li>
</ul>
</li>
</ul>
<h3 id="基于代价的优化"><a href="#基于代价的优化" class="headerlink" title="基于代价的优化"></a>基于代价的优化</h3><ul>
<li><p>为什么采用启发式规则</p>
<ul>
<li>可能造成查询优化过程的开销大于获得的查询开销的大小，得不偿失</li>
</ul>
</li>
<li><p>查询代价估算</p>
</li>
<li><p>查询代价估算基于CPU代价和I&#x2F;O代价，</p>
<ul>
<li>$$ 总代价&#x3D;I&#x2F;O代价+CPU代价$$</li>
<li>$$ COST &#x3D; P * a_page_cpu_time + W * T $$</li>
<li>P是计划运行时访问的页面数，a_page_cpu_time是每个页面读取的时间开销，其成绩反应了I&#x2F;O开销</li>
<li>T为访问的元组数量，如果是索引扫描，还要考虑索引读取的开销，反应了数据读取到内存的CPU开销</li>
<li>W为权重因子，表明I&#x2F;O到CPU的相关性，有称选择率</li>
</ul>
</li>
</ul>
<h1 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h1><h2 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h2><ul>
<li>事务<ul>
<li>定义：事务是用户定义的一组数据库操作，这组操作要么都做，要么都不做，不可分割。</li>
<li>是恢复和并发控制的基本单位</li>
</ul>
</li>
<li>事务和程序比较<ul>
<li>关系数据库事务：一个&#x2F;一组SQL语句，或一段程序</li>
<li>一个程序通常包含多个事务</li>
</ul>
</li>
<li>定义事务<ul>
<li>显式定义方式 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> transaction</span><br><span class="line">  <span class="keyword">SQL</span>语句<span class="number">1</span></span><br><span class="line">  <span class="keyword">SQL</span>语句<span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">commit</span> work<span class="operator">/</span><span class="keyword">rollback</span> work</span><br></pre></td></tr></table></figure></li>
<li>隐式方式：当用户没有显式定义事务时，DBMS按缺省规定自动划分事务</li>
<li>某种环境或者程序中的一条SQL语句，应用程序或操作窗口退出</li>
</ul>
</li>
<li>事务的特性（ACID）<ul>
<li>原子性atomicity:要么全做，要么全不做</li>
<li>一致性consistency：数据库中只包含成功事务提交的结果，没有夭折事务残留的修改</li>
<li>隔离性isolation：不受其它并发执行事务的影响</li>
<li>持久性durability</li>
</ul>
</li>
<li>事务的两段提交：<ul>
<li>事务执行的读写操作，只有正常提交了，才永久存入DB，之前都是放在缓冲区中。如果事务失败，则DBMS撤销它对DB和其它事务的影响，恢复到执行事务之前的状态</li>
</ul>
</li>
</ul>
<h2 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h2><ul>
<li>事务内部故障<ul>
<li>特点：非预期事务故障：事务没有达到预期的重点（commit或rollback）,事务夭折。夭折事务对数据库的部分修改可能已写入数据文件（数据库可能处于不正确、不一致状态）</li>
<li>DBMS仍在正常运行</li>
<li>事务故障恢复：撤销事务，DBMS自动完成</li>
</ul>
</li>
<li>系统故障<ul>
<li>特点：<ul>
<li>整个系统的正常运行突然被破坏，DBMS不能正常运行</li>
<li>所有正在运行的事务都非正常终止</li>
<li>内存数据丢失或不再可靠；外存数据不受影响</li>
<li>DB处于不正确或不一致状态：一些尚未完成事务的结果可能已送入DB；已完成事务的结果可能部分未送入DB；已完成事务的结果全部未送入DB（未提交）</li>
</ul>
</li>
<li>发生故障时，事务未提交：<ul>
<li>恢复策略：强行撤销undo所有未完成事务</li>
</ul>
</li>
<li>发生系统故障时，事务已提交，但缓冲区中的信息尚未完全写回到磁盘上：<ul>
<li>恢复策略：重做redo所有已提交的事务</li>
</ul>
</li>
</ul>
</li>
<li>介质故障：硬故障，外存发生故障<ul>
<li>介质故障恢复：装入副本或镜像。</li>
</ul>
</li>
</ul>
<h2 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h2><h3 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h3><ul>
<li>静态转储与动态转储<ul>
<li>静态：<ul>
<li>在系统无运行事务时进行的转储操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>转储期间不允许对数据库的任何存取、修改活动</li>
<li>得到的一定是一个数据一致性的副本</li>
<li>优点：实现简单</li>
<li>缺点：停止了一切事务运行，降低了数据库的可用性<ul>
<li>转储必须等待正在运行的用户事务结束</li>
<li>新的事务必须等待转储结束</li>
</ul>
</li>
</ul>
</li>
<li>动态：转储操作与用户事务并发进行，转储期间允许对数据库进行存取或修改<ul>
<li>优点：不用等待正在运行的用户事务结束，不会影响新事务的运行</li>
<li>缺点：不能保证副本中的数据正确有效</li>
<li>解决：需要把动态转储期间各事务对数据库的修改活动等级下来，建立日志文件</li>
<li>后备副本加上日志文件才能把数据库恢复到某一时刻的正确状态。</li>
</ul>
</li>
</ul>
</li>
<li>海量转储与增量转储<ul>
<li>海量转储：定期或不定期将DB全部数据转储<ul>
<li>优点：简单</li>
<li>缺点：重复转储，转储量大；停止运行（多为静态转储）</li>
</ul>
</li>
<li>增量转储：只转储上次转储后更新过的数据：<ul>
<li>优点：备份量小</li>
<li>缺点：恢复过程比较复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>先写日志后写数据规则</li>
<li>对日志文件中的记录进行REDO的时候，要按照日志序号递增的顺序进行，即正向扫描日志文件进行REDO</li>
<li>对日志文件中的记录进行UNDO的时候，要按照日志序号递减的顺序进行，即反向扫描日志文件进行UNDO</li>
</ul>
<h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><ul>
<li><p>事务恢复方法：利用log UNDO此事务对DB的修改</p>
</li>
<li><p>步骤：UNDO操作</p>
<ul>
<li>反向扫描文件日志，查找该事务的更新操作</li>
<li>对该事务的更新操作执行逆操作。</li>
<li>继续上两条</li>
<li>读到事务开始标记，故障恢复完成</li>
</ul>
</li>
<li><p>特点：DBMS自动完成</p>
</li>
<li><p>系统故障的恢复</p>
</li>
<li><p>目标：撤销故障发生时未完成的事务，重做已完成的事务</p>
</li>
<li><p>步骤：UNDO未完成事务，REDO已完成事务</p>
<ul>
<li>正向扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入重做队列；同时找出故障发生时未完成的事务，将其事务标识记入撤销队列。</li>
<li>对撤销队列中的各个事务进行撤销处理：反向扫描日志文件，对每个UNDO事务执行UNDO操作</li>
<li>对重做队列中的各个事务进行重做REDO处理：正向扫描日志文件，对每个REDO事务重新执行等级的操作。</li>
</ul>
</li>
<li><p>特点：由DBMS在重启时自动完成</p>
</li>
<li><p>介质故障的恢复</p>
</li>
<li><p>目标：数据和日志文件被破坏时的恢复，维护事务的持久性</p>
</li>
<li><p>步骤：</p>
<ul>
<li>装入最新的后背数据库副本，使数据库恢复到最近一次转储时的一致性状态<ul>
<li>对于动态转储的数据库副本，还需要转储时刻的日志文件副本，利用恢复系统故障相同的方法，才能恢复到一致性状态</li>
</ul>
</li>
<li>装入有关的日志文件副本，重做已完成的事务<ul>
<li>特点：需要DBA干预。DBA负责：重装最近转存的数据库副本和有关的各日志文件副本，执行系统提供的恢复命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="checkpoint技术"><a href="#checkpoint技术" class="headerlink" title="checkpoint技术"></a>checkpoint技术</h2><ul>
<li>基本策略：周期性的对日志做检查点，保存DB状态，避免故障恢复时检查整个日志</li>
<li>方法：在日志文件中增加一类新的记录–检查点checkpoint记录，并增加一个”重新开始文件“。周期性执行以下步骤<ul>
<li>将日志缓冲区中的日志记录写入磁盘</li>
<li>在日志文件中写一个检查点记录</li>
<li>将数据缓冲区中的数据写入磁盘DB中</li>
<li>将检查点记录在日志文件中的地址写入重新开始文件</li>
</ul>
</li>
<li>检查点记录的内容：<ul>
<li>checkpoint时刻所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址</li>
</ul>
</li>
<li>重新开始文件的内容：<ul>
<li>记录各个检查点记录在日志文件中的地址</li>
</ul>
</li>
<li>使用检查点方法可以改善恢复效率：<ul>
<li>当事务T在一个检查点之前提交：<ul>
<li>T对数据库所做的修改已写入数据库</li>
<li>写入时间使在这个检查点建立之前或在这个检查点建立之时</li>
<li>在进行恢复处理时，没有必要对事务T执行REDO操作</li>
</ul>
</li>
</ul>
</li>
<li>利用checkpoint进行恢复的步骤：<ul>
<li>根据重新开始文件中最后一个检查点记录的地址，在日志文件中找到最后一个检查点记录</li>
<li>由检查点记录得到该检查点记录的事务清单active-list<ul>
<li>建立两个事务队列：undo-list,redo-list</li>
<li>把active-list暂时放入undo-list对立，redo队列暂时为空</li>
</ul>
</li>
<li>从检查点开始正向扫描日志文件，直到日志文件结束<ul>
<li>如有新开始的事务T，把T暂时放入undo-list队列</li>
<li>如有提交的事务T，把T从undo-list移到redo-list</li>
</ul>
</li>
<li>对undo-list的每个事务执行undo操作，对redo-list的每个事务执行redo操作</li>
</ul>
</li>
</ul>
<h1 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>并发控制是为保证多用户并发操作数据库中信息时的正确性、一致性所采取的措施</p>
</li>
<li><p>事务调度</p>
<ul>
<li>事务的执行顺序称为一个调度,表示事务的指令在系统中执行的时间顺序</li>
<li>一组事务的调度必须保证<ul>
<li>包含了所有事务的操作指令</li>
<li>一个事务中指令的顺序必须保持不变</li>
</ul>
</li>
<li>串行调度<ul>
<li>属于统一事务的指令紧挨在一起</li>
<li>每个时刻只有一个事务运行,其它事务必须等到这个事务结束以后方能运行</li>
<li>对于有有n个事务的事务组,可以有$n!$个有效调度</li>
<li>缺点:不能充分利用系统资源,发挥数据共享资源的特点</li>
</ul>
</li>
<li>交叉并发方式<ul>
<li>在单处理机系统中,事务的并行执行是这些并行事务的并行操作轮流交叉运行</li>
<li>单处理机系统中的并行事务并没有真正的并行运行,单能够减少处理机的空闲时间,提高系统的效率</li>
</ul>
</li>
<li>同时并发方式<ul>
<li>多处理机系统中,每个处理机可以运行一个事务,多个处理机可以同事运行多个事务,实现多个事务真正的并行运行</li>
<li>并发执行的优点:<ul>
<li>一个事务由不同的步骤组成,所设计的系统资源也不同.各步骤并发执行,提高系统的吞吐量</li>
<li>如果各个事务设计数据库的不同部分,采用并发会减少平均响应时间</li>
</ul>
</li>
<li>核心问题:在保证一致性的前提下最大限度的提高并发度</li>
</ul>
</li>
</ul>
</li>
<li><p>并行调度的问题:带来数据的不一致性</p>
<ul>
<li>丢失更新<ul>
<li>两个以上事务从DB中读入同一数据并进行修改,其中一事务(后提交的事务)的提交结果破坏了另一事务(先提交事务)的提交结果,导致先提交事务对DB的修改被丢失.这种现象使数据库操作出现严重错误.</li>
</ul>
</li>
<li>不可重复读<ul>
<li>同一事务重复读同一数据,但获得结果不同,即从数据库中得到了不一致的数据(可能因为其它并发修改了数据库中的数据)</li>
</ul>
</li>
<li>读“脏”数据<ul>
<li>读未提交随后又被撤销(rollback)的数据.即从数据库中获取了临时性数据</li>
</ul>
</li>
</ul>
</li>
<li><p>并发控制的任务:用正确的方法调度并发操作,使一个事务的执行不受其他事务的干扰,从而避免数据的不一致现象</p>
</li>
<li><p>并发控制:正确的方式调度并发事务,使得一个事务的执行不受其他事务的干扰,避免造成数据的不一致性</p>
<ul>
<li>封锁</li>
<li>时间戳</li>
<li>乐观控制法</li>
<li>多版本并发控制</li>
</ul>
</li>
</ul>
<h2 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h2><ul>
<li><p>定义:事务T在每个数据对象操作之前,先相系统发出请求,加锁,于是事务T对这个数据对象就有一定的控制,直到T释放它的锁为止</p>
</li>
<li><p>锁的类型</p>
<ul>
<li>排它锁(X锁,写锁):若事务T对数据R加上X锁,啧其他事务不能对R进行任何封锁,保证了其他事务不能读取和修改R</li>
<li>共享锁(S锁,读锁):若事务T对数据R加上了S锁,啧其他事务能对R加S锁,保证了其他事务能读取单不能修改R</li>
</ul>
</li>
<li><p>封锁的粒度:</p>
<ul>
<li>封锁对象的大小称为封锁的粒度</li>
<li>关系数据库的封锁对象:属性之、元组、关系、索引</li>
</ul>
</li>
<li><p>封锁规则</p>
<ul>
<li>对于将要存取的数据须先申请加锁,加锁成功才能存取</li>
<li>已被加锁的数据不能再加不相容锁</li>
<li>一旦退出使用应适时释放锁</li>
<li>未被加锁的数据不可以对之解锁</li>
</ul>
</li>
<li><p>常用的封锁协议</p>
<ul>
<li>支持一致性维护的三级封锁协议<ul>
<li>策略:1级封锁协议+事务Ti在读取Di之前必须对Di加s锁,直至Ti结束后即可释放该s锁</li>
<li>功能:防止丢失更新、防止读“脏”、防止读不可重复</li>
</ul>
</li>
<li>支持并行调度可串行化的两段封锁协议</li>
<li>避免死锁的协议</li>
</ul>
</li>
<li><p>活锁：事务因故永远处于等待状态</p>
<ul>
<li>预防方法：FCFS(first come first Server):先来先服务</li>
<li>对于事务由优先级的系统，可设置一个最长等待时间，与优先级结合，调度事务的执行</li>
</ul>
</li>
<li><p>死锁：两个或两个以上事务均处于等待状态，每个事务都在等待其中另一个事务封锁的数据，导致任何事务都不能继续执行</p>
<ul>
<li>产生条件：<ul>
<li>互斥（排它性控制）</li>
<li>不可剥夺（释放前，其它事务不能剥夺）</li>
<li>部分分配（每次申请一部分）</li>
<li>环路（每事务获得的数据同时又被另一事务请求）</li>
</ul>
</li>
<li>解决办法：破坏死锁产生的条件<ul>
<li>预防：一次封锁法：每个事务先一次获得其需数据的全部锁<ul>
<li>特征：简单，无死锁；粒度大，并发性低；难以实现精确确定封锁对象。</li>
</ul>
</li>
<li>预防：顺序封锁：按照预先确定的数据封锁顺序实行封锁</li>
<li>预防：时间戳优先级法<ul>
<li>wait-die：老的时间戳更高优先级，优先级低的如果请求锁，则撤回。</li>
<li>wound-wait：请求的事务有更高的优先级，则撤销持有锁的事务，释放锁。</li>
</ul>
</li>
<li>等待图法：构造等待图，周期性检测，如果出现回路，则选择一个处理死锁代价最小的事务，释放该事务的所有锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="并发调度的可串行性"><a href="#并发调度的可串行性" class="headerlink" title="并发调度的可串行性"></a>并发调度的可串行性</h2><ul>
<li><p>可串行化调度：当且仅当多个事务并发执行的结果与该事务任一串行执行的结果相同时，则该并发执行是可串行化的</p>
</li>
<li><p>可串行性是并发事务正确调度的唯一准则</p>
</li>
<li><p>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</p>
</li>
<li><p>冲突可串行化——判断可串行化调度的<strong>充分</strong>条件：对于一个并发调度Sc，在保证冲突操作次序不变的情况下，如果通过交换不冲突操作可以得到一个串行调度，则Sc为冲突可串行化调度</p>
</li>
<li><p>冲突操作：不同事务对同一个数据的读写操作或写写操作</p>
</li>
<li><p>交换原则：</p>
<ul>
<li>不同事务的冲突操作不能交换次序</li>
<li>同一事务的两个操作不可交换</li>
</ul>
</li>
</ul>
<h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><ul>
<li>2PL是保证并发操作调度的可串行化而提供的封锁协议</li>
<li>策略：<ul>
<li>在对任何数据读、写之前，必须先获得该数据的锁</li>
<li>在释放一个封锁之后，该事务不能再申请任何其它锁</li>
</ul>
</li>
<li>定理：若所有并发事务都遵循两段锁协议，则最这些事务的所有并发调度都是可串行化的</li>
<li>说明：<ul>
<li>是可串行化调度的充分条件</li>
<li>并性执行结果一定是正确的，但是不能防止死锁<ul>
<li>一次封锁法遵守两段锁协议，但是两段锁协议不要求事务必须一次将所有要使用的数据都枷锁，所以可能死锁</li>
</ul>
</li>
<li>2PL保证冲突可串行化，但是存在级联撤销的问题<ul>
<li>解决：再释放锁（shrinking phase）阶段，只有commit或abort时才一次性释全部锁</li>
</ul>
</li>
<li>两段锁 VS 三级封锁协议<ul>
<li>两段锁保证并发调度的正确性</li>
<li>三级封锁协议在不同程度上保证数据的一致性</li>
<li>遵循第三级封锁协议必然遵守两段锁协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h2><ul>
<li>封锁对象的大小称为封锁粒度</li>
<li>封锁对象：逻辑单元，物理单元<ul>
<li>逻辑单元：属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库</li>
<li>物理单元：页（数据页或索引页）、物理记录等</li>
</ul>
</li>
<li>封锁粒度与系统的并发度和并发控制的开销密切相关<ul>
<li>粒度越大，能够封锁的数据单元越少，并发度越小，系统开销越小</li>
</ul>
</li>
</ul>
<h3 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h3><ul>
<li>允许多粒度树中的每个节点被独立的加锁</li>
<li>对一个节点加锁以为着这个节点所有后裔节点页被加同样类型的锁</li>
</ul>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST_CS_组成原理整理</title>
    <url>/2024/07/06/HUST-CS-%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="计算机系统的性能评价"><a href="#计算机系统的性能评价" class="headerlink" title="计算机系统的性能评价"></a>计算机系统的性能评价</h2><h3 id="非时间指标"><a href="#非时间指标" class="headerlink" title="非时间指标"></a>非时间指标</h3><ul>
<li>机器字长<ul>
<li>机器一次性能够处理的二进制位数（一般于内部寄存器的位数相等）</li>
</ul>
</li>
<li>总线宽度<ul>
<li>数据总线一次能并行传送的最大信息位数</li>
</ul>
</li>
<li>主存容量与存储带宽<ul>
<li>容量：一台计算机主存包含的存储单元总数</li>
<li>带宽：单位时间内与贮存你交换的二进制信息量，Byte&#x2F;s</li>
</ul>
</li>
</ul>
<h3 id="时间指标"><a href="#时间指标" class="headerlink" title="时间指标"></a>时间指标</h3><ul>
<li>主频<ul>
<li>CPU工作的时钟频率，与CPU运算能力之间<strong>不是</strong>唯一的、直接关系</li>
</ul>
</li>
<li>时钟周期$T&#x3D;\frac{1}{f}$<ul>
<li>计算机中最基本的、最小的时间单位。一个时钟周期CPU仅完成一个最基本动作</li>
</ul>
</li>
<li>外频<ul>
<li>系统总线的工作频率，CPU与主板之间同步运行的速度</li>
</ul>
</li>
<li>倍频<ul>
<li>$主频&#x3D;外频 \times 倍频$</li>
</ul>
</li>
<li>CPI<ul>
<li>执行一条指令（平均）需要的始终周期数<br>$$CPI &#x3D; 一段程序中所有指令的始终周期之和&#x2F;指令条数 &#x3D; 程序中各类指令的CPI \times 程序中各类指令的比例 $$</li>
</ul>
</li>
<li>MIPS<ul>
<li>$$ MIPS &#x3D;  \frac{指令条数}{执行时间 \times 10^6} &#x3D; \frac{指令条数}{所有指令CPU始终周期数之和&#x2F;f \times 10^6} &#x3D; \frac{f}{CPI \times 10^6} &#x3D; IPC * f $$</li>
<li>程序执行时间<ul>
<li>$$ T_e &#x3D; \frac{指令条数}{MIPS \times 10^6} $$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第二章-数据信息的表示"><a href="#第二章-数据信息的表示" class="headerlink" title="第二章 数据信息的表示"></a>第二章 数据信息的表示</h1><h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2><h3 id="数的机器码表示"><a href="#数的机器码表示" class="headerlink" title="数的机器码表示"></a>数的机器码表示</h3><ul>
<li>真值： 带正负号的</li>
<li>机器码<ul>
<li>原码：<ul>
<li>区间$(-2^n, 2^n)$</li>
</ul>
</li>
<li>反码<ul>
<li>符号与原码相同，正数与原码相同，负数除符号位其它二进制位取反</li>
</ul>
</li>
<li>补码<ul>
<li>正数和原码相同，符号位为0</li>
<li>负数逐位取反，末位加1，符号位为1</li>
<li>特性：<ul>
<li>唯一0</li>
<li>区间：小数$[-1,1)$，整数$[-2^n, 2^n)$</li>
<li>非对称区间，左侧多一个数</li>
</ul>
</li>
<li>双符号位补码<ul>
<li>符号位01表示正溢出，10表示负溢出，最高位表示正确的符号位</li>
</ul>
</li>
</ul>
</li>
<li>移码<ul>
<li>$$ [x]_{mov} &#x3D; 2^n + x \quad -2^n &lt;&#x3D; x &lt;&#x3D; 2^n $$</li>
<li>与补码的符号位相异，数值位相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示"></a>定点数表示</h3><h4 id="C语言中的整数"><a href="#C语言中的整数" class="headerlink" title="C语言中的整数"></a>C语言中的整数</h4><ul>
<li>有符号和无符号共存时无符号优先</li>
<li>整数变量初始化<ul>
<li>先按照约定处理常量转换成机器码</li>
<li>根据变量长度进行强制转换，超出位数截断</li>
</ul>
</li>
</ul>
<h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3><ul>
<li>机器字长一定时，阶码越长，表示范围越大，精度越高（规格化）</li>
<li>阶码相同，尾数越长，精度越高</li>
<li>扩大了表示范围，未增加状态数</li>
<li>绝对值越大，浮点数分布越系数，运算不满足结合律</li>
</ul>
<h2 id="数据信息的校验"><a href="#数据信息的校验" class="headerlink" title="数据信息的校验"></a>数据信息的校验</h2><h3 id="码距与校验"><a href="#码距与校验" class="headerlink" title="码距与校验"></a>码距与校验</h3><ul>
<li>码距： 任意两个合法编码间不同的二进制位数</li>
<li>码距越大，抗干扰能力越、纠错能力越强，数据荣誉越大，编码效率越低</li>
<li>最小码距&gt;&#x3D;e+1<ul>
<li>可检测e个错误</li>
</ul>
</li>
<li>最小码距&gt;&#x3D;2t+1<ul>
<li>可纠正t个错误</li>
</ul>
</li>
<li>最小码距&gt;&#x3D;e+t+1<ul>
<li>可纠正t个错误，同时需要检测e个错误</li>
</ul>
</li>
</ul>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><ul>
<li>奇校验<ul>
<li>冗余位： 1位，检验位P</li>
<li>编码规则：校验码（数据+校验位）中的1的个数位奇数<br>$$ 偶校验：P &#x3D; D_1 \oplus D_2 \oplus D_3 \oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8 $$<br>$$ 奇校验：P &#x3D; \neg (D_1 \oplus D_2 \oplus D_3 \oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8) $$<br>$$ 检错码：G &#x3D; P \oplus D_1 \oplus D_2 \oplus D_3 \oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8 $$<br>G&#x3D;1：数据一定出错，否则较大概率正常</li>
</ul>
</li>
</ul>
<h4 id="奇偶校验性能"><a href="#奇偶校验性能" class="headerlink" title="奇偶校验性能"></a>奇偶校验性能</h4><p>识别奇数错，不能纠错，不保证正确，实现简单，编码效率高</p>
<h3 id="海明校验"><a href="#海明校验" class="headerlink" title="海明校验"></a>海明校验</h3><ul>
<li>多i个就教研组</li>
<li>既能检错，也能纠错</li>
<li>最小码距为3</li>
<li>最低位从1开始</li>
</ul>
<h4 id="可检一位错海明码"><a href="#可检一位错海明码" class="headerlink" title="可检一位错海明码"></a>可检一位错海明码</h4><ul>
<li>编码规则：分组交叉就检验法<ul>
<li>戴编码数据分成r个就校验组</li>
<li>r位校验位（冗余），生成r位检错码</li>
<li>各数据位至少参加2各校验组</li>
<li>一个数据位出错，可导致多个检错码为1</li>
</ul>
</li>
<li>检错纠错：检错码值表示出错位置（假设一位错）<ul>
<li>检错码全0，数据大概率正常，最低位是1开始</li>
<li>可检错，也可纠错，将出错位取反即可</li>
</ul>
</li>
</ul>
<p>(n,k)海明码共n位，其中数据位k位，校验位r位，<br>$$ n&#x3D;k+r &lt;&#x3D; 2^r -1 $$</p>
<h4 id="n-k-码校验分组设计方法"><a href="#n-k-码校验分组设计方法" class="headerlink" title="(n,k)码校验分组设计方法"></a>(n,k)码校验分组设计方法</h4><ul>
<li>校验码$P_i$放置在$H_{2^i-1}$索引处</li>
<li>数据位放在剩下的位置。</li>
<li>$H_i$的二进制表示的低$j$位为1，则$G_j$组需要包含$H_i$</li>
<li>$P_i$负责校验二进制表示的低$j$位为1的$H_j$的数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">  (8,4)码</span><br><span class="line">  P3 = H5 ^ H6 ^ H7 ^ H12</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="海明码特点"><a href="#海明码特点" class="headerlink" title="海明码特点"></a>海明码特点</h4><ul>
<li>编码效率高</li>
<li>可纠正一位错</li>
<li><strong>在假设没有三位错的情况下，如何区别一位还是两位错</strong><ul>
<li>引入总校验位</li>
<li>报错字&#x3D;1，总校验位&#x3D;1，一位错。</li>
<li>报错字&#x3D;1，总校验位&#x3D;0，两位错。</li>
</ul>
</li>
</ul>
<h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><ul>
<li>编码规则：编码可被生成多项式整除<ul>
<li>模2除法，余数为0（高概率正确），否则出错</li>
</ul>
</li>
<li>设CRC码为n位，其中数据位k位，校验位r位<ul>
<li>$$ n &#x3D; k + r &lt;&#x3D; 2^r -1 $$</li>
</ul>
</li>
</ul>
<h4 id="模2运算规则"><a href="#模2运算规则" class="headerlink" title="模2运算规则"></a>模2运算规则</h4><p>除法：余数首位为1，商上1，否则为0</p>
<h4 id="CRC编码规则"><a href="#CRC编码规则" class="headerlink" title="CRC编码规则"></a>CRC编码规则</h4><ul>
<li>将待编码的k位有效信息位组表达为多项式$M(x)$   <ul>
<li>$$ M(x) &#x3D; b_{k-1}x^{k-1} + b_{k-2}x^{k-2}+…+b_1x+b_0 \quad x&#x3D;2 $$</li>
</ul>
</li>
<li>将数据左移r位，空出r位校验（冗余位），变成 $M(x) \cdot x^r$</li>
<li>将 $M(x) \cdot x^r$ 除以生成多项式$G(x)$,商为$Q(x)$，余数$R(x)$<ul>
<li>$$ M(x) \cdot x^r &#x3D; Q(x) \cdot G(x) +R(x) $$</li>
</ul>
</li>
<li>将余数填充在校验位<ul>
<li>$$ M(x) \cdot x^r + R(x) &#x3D; Q(x) \cdot G(x) + R(x) + R(x) &#x3D; Q(x) \cdot G(x) $$</li>
</ul>
</li>
</ul>
<p>编码规则：CRC编码可被$G(x)$表示的编码整除</p>
<p><strong>出错</strong>：<br>当只有一位错的时候，余数的“1”在第几位，就说明是第几位处所。如余数<code>010000</code>，表示第5位出错。</p>
<h4 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h4><ul>
<li>生成多项式特征<ul>
<li>任意1位发生错误余数均不为0</li>
<li>不同位发生错误余数不同</li>
<li>余数左移一位继续作模2除，应使余数循环，循环周期$N&#x3D;k+r$</li>
</ul>
</li>
<li>如何产生生成多项式<ul>
<li>(n,k)码，将$X^n+1$分解为若干质因子</li>
<li>根据码距要求选择其中的因式或多个因式的成绩为生成多项式</li>
</ul>
</li>
</ul>
<blockquote>
<p>eg：<br>$$ x^7+1&#x3D;(x+1)(x^3+x+1)(x^3+x^2+1) $$<br>$G(x)$可以为多种取值<br>$G(x)&#x3D;x+1&#x3D;11$ (7,6)码，判一位错<br>$G(x)&#x3D;x^3+x+1&#x3D;1011$ 或 $G(x)&#x3D;x^3+x^2+1$ (7,4)码，两位错，一位错余数均不为0，但余数有重叠<br>$G(x)&#x3D;(x+1)(x^3+x+1)&#x3D;11101$<br>如果使用$G(x)&#x3D;1011$来编码<br>$$ 1100_2 &lt;&lt;3 \div &#x3D; 1110_2 \quad … \quad 010_2 $$<br>原始数据<code>1100</code>,编码后的数据<code>1100</code> <code>010</code></p>
</blockquote>
<h4 id="模2除法满足结合律"><a href="#模2除法满足结合律" class="headerlink" title="模2除法满足结合律"></a>模2除法满足结合律</h4><ul>
<li>两数的余数异或等于两数异或后的余数<ul>
<li>$$(M(x) % G(x)) \oplus (N(x)%G(x)) &#x3D; (M(x) \oplus N(x)) % G(x) $$</li>
</ul>
</li>
<li>利用模2除法的结合律可以实现并行CRC电路</li>
</ul>
<table>
<thead>
<tr>
<th align="left">串行CRC</th>
<th align="left">并行CRC</th>
</tr>
</thead>
<tbody><tr>
<td align="left">时序</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">多周期</td>
<td align="left">单周期</td>
</tr>
<tr>
<td align="left">慢</td>
<td align="left">块</td>
</tr>
<tr>
<td align="left">硬件少</td>
<td align="left">硬件多</td>
</tr>
</tbody></table>
<h4 id="CRC-n-k-码检错性能"><a href="#CRC-n-k-码检错性能" class="headerlink" title="CRC (n,k)码检错性能"></a>CRC (n,k)码检错性能</h4><p>$r&#x3D;n-k$</p>
<ul>
<li>所有小于等于r长度的突发错误<ul>
<li>突发错长度：第一和最后错位之间的距离</li>
</ul>
</li>
<li>$(1-2^{-r+1})$比例的$r+1$长度的突发错</li>
<li>$(1-2^{-r})$比例的大于$r+1$长度的突发错</li>
<li>所有小于最小码距的任意位数的错误</li>
<li>如果生成多项式中1的数目位偶数，可检测所有奇数错</li>
</ul>
<h1 id="第三章-运算方法与运算器"><a href="#第三章-运算方法与运算器" class="headerlink" title="第三章 运算方法与运算器"></a>第三章 运算方法与运算器</h1><h2 id="定点加减法运算"><a href="#定点加减法运算" class="headerlink" title="定点加减法运算"></a>定点加减法运算</h2><h3 id="溢出及检测"><a href="#溢出及检测" class="headerlink" title="溢出及检测"></a>溢出及检测</h3><ul>
<li>单符号数溢出检测1<ul>
<li>正正得负 负负得正</li>
<li>设量符号位为$f_0$$f_1$，和数符号位$f_s$</li>
<li>溢出检测信号<code>Overflow</code> &#x3D; $\hat f_0 \hat f_1 f_s + f_0f_1 \hat f_s$</li>
</ul>
</li>
<li>单符号溢出检测方法2<ul>
<li>符号位进位位$C_f$，最高位进位位$C_n$</li>
<li>$Overflow&#x3D;C_f \oplus C_n$</li>
</ul>
</li>
<li>双符号溢出检测方法<ul>
<li>$01$正溢出，$10$负溢出</li>
</ul>
</li>
</ul>
<h3 id="加减法的逻辑实现"><a href="#加减法的逻辑实现" class="headerlink" title="加减法的逻辑实现"></a>加减法的逻辑实现</h3><h4 id="一位全加器逻辑实现"><a href="#一位全加器逻辑实现" class="headerlink" title="一位全加器逻辑实现"></a>一位全加器逻辑实现</h4><p>$$ S_i &#x3D; X_i \oplus Y_i \oplus C_i $$<br>$$ C_{i+1} &#x3D; X_i Y_i + (X_i \oplus Y_i) C_i $$<br>得到$C_{i+1}$五级门电路延迟，得到$S_i$六级门电路延迟</p>
<h4 id="减法的球阀"><a href="#减法的球阀" class="headerlink" title="减法的球阀"></a>减法的球阀</h4><p>引入运算控制位<code>Sub</code><br><code>Sub</code>&#x3D;1时候做减法，送入加法器的是$[-Y_{补}]$<br>$$ Input &#x3D; Y_i \oplus Sub$$</p>
<h4 id="串行加法器时延"><a href="#串行加法器时延" class="headerlink" title="串行加法器时延"></a>串行加法器时延</h4><p>获得$C_n$的时间$(2n+3)T$，获得$S_{n-1}T$的时间$(2n+4)T$，获得<code>overflow</code>需要$(2n+6)T$</p>
<h4 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h4><p>$$ G_i &#x3D; X_i Y_i \qquad P_i &#x3D; X_i \oplus Y_i $$<br>$$ C_{i+1} &#x3D; G_i + P_i C_i $$<br>$$ C_n &#x3D; G_{n-1}+P_{n-1}G_{n-2} + P_{n-1}P_{n-2}G_{n-3}+…+P_{n-1}P_{n-2}…P_1P_0C_0 $$</p>
<ul>
<li>进位输出仅与最低位进位输入$C_0$有关</li>
<li>位数预测长，进位链电路复杂度越高</li>
<li>通常按照<em>4位一组</em>进行分组运算</li>
<li>$$ C_4 &#x3D; G_3 + P_3G_2+P_3P_2G_1+P_3P_2P_1G_0+P_3P_2P_1P_0C_0 $$</li>
<li>生成、传递函数电路就是普通的与门、异或门阵列，可以并行输出所有$G_i$$P_i$的值，3级门电路延迟</li>
<li>并行进位电路2级门电路延迟</li>
<li>进位信号得到后，求和值需要一级异或门延迟3T即可完成</li>
<li>4个一组时，最高位进位$C_4$延迟$5T$，结果$S_i$延迟$8T$</li>
<li>16位加法器，组内先行进位，组间串行进位，获得结果延迟$14T$,获得最高位进位延迟$11T$</li>
</ul>
<h4 id="成组进位生成-传递函数"><a href="#成组进位生成-传递函数" class="headerlink" title="成组进位生成&amp;传递函数"></a>成组进位生成&amp;传递函数</h4><p>$$ P^{<em>} &#x3D; P_3P_2P_1P_0 $$<br>$$ G_{</em>} &#x3D; G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0 $$<br>$$ C_4 &#x3D; G^{<em>} + P^{</em>}C_0 $$</p>
<p>16位先行进位<br>生成$P^{<em>},G^{</em>}$只需$5T$<br>生成$C_{12}$只需$2T$<br>计算进位$2T$,求和$3T$<br>总共12级门电路延迟</p>
<p>64位先行进位 –&gt; 16级门电路延迟</p>
<h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><p>$$ [X \times Y]_{原} &#x3D; X \times [Y_12^{-1}+Y_22^{-2}+…+Y_n2^{-n}] $$<br>从$Y$的最低位开始；$\sum$从0开始采用双符号位；$X$也采用双符号位；根据$Y_i$的值判断是加$X$还是加0。加完以后$\sum$,$X$,$Y$都逻辑右移。$\sum$可能瞬间溢出，但是移位后正常。最终结果是$\sum$加上移出的部分。</p>
<h4 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h4><p>$$ [X \times Y]<em>{补} &#x3D; [X]</em>{补} \times 0.Y_1Y_2…Y_n - Y_0[X]<em>{补} $$<br>$$ &#x3D; [X]</em>{补} \times [Y_1-Y_0+(Y_2-Y_1)2^{-1}+(Y_3-Y_2)2^{-2}+…(0-Y_n)2^{-n}] $$<br>大概类似原码乘法，也$\sum$和$X$也使用双符号位，但是在判断$\sum$是加什么出，如果$Y_nY_{n+1}$为10，则$\sum +-[-X]<em>{补}$;若$Y_nY</em>{n+1}$为01，$\sum +&#x3D; [X]_{补}$;其它情况则+0.右移仍然照做。</p>
<p><img src="/../img/HUST_CS_%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95.png" alt="补码乘法"><br>上面的右移是算数右移！</p>
<h4 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h4><p>横向进位乘法器<br>延迟会比斜向进位乘法器更高，但是设计简单。<br>两个五位数乘法，横向乘法进位器时延39T，但是斜向进位乘法进位器时延37T</p>
<p>斜向进位乘法器</p>
<ul>
<li>总共$n*(n-1)$个全加器</li>
<li>$(n-1) FA + (2(n-1)+4)T+T$，其中<code>FA</code>是全加器</li>
<li>$(8n-3)T$的时延</li>
</ul>
<h4 id="整数的乘运算"><a href="#整数的乘运算" class="headerlink" title="整数的乘运算"></a>整数的乘运算</h4><ul>
<li>硬件不判断溢出，保留2n位成绩，供软件使用</li>
<li>程序不判断溢出，编译器也不生成用于溢出处理的代码，会发生整数溢出问题</li>
</ul>
<h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><h4 id="恢复余数的除法"><a href="#恢复余数的除法" class="headerlink" title="恢复余数的除法"></a>恢复余数的除法</h4><p>被除数和除数都使用双符号位，先尝试减除数。如果余数小于0，则再加回余数，商为0。否则商为1.余数左移，然后再减除数。  </p>
<p>最后获得的余数是放大了的，商有几位，余数就需要乘$2^{-n}$。</p>
<h4 id="不恢复余数的除法"><a href="#不恢复余数的除法" class="headerlink" title="不恢复余数的除法"></a>不恢复余数的除法</h4><ul>
<li>第一次一定做减法</li>
<li>商$Q_n &#x3D; ~R_0$（余数符号位）</li>
<li>$R&#x3D;(R+(-1)^{Q_n}Y)*2$</li>
<li>最后仍然要余数缩小</li>
</ul>
<p>原码阵列除法器</p>
<p><code>FA</code>加上加减控制变成“可控制加、减法单元”<code>CAS</code>，时延9T<br>原码阵列除法器需要n<em>n个<code>CAS</code>,时延$n</em>n*9T$</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>浮点计算步骤：对阶、尾数运算、规格化、舍入、溢出判断</p>
<ul>
<li>对阶<ul>
<li>小阶对大阶 尾数右移</li>
</ul>
</li>
<li>运算结果规格化<ul>
<li>目的：保证浮点数的编码唯一性</li>
<li>形式：尾数非0时，要求绝对值&gt;&#x3D;0.5，尾数MSB&#x3D;1.否则修改阶码并移动尾数，使其满足要求</li>
<li>右规：右移实现规格化，阶码+</li>
<li>左规：左移实现规格化，阶码-</li>
</ul>
</li>
</ul>
<h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4><p>IEEE754在结果右边增加2个附加位</p>
<ul>
<li>保护位Guard：在最低有效位右边的位</li>
<li>舍入位Round：在保护位右边的位</li>
</ul>
<h3 id="浮点数乘法运算"><a href="#浮点数乘法运算" class="headerlink" title="浮点数乘法运算"></a>浮点数乘法运算</h3><ol>
<li>阶码相加</li>
</ol>
<ul>
<li>阶码相加可能产生溢出，要进行溢出判断</li>
</ul>
<ol start="2">
<li>尾数相乘</li>
</ol>
<ul>
<li>尾数相乘可得到积的尾数，可按定点乘法运算方法运算</li>
</ul>
<ol start="3">
<li>结果规格化</li>
</ol>
<h3 id="浮点数除法运算"><a href="#浮点数除法运算" class="headerlink" title="浮点数除法运算"></a>浮点数除法运算</h3><ol>
<li>尾数调整</li>
</ol>
<ul>
<li>如果被除数尾数大于除数尾数（绝对值），则将被除数尾数右移一位，阶码+1</li>
</ul>
<ol start="2">
<li>阶码求差</li>
</ol>
<ul>
<li>商的阶码等于被除数的阶码减去除数的阶码</li>
</ul>
<ol start="3">
<li>尾数相除</li>
</ol>
<h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><h3 id="运算器功能"><a href="#运算器功能" class="headerlink" title="运算器功能"></a>运算器功能</h3><ul>
<li>算数运算和逻辑运算<ul>
<li>运算电路</li>
</ul>
</li>
<li>暂存运算数据以及中间结果<ul>
<li>暂存器，通用寄存器</li>
</ul>
</li>
<li>选取数据参与运算<ul>
<li>多路选择、数据通路</li>
</ul>
</li>
<li>反应运算处理的状态<ul>
<li>程序状态字</li>
</ul>
</li>
</ul>
<h3 id="运算器与总线结构"><a href="#运算器与总线结构" class="headerlink" title="运算器与总线结构"></a>运算器与总线结构</h3><p>单总线结构的时候，完成一次<code>ADD R0, R1</code>,需要3个时钟周期。<br>分别是传入第一个操作数，传入第二个操作数，写回结果。</p>
<p>双总线+1个锁存器，2个时钟周期。<br>第一个周期取第一个操作数放到锁存器中。第二个周期传入第二个操作数以后获得结果就可以立刻写回了。因为第二个操作数走的总线是单独的。但是第一个操作数和写回结果走的总写是一条。</p>
<p>也可以第一个操作数和第二个操作数在第一个周期就同时传入ALU，但是结果先写到锁存器中。等第二个周期再写回通用寄存器中。</p>
<h1 id="第四章-存储系统"><a href="#第四章-存储系统" class="headerlink" title="第四章 存储系统"></a>第四章 存储系统</h1><h2 id="存储器概述（不重要）"><a href="#存储器概述（不重要）" class="headerlink" title="存储器概述（不重要）"></a>存储器概述（不重要）</h2><ul>
<li>按存取方式分<ul>
<li>随机存储器<ul>
<li>存取时间与物理位置无关</li>
<li>磁芯、半导体存储器</li>
</ul>
</li>
<li>顺序存储器<ul>
<li>存取内容只能按地址顺序访问</li>
<li>磁带</li>
</ul>
</li>
<li>直接存储器<ul>
<li>不必顺序访问，但是存取时间与物理位置有一定关系</li>
<li>磁盘（机械硬盘）、激光存储器</li>
<li>因为它自己可以寻址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h2><h4 id="存储器的刷新"><a href="#存储器的刷新" class="headerlink" title="存储器的刷新"></a>存储器的刷新</h4><ul>
<li>集中刷新<ul>
<li>刷新周期：2ms</li>
<li>在数据丢失之前集中刷新所有行</li>
<li>存在死区，用在实时要求不高的场合</li>
</ul>
</li>
<li>分散刷新<ul>
<li>最大刷新周期：2ms</li>
<li>存储周期：读写+刷新，各刷新周期分散安排在存取周期中</li>
<li>刷新次数 2ms&#x2F;100ns&#x3D;20000次，比较浪费，用在低速系统中</li>
</ul>
</li>
<li>异步刷新<ul>
<li>刷新周期：2ms，各刷新周期分散安排在2ms内</li>
<li>每隔2ms&#x2F;128&#x3D;15.5微妙刷新一行，将128次刷新分散</li>
<li>最常用</li>
</ul>
</li>
</ul>
<h3 id="半导体存储器的对比"><a href="#半导体存储器的对比" class="headerlink" title="半导体存储器的对比"></a>半导体存储器的对比</h3><table>
<thead>
<tr>
<th align="left">SRAM</th>
<th align="left">DRAM</th>
<th align="left">ROM</th>
<th align="left">PROM</th>
<th align="left">EPROM</th>
<th align="left">EEPROM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOS管</td>
<td align="left">电容</td>
<td align="left">开关</td>
<td align="left">熔丝</td>
<td align="left">浮置栅</td>
<td align="left">浮置栅</td>
</tr>
<tr>
<td align="left">快</td>
<td align="left">慢</td>
<td align="left">只读</td>
<td align="left">写一次</td>
<td align="left">高压写入</td>
<td align="left">高压写入</td>
</tr>
<tr>
<td align="left">6MOS</td>
<td align="left">1MOS+1C</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">紫外线擦</td>
<td align="left">控制栅极</td>
</tr>
<tr>
<td align="left">功耗高</td>
<td align="left">价格便宜</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">离线擦除</td>
<td align="left">在线电擦</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">动态刷新</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">擦后写</td>
<td align="left">擦后写</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">行列分开</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="主存的组织以及"><a href="#主存的组织以及" class="headerlink" title="主存的组织以及"></a>主存的组织以及</h2><h3 id="存储器扩展"><a href="#存储器扩展" class="headerlink" title="存储器扩展"></a>存储器扩展</h3><ul>
<li>字长扩展（数据总线扩展）<ul>
<li>各芯片并行工作</li>
</ul>
</li>
<li>字数扩展（地址总线扩展）<ul>
<li>同一时刻仅一芯片工作</li>
</ul>
</li>
</ul>
<h4 id="字长扩展-DBUG"><a href="#字长扩展-DBUG" class="headerlink" title="字长扩展(DBUG)"></a>字长扩展(DBUG)</h4><p>存储系统位宽N位，若使用k位芯片，k&lt;N,需要(N&#x2F;k)个芯片</p>
<h4 id="字数扩展-ABUS"><a href="#字数扩展-ABUS" class="headerlink" title="字数扩展(ABUS)"></a>字数扩展(ABUS)</h4><p>存储系统容量位M，若使用容量为I的芯片，I&lt;M，需要（M&#x2F;I）个芯片</p>
<h4 id="综合扩展"><a href="#综合扩展" class="headerlink" title="综合扩展"></a>综合扩展</h4><p>存储系统$M<em>N$位，若使用$I</em>k$位芯片，$I&lt;M,k&lt;N$,需要$(M&#x2F;I)*(N&#x2F;k)$个芯片</p>
<p><em>（大概是懂了这个类型的连线题怎么玩了）</em></p>
<h2 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h2><p>CPU与存储器之间的速度无法匹配</p>
<ul>
<li><p>解决方法</p>
<ul>
<li>增加Cache(行缓冲)</li>
<li>采用高速器件提高速度</li>
<li>采用双端口存储器</li>
<li>增加字长，单个存储周期存取多个字</li>
<li>将主存划分为多个模块，多模块并行</li>
</ul>
</li>
<li><p>多模块顺序存储器（存储扩展）</p>
<ul>
<li>一个地址寄存器</li>
<li>高位片选，多模块串行</li>
<li>扩容方便</li>
<li>性能无提升</li>
<li>方便故障隔离</li>
</ul>
</li>
<li><p>多模块交叉存储器</p>
<ul>
<li>模块并行工作</li>
<li>CPU比存储器要快</li>
<li>能同时取出多条指令或者数据</li>
<li>扩容、提速</li>
</ul>
</li>
</ul>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><h3 id="cache写操作流程"><a href="#cache写操作流程" class="headerlink" title="cache写操作流程"></a>cache写操作流程</h3><ul>
<li>写穿策略<ul>
<li>无脏数据，无丢失数据风险，写速度慢</li>
</ul>
</li>
<li>写回策略<ul>
<li>存在脏数据，有丢失数据风险，突发写速度快，持续写性能</li>
</ul>
</li>
</ul>
<h3 id="cache的基本概念"><a href="#cache的基本概念" class="headerlink" title="cache的基本概念"></a>cache的基本概念</h3><ul>
<li>命中：CPU访问数据在cache中（上层快存）</li>
<li>缺失：CPU访问数据不再cache中</li>
<li>块：cache与主存交换最小单位</li>
<li>行&#x2F;槽 Line&#x2F;Slot：标记、标志位、数据块容器<ul>
<li>有效位、查找标记、脏标志位、置换标志、数据块副本</li>
</ul>
</li>
<li>命中率、缺失率</li>
<li>命中访问时间<ul>
<li>数据查找时间、cache访问时间、总线传输时间</li>
</ul>
</li>
<li>缺失损失<ul>
<li>主存块调入cache，数据传输到处理器的时间</li>
<li>远大于命中时间，所以一些相对较小的时间可以忽略</li>
</ul>
</li>
<li>数据替换：cache满了以后进行替换</li>
<li>脏数据逐出：当一个cache已经被修改过，必须得写回到下一级存储器，才可以丢弃。</li>
</ul>
<h3 id="cache读写流程"><a href="#cache读写流程" class="headerlink" title="cache读写流程"></a>cache读写流程</h3><ul>
<li>CPU cache系统读过程<ul>
<li>CPU给出主存地址（块地址，块内地址）</li>
<li>主存块地址为关键字进行查找</li>
<li>如相符表示副本在cache中，命中，访问cahce</li>
<li>否则数据缺失，访问主存<ul>
<li>将数据所在块副本调入cache（块交换–局部性）</li>
<li>载入副本过程可能引起替换（时间长）</li>
<li>更新查找表，记录当前数据块地址</li>
<li>cache缺失时CPU只能挂起等待</li>
</ul>
</li>
</ul>
</li>
<li>CPU cache系统写过程<ul>
<li>CPU给出主存地址</li>
<li>主存块地址为关键字进行查找<ul>
<li>相符则表示命中，数据副本在cache中</li>
<li>缺失根据写分配策略决定是否将该主存地址对应数据块调入</li>
</ul>
</li>
<li>写入数据到cache</li>
<li>根据写策略决定是否写入主存</li>
</ul>
</li>
</ul>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><h4 id="数据查找"><a href="#数据查找" class="headerlink" title="数据查找"></a>数据查找</h4><h5 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h5><ul>
<li>按内容进行访问(key, value)<ul>
<li>以关键字作全局全局并发比较，硬件成本高（比较器多）</li>
<li>片外cache用于存放查找表</li>
<li>片外cache村南方查找表+数据副本</li>
<li>虚拟存储器中存放段表、页表</li>
</ul>
</li>
<li>存储容量&#x3D;查找表&#x2F;相联存储器容量&#x3D;表项数*表项大小<ul>
<li>(valid, key, value)</li>
<li>(有效位，主存块地址，cache块地址) （片外cache，存放查找表）</li>
<li>(有效位，主存块地址，cache块数据) （片内cache，存放查找表+数据副本）</li>
<li>(有效位， VPN, PPN)（虚拟存储器页表）</li>
</ul>
</li>
</ul>
<p>CPU cache基本组织方式</p>
<ul>
<li>CPU cache由SRAM构成</li>
<li>cache与主存均分为固定大小的数据块，以块为单位交换数据</li>
<li>相联存储器存放查找表&#x2F;cache<ul>
<li>表项：（有效位，调入cache的主存块地址，cache块地址&#x2F;块数据）</li>
<li>容量&#x3D;cache块数*表项大小</li>
</ul>
</li>
<li>CPU给出的块地址与查找表中某单元相同且有效位为1表示命中</li>
</ul>
<p>相连存储器容量</p>
<ul>
<li>查找表和缓存副本一体（CPU片内缓存）<ul>
<li>存放cache行</li>
<li>有效位，主存块地址，数据块副本，标志位（dirty bit），置换标记</li>
<li>存储容量&#x3D;cache行大小*行数</li>
</ul>
</li>
<li>查找表和缓存副本分离（片内查找表，片外缓存）<ul>
<li>存放查找信息</li>
<li>有效位，主存块地址，cache块地址，标志位（dikrty bit），置换标记</li>
<li>存储容量&#x3D;查找表表项大小*行数</li>
</ul>
</li>
</ul>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><h5 id="全相连映射"><a href="#全相连映射" class="headerlink" title="全相连映射"></a>全相连映射</h5><p>主存块可放置在任意cache行</p>
<p>cache8行，块大小4W，主存$2^9$W，cache总容量&#x3D;(valid+查找标记+脏位+置换标记位+数据块副本容量)*总行数</p>
<p>应用场合</p>
<ul>
<li>块映射灵活，一对多映射</li>
<li>cache满后才会出现块冲突</li>
<li>块冲突概率低，cache利用率高</li>
<li>淘汰算法复杂</li>
<li>命中率高</li>
</ul>
<h5 id="直接相连映射"><a href="#直接相连映射" class="headerlink" title="直接相连映射"></a>直接相连映射</h5><p>cache块号i，供n块，主存块号j，i&#x3D;j mod n</p>
<p>cache8行，块大小4W，主存$2^9$W，cache总容量&#x3D;(valid+查找标记位+标志位+数据块副本容量)*总行数</p>
<p>在全相连映射中，主存地址被解释为：区地址（tag）+行地址（索引，区内块偏移）+块内偏移</p>
<p>直接相连应用场合</p>
<ul>
<li>映射速度块，一对一映射，无需查表<ul>
<li>利用索引字段直接对比响应标记位即可</li>
<li>查找表可以和副本一起存放，无需相联存储器</li>
</ul>
</li>
<li>容易冲突，cache利用率低</li>
<li>替换算法简单</li>
<li>命中率低，适合大容量cache</li>
</ul>
<h5 id="组相连存储器硬件开销"><a href="#组相连存储器硬件开销" class="headerlink" title="组相连存储器硬件开销"></a>组相连存储器硬件开销</h5><ul>
<li>SRAM<ul>
<li>存放数据副本</li>
</ul>
</li>
<li>多个先练存储器共享一个多路比较器<ul>
<li>相对于全相连，多路比较器复杂度低</li>
<li>查找表表项内容（valid位，dirty位，查找标记，置换标记位）</li>
<li>相联存储器总容量<ul>
<li>cache行数*（1+1+查找标记位宽度+置换标记位）</li>
</ul>
</li>
</ul>
</li>
<li>片外缓存如果查找表在CPU内部<ul>
<li>查找表中必须增加cache行地址</li>
</ul>
</li>
</ul>
<p>cache8行，块大小4W，主存$2^9$W，cache总容量&#x3D;(valid+查找标记+脏位+置换标记位+数据块副本容量)*总行数</p>
<p>组相连映射中，主存地址被解释为：标记+组索引+块内偏移</p>
<p>组相连应用场合</p>
<ul>
<li>小容量cache可采用全相连映射或组相连映射</li>
<li>大容量cache可采用直接映射方式<ul>
<li>查找速度块，命中率相对低</li>
<li>但cache容量大可提高命中率</li>
<li>块设备缓存</li>
</ul>
</li>
</ul>
<h4 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h4><ul>
<li>先进先出FIFO<ul>
<li>可能会产生颠簸，不停的出和入</li>
</ul>
</li>
<li>最不经常使用算法LFU<ul>
<li>为缓存中的每一个数据记录是否被使用过，当需要替换的时候把使用次数最少的扔出去</li>
</ul>
</li>
<li>近期最久未使用算法LRU<ul>
<li>记录缓存中每个数据进入缓存的时间，如果hit了就归零重新记录，需要替换的时候把时间最久的扔出去</li>
</ul>
</li>
</ul>
<h4 id="写入策略"><a href="#写入策略" class="headerlink" title="写入策略"></a>写入策略</h4><ul>
<li>写回法</li>
<li>写穿法</li>
<li>写分配</li>
<li>写不分配</li>
</ul>
<h3 id="cache对存储系统性能的影响"><a href="#cache对存储系统性能的影响" class="headerlink" title="cache对存储系统性能的影响"></a>cache对存储系统性能的影响</h3><ul>
<li>读优化<ul>
<li>时间局部性<ul>
<li>将刚访问的数据调度到cache中，利用淘汰算法将不经常使用的数据淘汰</li>
</ul>
</li>
<li>空间局部性<ul>
<li>大块预读，相邻的数据被调度到cache中</li>
</ul>
</li>
</ul>
</li>
<li>写优化<ul>
<li>写回策略提升突发写性能</li>
</ul>
</li>
<li>负面影响<ul>
<li>写回策略引起不一致性</li>
<li>缓冲区满以后，写性能降低</li>
</ul>
</li>
</ul>
<h3 id="cache命中率"><a href="#cache命中率" class="headerlink" title="cache命中率"></a>cache命中率</h3><ul>
<li>命中率<ul>
<li>$N_c$表示cache完成存取访问的总次数</li>
<li>$N_m$表示主存完成存取访问的总次数</li>
<li>$h&#x3D;|frac{N_c}{N_c+N_m}$</li>
</ul>
</li>
<li>$t_a$表示平均访问时间<ul>
<li>$t_c$表示命中cache时的访问时间</li>
<li>$t_m$表示命中主存时的访问时间</li>
<li>$t_a&#x3D;ht_c+(1-h)t_m$</li>
</ul>
</li>
<li>访问效率&#x3D;$\frac{t_c}{t_a}$</li>
<li>影响命中率的几个因素<ul>
<li>程序行为（局部性） </li>
<li>cache容量</li>
<li>组织方式</li>
<li>块大小</li>
</ul>
</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><blockquote>
<p>为什么cache访问的时候使用的是物理地址而不是虚拟地址？<br>每个进程都使用相同的虚拟地址空间，不同进程相同虚拟地址对应的物理数据是不一样的，无法使用虚拟地址去cache中查找，导致不同进程切换时候可能会切换cache</p>
</blockquote>
<h3 id="虚拟地址到物理地址"><a href="#虚拟地址到物理地址" class="headerlink" title="虚拟地址到物理地址"></a>虚拟地址到物理地址</h3><p>当CPU要访问一个地址的时候，把虚拟地址给到MMU，MMU计算出PTEA以后给cache memeory（页表），获得对应的PTE，如果页命中，则MMU再把PA送给页表，页表取出对应物理地址处的数据送给CPU。如果页不命中，MMU抛出异常，等却也异常处理成功以后，程序会唤醒一场指令所在进程，重新再调用一次。</p>
<h3 id="使用TLB提高速度"><a href="#使用TLB提高速度" class="headerlink" title="使用TLB提高速度"></a>使用TLB提高速度</h3><p>MMU直接把VPN到TLB中查找，如果查找成功直接可以获得对应VA的PPN，然后根据PPN得到PA，发给页表让页表把对应数据给CPU</p>
<h1 id="第五章-指令系统"><a href="#第五章-指令系统" class="headerlink" title="第五章 指令系统"></a>第五章 指令系统</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><ul>
<li>操作码OP与地址码AC<ul>
<li>操作码字段长度决定指令系统规模<ul>
<li>每条指令对应一个操作码</li>
<li>定长操作码$Length_{OP}&#x3D;[log_2n]$</li>
<li>变长操作码 操作码向不用的地址码字段扩展</li>
</ul>
</li>
<li>操作数字段可能有多个<ul>
<li>寻址方式字段 长度与寻址方式种类有关，也可能隐含在操作码字段</li>
<li>地址码字段 作用以及影响、长度和寻址方式有关</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展操作码的条数的计算：<br>指令长度32位，操作数12位，剩下可以给操作码，双操作数、单操作数和无操作数<br>若双操作数有k条指令<br>单操作数$(2^8-k)\times2^{12}$，$2^{12}$是多余的12位组合</p>
</blockquote>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><h4 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h4><p>程序对应的机器指令序列在主存顺序存放。<br>执行时从第一条指令开始，逐条取出并执行。</p>
<ul>
<li>实现方式<ul>
<li>程序计数器对指令序号进行计数</li>
<li>PC存放吓一跳哈子i了那个地址,初始值为程序首地址</li>
<li>执行一跳指令,PC&#x3D;PC+当前指令字节长度</li>
</ul>
</li>
</ul>
<h4 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h4><p>当程序中出现分支或循环时,就会改变程序的执行顺序</p>
<ul>
<li>吓一跳指令地址不是PC++得到,而是由指令本身给出</li>
<li>跳跃的处理方式是重新修改PC的内容,然后进入取指令阶段</li>
</ul>
<h3 id="操作数寻址"><a href="#操作数寻址" class="headerlink" title="操作数寻址"></a>操作数寻址</h3><ul>
<li>立即寻址<ul>
<li>地址码字段是操作数本身(相当于不用寻址,直接就是操作数)</li>
</ul>
</li>
<li>直接寻址</li>
<li>间接寻址<ul>
<li>需要两次访存,速度慢,已经淘汰</li>
</ul>
</li>
<li>寄存器寻址</li>
<li>寄存器间接寻址</li>
<li>相对寻址</li>
<li>基址&#x2F;变址寻址</li>
<li>复合寻址</li>
</ul>
<h4 id="硬件堆栈"><a href="#硬件堆栈" class="headerlink" title="硬件堆栈"></a>硬件堆栈</h4><p>栈顶不动,数据移动,也能保证栈的结构</p>
<h3 id="x86系列支持多种寻址方式的意义"><a href="#x86系列支持多种寻址方式的意义" class="headerlink" title="x86系列支持多种寻址方式的意义"></a>x86系列支持多种寻址方式的意义</h3><ul>
<li>访问更大的存储空间</li>
<li>访问更大的数据</li>
<li>方便程序设计</li>
<li>提高指令执行速度（？）</li>
</ul>
<h2 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h2><ul>
<li>根据指令规模以及是否支持操作码扩展,确定操作码字段长度</li>
<li>根据对操作数的要求确定地址码字段的个数</li>
<li>根据寻址方式的要求,为各地址码字段确定寻址方式字段长度</li>
<li>定长还是变长</li>
</ul>
<h2 id="CISSC与RISC"><a href="#CISSC与RISC" class="headerlink" title="CISSC与RISC"></a>CISSC与RISC</h2><h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3><ul>
<li>指令条数少,只保留使用频率最高的简单指令,指令定长<ul>
<li>便于硬件实现,用软件实现复杂指令功能</li>
</ul>
</li>
<li>Load&#x2F;Store架构<ul>
<li>只有存&#x2F;取数指令才能访问存储器,区域指令的操作数都在寄存器之间进行</li>
<li>便于硬件实现</li>
</ul>
</li>
<li>指令长度固定,指令格式简单、寻址方式简单<ul>
<li>便于硬件实现</li>
</ul>
</li>
<li>寄存器数量多<ul>
<li>便于编译器实现</li>
</ul>
</li>
<li>一个机器周期完成一条机器指令</li>
<li>RISCCPU采用硬布线控制,CISC采用微程序</li>
</ul>
<h2 id="指令系统举例"><a href="#指令系统举例" class="headerlink" title="指令系统举例"></a>指令系统举例</h2><h3 id="MIPS32指令格式"><a href="#MIPS32指令格式" class="headerlink" title="MIPS32指令格式"></a>MIPS32指令格式</h3><ul>
<li>R型指令<ul>
<li>操作码(6)+源寄存器1(5)+源寄存器2(5)+目的寄存器(5)+偏移位移量(5)+扩展操作码(6)</li>
<li>无寻址方式字段,隐藏在操作码字段中</li>
</ul>
</li>
<li>I型指令<ul>
<li>OP(6)+$R_s$(5)+$R_t$(5)+Imm(16)</li>
</ul>
</li>
<li>J型指令<ul>
<li>OP(6)+Imm(26)</li>
</ul>
</li>
</ul>
<h1 id="第六章-中央处理器"><a href="#第六章-中央处理器" class="headerlink" title="第六章 中央处理器"></a>第六章 中央处理器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>CPU的主要功能(取指令并执行指令的部件)<ul>
<li>运算器<ul>
<li>数据加工:算数&#x2F;逻辑运算</li>
</ul>
</li>
<li>控制器<ul>
<li>程序控制:程序中指令执行顺序控制</li>
<li>操作控制:将机器指令翻译成执行部件所需操作控制信号</li>
<li>时序控制:控制操作信号产生的时间、持续时间</li>
<li>异常控制:异常处理、外设交互</li>
</ul>
</li>
</ul>
</li>
<li>CPU中重要寄存器<ul>
<li>PC–程序计数器</li>
<li>IR–指令寄存器(optional)</li>
<li>AR–地址寄存器(optional)</li>
<li>DR–数据缓冲寄存器(optional)</li>
<li>AC–累加寄存器(optional)</li>
<li>PSW–程序状态字(optional)</li>
</ul>
</li>
<li>操作控制器<ul>
<li>输入:机器指令</li>
<li>输出:控制信号序列</li>
<li>功能:循环取指、执行、处理异常<ul>
<li>将机器指令译码并生成执行部件所需的控制信号序列,控制信号按序传送至各个执行部件控点,引起逻辑门开闭,建立正确的数据通路,从而完成指令功能</li>
</ul>
</li>
<li>控制器分类<ul>
<li>应布线控制器(时序逻辑型)(硬件实现)</li>
<li>微程序控制器(存储程序型)(软件实现)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><h3 id="指令执行一般流程"><a href="#指令执行一般流程" class="headerlink" title="指令执行一般流程"></a>指令执行一般流程</h3><p>取指令(PC++)-&gt;指令译码-&gt;操作数地址计算-&gt;取操作数-&gt;数据操作指令执行-&gt;操作数地址计算-&gt;存操作数-&gt;(无中断)取指令<br>有中断,就等待中断响应,然后再取指令</p>
<h3 id="指令周期基本概念"><a href="#指令周期基本概念" class="headerlink" title="指令周期基本概念"></a>指令周期基本概念</h3><ul>
<li>时钟周期&#x3D;节拍脉冲&#x3D;震荡周期  能够完成一次微操作</li>
<li>机器周期 &#x3D; CPU周期  从贮存读出一跳指令的最短时间  可完成复杂操作</li>
<li>指令周期:从贮存取一跳指令并执行指令的时间<ul>
<li>取指令周期、执行指令周期 (间址周期、中断周期)</li>
<li>执行周期包含n个机器周期,机器周期包含k个节拍</li>
</ul>
</li>
</ul>
<h2 id="数据通路及指令操作流程"><a href="#数据通路及指令操作流程" class="headerlink" title="数据通路及指令操作流程"></a>数据通路及指令操作流程</h2><ul>
<li>数据通路–执行部件间传送信息的路径(数据流)<ul>
<li>通路的建立由控制信号控制,受时钟驱动(控制流)</li>
<li>不同指令、同一指令在执行的不同阶段的数据通路不同</li>
<li>共享通路(总线)、专用通路<ul>
<li>指令执行流程、执行效率</li>
<li>微操作控制信号的时序安排</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="D触发器定时模型"><a href="#D触发器定时模型" class="headerlink" title="D触发器定时模型"></a>D触发器定时模型</h4><ul>
<li>时钟触发前输入需要稳定一段时间(建立时间) setup time</li>
<li>时钟触发后输入需要稳定一段时间(保持时间) hold time</li>
<li>时钟触发到输出稳定的时间(触发器延迟) Clk_to_Q</li>
</ul>
<blockquote>
<p>时钟周期&gt;Clk_to_Q+关键路径时延+Setup time<br>Clk_to_Q+最短路径时延&gt;Hold time</p>
</blockquote>
<h2 id="时序与控制"><a href="#时序与控制" class="headerlink" title="时序与控制"></a>时序与控制</h2><h3 id="中央处理器时序"><a href="#中央处理器时序" class="headerlink" title="中央处理器时序"></a>中央处理器时序</h3><h4 id="传统三级时序"><a href="#传统三级时序" class="headerlink" title="传统三级时序"></a>传统三级时序</h4><ul>
<li>状态周期、节拍点位、节拍脉冲</li>
<li>状态周期数、节拍点位数、节拍脉冲数可变</li>
</ul>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><ul>
<li>同步控制<ul>
<li>机器周期数、节拍数固定—3机器周期*4节拍</li>
<li>机器周期数固定、节拍数不固定—3机器周期,取指&#x2F;计算&#x2F;执行 4&#x2F;2&#x2F;3节拍</li>
<li>大多数指令机器周期固定</li>
</ul>
</li>
<li>异步控制<ul>
<li>无时钟,应答机制</li>
</ul>
</li>
</ul>
<h3 id="时序发生器"><a href="#时序发生器" class="headerlink" title="时序发生器"></a>时序发生器</h3><h3 id="指令周期方框图"><a href="#指令周期方框图" class="headerlink" title="指令周期方框图"></a>指令周期方框图</h3><ul>
<li>取指周期<ul>
<li>PC-&gt;Ar, PC-&gt;X</li>
<li>X+4-&gt;Z</li>
<li>Z-&gt;PC, M[AR]-&gt;DR</li>
<li>DR-&gt;IR</li>
</ul>
</li>
<li>计算周期<ul>
<li>lw指令&amp;sw指令<ul>
<li>R[rs]-&gt;X</li>
<li>X+Imm-&gt;Imm</li>
</ul>
</li>
<li>beq指令<ul>
<li>R[rs]-&gt;X</li>
<li>X-R[rt]-&gt;PSW</li>
</ul>
</li>
<li>add&amp;addi不需要计算周期</li>
</ul>
</li>
<li>执行周期<ul>
<li>lw指令<ul>
<li>Z-&gt;AR</li>
<li>M[AR]-&gt;DR</li>
<li>DR-&gt;R[rt]</li>
</ul>
</li>
<li>sw指令<ul>
<li>Z-&gt;AR</li>
<li>R[rt]-&gt;DR</li>
<li>DR-&gt;M[AR]</li>
</ul>
</li>
<li>beq指令<ul>
<li>PC-&gt;X</li>
<li>IR(A)+X-&gt;Z</li>
<li>if(PSW&gt;equal) Z-&gt;PC</li>
</ul>
</li>
<li>add指令<ul>
<li>R[rs]-&gt;X</li>
<li>X+R[rt]-&gt;Z</li>
<li>Z-&gt;R[rd]</li>
<li>addi指令<ul>
<li>R[rs]-&gt;X</li>
<li>X+imm-&gt;Z</li>
<li>Z-&gt;R[rt]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="单总线MIPS-CPU典型指令"><a href="#单总线MIPS-CPU典型指令" class="headerlink" title="单总线MIPS CPU典型指令"></a>单总线MIPS CPU典型指令</h2><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">指令功能（RTL描述）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lw rt, imm(rs)</td>
<td align="left">R[rt] &lt;- M[R[rs]+SignExt(imm)]</td>
</tr>
<tr>
<td align="left">sw rt, imm(rs)</td>
<td align="left">M[R[rs]+SignExt(imm)]&lt;-R[rt]</td>
</tr>
<tr>
<td align="left">bewq rs, rt, imm</td>
<td align="left">if(R[rs]&#x3D;&#x3D;R[rt]) Pc&lt;-PC+4+SignExt(imm)&lt;&lt;2</td>
</tr>
<tr>
<td align="left">addi rt, rs, imm</td>
<td align="left">R[rt]&lt;-R[rs]+SignExt(imm)</td>
</tr>
<tr>
<td align="left">add rd, rs, rt</td>
<td align="left">R[rd]&lt;-R[rs]+R[rt]</td>
</tr>
</tbody></table>
<h3 id="取指令数据通路"><a href="#取指令数据通路" class="headerlink" title="取指令数据通路"></a>取指令数据通路</h3><table>
<thead>
<tr>
<th align="left">节拍</th>
<th align="left">数据通路（数据流）</th>
<th align="left">控制信号（控制流）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">PC-&gt;AR, PC-&gt;X</td>
<td align="left">$PC_{out},AR_{in},X_{in}$</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">X+4-&gt;Z</td>
<td align="left">+4</td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">Z-&gt;PC, M[AR]-&gt;DR</td>
<td align="left">$Z_{out},PC_{in},DRE_{in},Read$</td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left">DR-&gt;IR</td>
<td align="left">$DR_{out},IR_{in}$</td>
</tr>
</tbody></table>
<h3 id="lw指令执行数据通路"><a href="#lw指令执行数据通路" class="headerlink" title="lw指令执行数据通路"></a>lw指令执行数据通路</h3><table>
<thead>
<tr>
<th align="left">节拍</th>
<th align="left">数据通路（数据流）</th>
<th align="left">控制信号（控制流）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T5</td>
<td align="left">R[rs]-&gt;X</td>
<td align="left">$R_{out},X_{in}$</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">X+sExt(imm)-&gt;Z</td>
<td align="left">$IR(I){out}, ADD$</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">Z-&gt;AR</td>
<td align="left">$Z_{out},AR_{in}$</td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">M[AR]-&gt;DR</td>
<td align="left">$DRE_{in},Read$</td>
</tr>
<tr>
<td align="left">T9</td>
<td align="left">DR-&gt;R[rt]</td>
<td align="left">$DR_{out},R_{in}$</td>
</tr>
</tbody></table>
<h3 id="sw指令执行数据通路"><a href="#sw指令执行数据通路" class="headerlink" title="sw指令执行数据通路"></a>sw指令执行数据通路</h3><table>
<thead>
<tr>
<th align="left">节拍</th>
<th align="left">数据通路（数据流）</th>
<th align="left">控制信号（控制流）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T5</td>
<td align="left">R[rs]-&gt;X</td>
<td align="left">$R_{out},X_{in}$</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">X+sExt(imm)-&gt;Z</td>
<td align="left">$IR(I){out}, ADD$</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">Z-&gt;AR</td>
<td align="left">$Z_{out},AR_{in}$</td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">R[rt]-&gt;DR</td>
<td align="left">$R_{out},Rs&#x2F;Rt,DR_{in}$</td>
</tr>
<tr>
<td align="left">T9</td>
<td align="left">DR-&gt;M[AR]</td>
<td align="left">$DRE_{out}, Write$</td>
</tr>
</tbody></table>
<h3 id="beq指令数据通路"><a href="#beq指令数据通路" class="headerlink" title="beq指令数据通路"></a>beq指令数据通路</h3><table>
<thead>
<tr>
<th align="left">节拍</th>
<th align="left">数据通路（数据流）</th>
<th align="left">控制信号（控制流）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T5</td>
<td align="left">R[rs]-&gt;X</td>
<td align="left">$R_{out},X_{in}$</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">X-R[rt]-&gt;PSW</td>
<td align="left">$R_{out},Rs&#x2F;Rt,SUB,PSW_{in}$</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">PC-&gt;X</td>
<td align="left">$PC_{out},X_{in}$</td>
</tr>
<tr>
<td align="left">T8</td>
<td align="left">X+sExt(imm&lt;&lt;2)-&gt;Z</td>
<td align="left">$IR(A)_{out}, ADD$</td>
</tr>
<tr>
<td align="left">T9</td>
<td align="left">if(PSW.equal)Z-&gt;PC</td>
<td align="left">$Z_{out},PC_{in}&#x3D;PSW.equal$</td>
</tr>
</tbody></table>
<h3 id="I型运算类指令执行数据通路"><a href="#I型运算类指令执行数据通路" class="headerlink" title="I型运算类指令执行数据通路"></a>I型运算类指令执行数据通路</h3><table>
<thead>
<tr>
<th align="left">节拍</th>
<th align="left">数据通路（数据流）</th>
<th align="left">控制信号（控制流）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T5</td>
<td align="left">R[rs]-&gt;X</td>
<td align="left">$R_{out},X_{in}$</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">X+sExt(imm)-&gt;Z</td>
<td align="left">$IR(I)_{out}, ADD$</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">Z-&gt;R[rt]</td>
<td align="left">$Z_{out},R_{in}$</td>
</tr>
</tbody></table>
<h3 id="R型运算类指令执行数据通路"><a href="#R型运算类指令执行数据通路" class="headerlink" title="R型运算类指令执行数据通路"></a>R型运算类指令执行数据通路</h3><table>
<thead>
<tr>
<th align="left">节拍</th>
<th align="left">数据通路（数据流）</th>
<th align="left">控制信号（控制流）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T5</td>
<td align="left">R[rs]-&gt;X</td>
<td align="left">$R_{out},X_{in}$</td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left">X+R[rt]-&gt;Z</td>
<td align="left">$Rs&#x2F;Rt,R_{out}, ADD$</td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left">Z-&gt;R[rt]</td>
<td align="left">$Z_{out},R_{in},RegDst$</td>
</tr>
</tbody></table>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2><h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><ul>
<li>微程序是利用软件思想设计硬件的技术</li>
<li>将控制信号序列向程序一样存储起来<ul>
<li>控制信号序列分解为若干节拍</li>
<li>一个节拍的兵法信号编成一跳微指令</li>
<li>多个节拍对应多条微指令,形成一段微程序</li>
</ul>
</li>
<li>依据执行微程序即可生成控制信号序列<ul>
<li>指令取指执行-&gt;微程序执行-&gt;微指令执行-&gt;生成控制信号</li>
<li>软时序:一次执行微指令,时间信号有先后顺序</li>
</ul>
</li>
<li>存储技术和程序设计相结合,会比复杂时序逻辑设计</li>
</ul>
<h3 id="单总线CPU微指令构造"><a href="#单总线CPU微指令构造" class="headerlink" title="单总线CPU微指令构造"></a>单总线CPU微指令构造</h3><ul>
<li>操作控制字段:存储操作控制信号<ul>
<li>每一位对应一个控制信号,也称微命令,可同事给出多个操作信号</li>
</ul>
</li>
<li>顺序控制字段:用于控制微程序的执行顺序<ul>
<li>判别逻辑为零,下一条微指令地址从下址字段获取,否则按约定规则生成</li>
</ul>
</li>
</ul>
<h3 id="微命令编码"><a href="#微命令编码" class="headerlink" title="微命令编码"></a>微命令编码</h3><ul>
<li>简单直观，便于输出控制，微指令长度太长，控存容量大<ul>
<li>直接表示-&gt;编码表示（压缩互斥性微命令）</li>
<li>下址字段-&gt;计数器法 （$\mu$AR++,增加$P_{end}$判别位）</li>
<li>水平型-&gt;垂直型微指令（牺牲并行性）</li>
</ul>
</li>
</ul>
<h2 id="异常与中断处理"><a href="#异常与中断处理" class="headerlink" title="异常与中断处理"></a>异常与中断处理</h2><ul>
<li>内部异常（当前指令无法执行）<ul>
<li>故障fault<ul>
<li>由指令执行引起的异常，如未定义指令、越权指令、段故障、缺页故障、存储保护违例、数据未对齐、除数为0、浮点溢出、整数溢出等。</li>
<li>可恢复的故障，指令需恢复执行；不可恢复故障，程序被终止</li>
</ul>
</li>
<li>陷阱trap<ul>
<li>是一种事先被安排的“异常”时间，通过在程序中显式的调用陷阱指令触发异常，用于在用户态下调用操作系统内核程序，如系统调用、条件陷阱指令。</li>
</ul>
</li>
<li>终止<ul>
<li>随机出现的使CPU无法继续执行的硬件故障，和具体指令无关。如机器校验错、总线错误、异常处理中再次异常的双错等，此时当前程序无法继续执行，只能终止执行，由异常服务处理程序来重启系统。</li>
</ul>
</li>
</ul>
</li>
<li>外部中断（当前指令执行完毕）<ul>
<li>关中断<ul>
<li>临时禁止中断请求，使为了保障中断响应周期以及中断服务程序中保护现场操作的完整性</li>
</ul>
</li>
<li>保存断点<ul>
<li>保存将来返回被中断程序的位置，对于已经执行完毕的指令其断点是下一条指令的位置（可能不是顺序指令），对于缺页故障、段错等执行指令引起的故障异常，由于指令并没有执行，所以断点应该是异常指令的PC值</li>
</ul>
</li>
<li>中断识别<ul>
<li>根据当前的中断请求识别出中断来源，也就是发生了什么中断，并将对应中断的中断服务程序入口地址送程序计数器PC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第九章-输入输出系统"><a href="#第九章-输入输出系统" class="headerlink" title="第九章 输入输出系统"></a>第九章 输入输出系统</h1><h2 id="输入输出设备与特性"><a href="#输入输出设备与特性" class="headerlink" title="输入输出设备与特性"></a>输入输出设备与特性</h2><ul>
<li>异步性</li>
<li>实时性</li>
<li>独立性</li>
</ul>
<p>磁盘、网卡既能输入也能输出，就叫“输入输出设备”<br>键盘只能输入，就叫输入设备<br>只能输出就叫输出设备  </p>
<h3 id="输入-输出系统的组成与功能"><a href="#输入-输出系统的组成与功能" class="headerlink" title="输入&#x2F;输出系统的组成与功能"></a>输入&#x2F;输出系统的组成与功能</h3><ul>
<li>外部设备、接口部件、总线以及响应的管理软件统称为计算机的输入输出系统，简称IO系统<ul>
<li>I&#x2F;O硬件<ul>
<li>外设、控制器、I&#x2F;O接口、总线</li>
</ul>
</li>
<li>I&#x2F;O软件<ul>
<li>OSA无关库，设备无关库，驱动</li>
</ul>
</li>
</ul>
</li>
<li>主要功能<ul>
<li>完成计算机内部二进制信息与外部i多种信息形式间的交流</li>
<li>保证CPU能够正确选择I&#x2F;O设备并实现对其控制，与数据传输</li>
<li>利用数据缓冲、合适的数据传送方式，实现主机外设间速度匹配</li>
</ul>
</li>
</ul>
<h2 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h2><ul>
<li>I&#x2F;O接口：连接总线与I&#x2F;O设备的物理和逻辑界面<ul>
<li>既包括物理连接电路，也包括软件逻辑接口</li>
<li>所有设备均通过I&#x2F;O接口（总线接口）与总线相连</li>
<li>CPU使用设备地址经总线与I&#x2F;O接口通信访问I&#x2F;O设备</li>
<li>标准接口有利于提升I&#x2F;O系统的独立性，降低连接复杂度</li>
</ul>
</li>
<li>I&#x2F;O接口功能<ul>
<li>设备寻址</li>
<li>数据交互</li>
<li>设备控制</li>
<li>状态检测</li>
<li>数据缓冲</li>
<li>格式转换</li>
</ul>
</li>
<li>I&#x2F;O接口编址<ul>
<li>统一编址<ul>
<li>内存映射编址（Memory-mapped）</li>
<li>外设地址与内存地址统一编址，同一个地址空间</li>
<li>不需要设置专用的I&#x2F;O指令</li>
<li>采用访存指令访问外设，具体访问什么设备取决于地址</li>
</ul>
</li>
<li>独立编址<ul>
<li>端口映射编址（Port-mapped）</li>
<li>I&#x2F;O地址空间与主存地址空间相互独立</li>
<li>I&#x2F;O地址又称为I&#x2F;O端口</li>
<li>不同设备中的不同寄存器和存储器都又唯一的端口地址</li>
<li>使用I&#x2F;O指令访问外设</li>
</ul>
</li>
</ul>
</li>
<li>I&#x2F;O接口的软件<ul>
<li>现代计算机中用户必须通过操作系统间接访问设备，屏蔽设备细节，更加方便。</li>
<li>与OS无关的I&#x2F;O库（用户态）<ul>
<li>如C语言中的标准I&#x2F;O库stdio.h。用户程序主要通过调用I&#x2F;O库访问设备，方便程序在不同OS间移植</li>
</ul>
</li>
<li>与设备无关的OS调用库（内核态）<ul>
<li>open,read, write, seek,ioctl,close等</li>
</ul>
</li>
<li>独立的设备驱动程序（内核态）<ul>
<li>设备驱动程序是与设备相关的I&#x2F;O软件部分</li>
<li>不同设备对应不同的驱动程序</li>
<li>遵循具体设备的I&#x2F;O接口约定，包含设备接口细节</li>
</ul>
</li>
</ul>
</li>
<li>I&#x2F;O接口分类<ul>
<li>按数据传送方式<ul>
<li>并行</li>
<li>串行</li>
</ul>
</li>
<li>按接口的灵活性<ul>
<li>可编程接口</li>
<li>不可变成接口</li>
</ul>
</li>
<li>按通用性<ul>
<li>通用</li>
<li>专用</li>
</ul>
</li>
<li>按总线传输的通信方式<ul>
<li>同步</li>
<li>异步</li>
</ul>
</li>
<li>按访问外设的方式<ul>
<li>直接传送方式</li>
<li>程序控制方式</li>
<li>程序中断方式</li>
<li>DMA</li>
<li>通道处理机接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据传送控制方式"><a href="#数据传送控制方式" class="headerlink" title="数据传送控制方式"></a>数据传送控制方式</h2><ul>
<li>程序查询方式<ul>
<li>轮询</li>
<li>定时</li>
</ul>
</li>
<li>程序中断方式</li>
<li>直接内存访问方式</li>
<li>通道方式</li>
<li>外围处理机方式</li>
</ul>
<h2 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h2><h2 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><ul>
<li>提高了CPU的使用效率<ul>
<li>主动告知机制避免了反复查询设备状态</li>
<li>仍需要CPU占用（中断服务子程序运行时间+中断开销）</li>
</ul>
</li>
<li>适合随机出现的服务</li>
<li>需要专门的硬件</li>
<li>子程序与中断服务子程序的异同<ul>
<li>共同点：调用后要返回</li>
<li>差异：调用方式（显式&#x2F;随机），保存寄存器（中断更多），返回位置与方式（调用位置&#x2F;中断位置）</li>
</ul>
</li>
<li>当同时有多个中断的时候，要进行中断仲裁<ul>
<li>优先级高的先响应</li>
<li>CPU优先级随不同中断服务程序而改变<ul>
<li>执行某设备中断服务子程序，CPU优先级就与该设备的优先级一样</li>
</ul>
</li>
<li>单级中断与多重中断<ul>
<li>单级中断<ul>
<li>所有中断源同一个级别，离CPU近的优先级高</li>
<li>CPU处理某个中断时，不响应其它中断</li>
</ul>
</li>
<li>多重中断<ul>
<li>优先级高的中断可以打断优先级低的中断服务程序</li>
<li>中断嵌套</li>
</ul>
</li>
</ul>
</li>
<li>划分优先级的一般规律<ul>
<li>硬件故障中断属于最高级，其次是程序错误中断</li>
<li>非屏蔽中断优于可屏蔽中断</li>
<li>DMA请求优先于I&#x2F;O设备传送的中断请求</li>
<li>告诉设备优于低俗设备</li>
<li>输入设备的中断优于输出设备</li>
<li>实时设备优先于普通设备</li>
</ul>
</li>
<li>中断屏蔽：动态改变各设备的处理优先级</li>
</ul>
</li>
<li>中断识别（寻找入口地址）<ul>
<li>独立请求：向量中断<ul>
<li>将服务程序入口（中断向量）组织在中断向量表中；响应时由硬件直接产生中断号（向量地址），查中断向量表取得服务程序入口，转入响应服务程序。</li>
<li>硬件查询法</li>
</ul>
</li>
<li>中断共享：非向量中断<ul>
<li>将服务程序入口组织在查询程序中</li>
<li>响应时执行查询程序查询你中断源，查询特定端口GPIO识别中断源</li>
<li>程序识别（软件方法）</li>
</ul>
</li>
</ul>
</li>
<li>中断处理中的问题<ul>
<li>中断响应条件<ul>
<li>中断允许触发器IE&#x3D;1</li>
<li>对应的中断未被屏蔽</li>
<li>无更高优先级的DMA请求</li>
<li>中断嵌套必须优先级更高</li>
<li>指令已经执行完最后一个机器周期<ul>
<li>保证指令执行的完整性</li>
</ul>
</li>
</ul>
</li>
<li>保存现场，恢复现场<ul>
<li>中断程序用到的通用寄存器，EPC，屏蔽字</li>
<li>缺页异常的断点和外部中断断点不一致</li>
</ul>
</li>
<li>中断过程由软硬件结合完成</li>
</ul>
</li>
</ul>
<h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><ul>
<li>基本概念<ul>
<li>外设于主存间建立一个由硬件管理的数据通路（虚拟通路，还是通过系统总线）</li>
<li>CPU不介入外设于主存的数据传送操作</li>
<li>减少CPU开销，提升效率</li>
</ul>
</li>
<li>与CPU访存冲突<ul>
<li>停止CPU使用主存<ul>
<li>DMA传送数据时，CPU停止使用主存</li>
<li>一批数据传送结束后，DMA再交还主存使用权</li>
<li>DMA传送过程中，CPU处于等待状态</li>
</ul>
</li>
<li>DMA与CPU交替使用主存<ul>
<li>每个存储周期分成两段<ul>
<li>一段用于DMA访问主存</li>
<li>一段用于CPU访问主存</li>
</ul>
</li>
<li>无主存使用权移交过程</li>
</ul>
</li>
<li>周期挪用法<ul>
<li>DMA要求访问主存时，CPU暂停一个或多个存储周期。一个数据传送结束后，CPU继续运行</li>
<li>CPU现场没有变动，仅延缓了指令的执行</li>
<li>如发生访存冲突，DMA优先访问</li>
</ul>
</li>
</ul>
</li>
<li>DMA与程序中断的区别<ul>
<li>中断通过程序传送数据，DMA靠硬件实现</li>
<li>中断实际为两指令之间，DMA响应实际为两存储周期之间</li>
<li>中断不仅具有数据传送能力，还能处理异常事件。DMA只能进行数据传送。</li>
<li>DMA仅挪用了一个存储周期，不改变CPU现场。</li>
<li>DMA请求的优先级比中断请求高。CPU优先响应DMA请求，是为了避免DMA所连接的告诉外设丢失数据</li>
<li>DMA利用了中断的技术</li>
</ul>
</li>
</ul>
<h2 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h2><h2 id="常见I-O设备"><a href="#常见I-O设备" class="headerlink" title="常见I&#x2F;O设备"></a>常见I&#x2F;O设备</h2><h1 id="错题总结话术："><a href="#错题总结话术：" class="headerlink" title="错题总结话术："></a>错题总结话术：</h1><ul>
<li>从软硬协同的角度分析运算器提供硬件溢出检测机制的意义：<ul>
<li>硬件提供溢出检测后，程序员可以通过该溢出位判断溢出与否，而不再需要通过专门程序判断溢出，简化了程序设计，利于流水线CPU的高效运行。</li>
</ul>
</li>
<li>如果要将单周期CPU变成多周期，应该左什么变化<ul>
<li>将指令存储器和数据存储器合二为一；每个功能部件后增加一个缓冲器，如主存、寄存器堆、ALU等部件后都要增加</li>
</ul>
</li>
<li>如果多周期MIPS CPU采用微程序控制器，若要加入中断逻辑，应进行哪些扩展？<ul>
<li>微程序中需要增加中断隐指令的微程序，该微程序的功能是保存断点，修改PC地址为中断程序入口地址，微指令P字段需要再增加一位用于中断判断$P_{end}$，每条指令对应微程序最后一条指令的中断判断位为1，如果当前有中断请求信号，要进行分支跳转中断隐指令对应的微程序</li>
</ul>
</li>
<li>在定长指令周期三级时许总线CPU实验中，测试程序预期功能是在0x80的内存数据单元进行排序，请问这个排序是降序还是升序？（<strong>降序</strong>）是由符号比较还是无符号比较？（<strong>有符号比较</strong>）为什么实际Educoder平台上通关的结果是在0x00处进行内存的安源数据排序的，而且代码区部分代码会被覆盖？<ul>
<li>Z寄存器没有锁存控制，采用定长周期时，刚刚计算完的地址应该直接送AR，但是由于计算周期和执行周期之间插入了空周期，所以导致送入AR中的地址错误。</li>
</ul>
</li>
<li>如果要为CPU增加单级中断处理机制，需要增加哪些硬件单元，并叙述其功能。<ul>
<li>EPC：保存断点</li>
<li>中断使能寄存器IE：开关中断</li>
<li>中断识别控制逻辑：中断识别</li>
</ul>
</li>
<li>如果要为CPU增加单级中断处理机制，在软件以及软硬系统方面需要进行哪些修改。<ul>
<li>中断返回eret指令的支持</li>
<li>编写中断服务程序：保护线程、中断服务、恢复现场、中断返回</li>
</ul>
</li>
<li>CRC编码实验中，对16位汉字进行编码，选择生成多项式7位，余数6位，能够区分一位错和两位错，直接通过余数区分。</li>
</ul>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST-CS-系统结构整理</title>
    <url>/2025/06/24/HUST-CS-%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="体系结构的基础知识"><a href="#体系结构的基础知识" class="headerlink" title="体系结构的基础知识"></a>体系结构的基础知识</h1><h2 id="体系结构基本概念"><a href="#体系结构基本概念" class="headerlink" title="体系结构基本概念"></a>体系结构基本概念</h2><h3 id="计算机系统中的层次概念"><a href="#计算机系统中的层次概念" class="headerlink" title="计算机系统中的层次概念"></a>计算机系统中的层次概念</h3><ol>
<li>计算机系统 &#x3D; 软件 + 硬件&#x2F;固件</li>
<li>计算机语言由低级向高级发展：高一级语言的语句相对于低级语言功能更强，更便于应用，但又都以低级语言为基础</li>
<li>从计算机语言的角度，把计算机系统按系统功能划分成多层次结构</li>
</ol>
<table>
<thead>
<tr>
<th align="left">层次</th>
<th align="left">对应</th>
<th align="left">划分</th>
</tr>
</thead>
<tbody><tr>
<td align="left">6</td>
<td align="left">应用语言虚拟机</td>
<td align="left">软件</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">高级语言虚拟机</td>
<td align="left">软件</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">汇编语言虚拟机</td>
<td align="left">软件</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">操作系统虚拟机</td>
<td align="left">软件</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">机器语言（传统机器级）</td>
<td align="left">硬件或固件</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">微程序机器级</td>
<td align="left">硬件或固件</td>
</tr>
</tbody></table>
<h3 id="计算机体系结构定义"><a href="#计算机体系结构定义" class="headerlink" title="计算机体系结构定义"></a>计算机体系结构定义</h3><ol>
<li>计算机体系结构定义：程序员所看到的计算机属性，即概念性结构与功能特性</li>
<li>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同属性</li>
<li>透明性：在计算机技术中，对这种本来是存在的事物或属性，但从某种角度看又好像不存在</li>
<li>Amdahl提出的体系结构：传统机器级体系结构————即一般所说的机器语言，程序员所看到的传统机器级所具有的属性</li>
<li>对通用寄存器型机器，属性主要指<ol>
<li>数据表示（硬件能直接辨认和处理的数据类型）</li>
<li>寻址规则（最小寻址单元、寻址方式及其表示）</li>
<li>寄存器定义（各种寄存器的定义、数量和使用方式）</li>
<li>指令集（机器指令的操作类型和格式、指令间的排序和控制机构等）</li>
<li>中断系统（中断类型和中断响应硬件的功能等）</li>
<li>机器工作状态的定义切换（管态和目态等）</li>
<li>存储系统（主存容量、程序员可用的最大存储容量等）</li>
<li>信息保护（信息保护方式和硬件对信息保护的支持）</li>
<li>I&#x2F;O结构（I&#x2F;O连接方式、处理机&#x2F;存储器与I&#x2F;O设备间数据传送的方式和格式以及I&#x2F;O操作的状态等）<blockquote>
<p>经典计算机体系结构概念的实质<br>  计算机系统中软硬件界面的确定，界面之上是软件功能，界面之下是硬件和固件功能</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="计算机组成和计算机实现技术"><a href="#计算机组成和计算机实现技术" class="headerlink" title="计算机组成和计算机实现技术"></a>计算机组成和计算机实现技术</h3><ol>
<li>计算机组成：计算机体系结构的逻辑实现</li>
<li>计算机实现：计算机组成的物理实现</li>
</ol>
<p><strong>一种体系结构可以有多种组成</strong><br><strong>一种组成可以有多种物理实现</strong></p>
<ol start="3">
<li>系列机&#x2F;兼容机&#x2F;软件兼容<ol>
<li>系列机：在一个厂家内生产的具有相同体系结构，但具有不同组成和实现的一系列不同型号的机器</li>
</ol>
</li>
</ol>
<h3 id="计算机的分代和分类"><a href="#计算机的分代和分类" class="headerlink" title="计算机的分代和分类"></a>计算机的分代和分类</h3><ul>
<li><p>桌面计算机</p>
</li>
<li><p>服务器</p>
</li>
<li><p>物联网&#x2F;嵌入式计算机</p>
</li>
<li><p>个人移动装置</p>
</li>
<li><p>集群&#x2F;数据中心计算系统</p>
</li>
<li><p>Flynn分类法：按照指令流和数据流的多倍性特征对计算机系统进行分类</p>
<ul>
<li>指令流：机器执行的指令序列</li>
<li>数据流：由指令调用的数据序列，包括输入数据和中间结果</li>
<li>多倍性(multiplicity)：在系统性能瓶颈不见上同时处于同一执行阶段的指令或数据的最大可能个数</li>
</ul>
<ol>
<li>单指令流单数据流SISD – Single Instruction Stream Single Data Stream</li>
<li>单指令流多数据流SIMD – Single Instruction Stream Multiple Data Stream</li>
<li>多指令流单数据流MISD – Multiple Instruction Stream Single Data Stream</li>
<li>多指令流多数据流MIMD – Multiple Instruction Stream Multiple Data Stream</li>
</ol>
</li>
<li><p>SISD：传统顺序处理机</p>
<ul>
<li>包括单指令功能部件处理机，多功能部件处理机，流水线处理机————标量流水线处理机</li>
</ul>
</li>
<li><p>SIMD：</p>
<ul>
<li>包括并行处理机，阵列处理机，向量处理机，超标量处理机，超流水线处理机，即多个PU按一定的方式互联，在同一个CU控制下，并行的对多个数据进行处理</li>
</ul>
</li>
<li><p>MIMD：</p>
<ul>
<li>多处理机系统</li>
</ul>
</li>
<li><p>MISD：实际不存在</p>
</li>
</ul>
<h2 id="定量分析技术基础"><a href="#定量分析技术基础" class="headerlink" title="定量分析技术基础"></a>定量分析技术基础</h2><h3 id="性能设计和评测的基本原则"><a href="#性能设计和评测的基本原则" class="headerlink" title="性能设计和评测的基本原则"></a>性能设计和评测的基本原则</h3><h4 id="三条基本原则和方法"><a href="#三条基本原则和方法" class="headerlink" title="三条基本原则和方法"></a>三条基本原则和方法</h4><ol>
<li>大概率事件优先原则<ul>
<li>对于大概率时间（最常见的事件），赋予它优先的处理权和资源使用权，以获得全局的最优结果</li>
</ul>
</li>
<li>Amdahl定律<ul>
<li>加快某部件执行速度所获得的系统性能和加速比，受限于该部件在系统中所占的重要性</li>
</ul>
</li>
<li>程序局部性原理<ul>
<li>程序在执行时所访问地址的分布不是随机的，而是相对地簇聚；这种 簇聚包括指令和数据两部分<ul>
<li>程序的时间局部性：程序即将用到的信息很可能就是目前正在使用的信息</li>
<li>程序的空间局部性：程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h4><p>系统中某一部件由于采用某种更快的执行方式后整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关</p>
<h5 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h5><p>$$ 系统加速比 &#x3D; \frac{系统性能_{改进后}}{系统性能_{改进前}} &#x3D; \frac{总执行时间_{改进前}}{总执行时间_{改进后}} $$</p>
<ul>
<li>系统加速比依赖于两个因素<ul>
<li>可改进比例：可改进部分在原系统计算时间中所占的比例，它总是小于等于1</li>
<li>部件加速比：可改进部分改进以后的性能提高，一般情况下它是大于1的<br>$$ 总执行时间_{改进后} &#x3D; 不可改进部分的执行时间 + 可改进部分改进后的执行时间 $$<br>$$ 总执行时间_{改进后} &#x3D; (1 - 可改进比例) \times 总执行时间_{改进前} + \frac{可改进比例 \times 总执行时间_{改进前}}{部件加速比} $$<br>$$ \qquad &#x3D; [(1 - 可改进比例) + \frac{可改进比例}{部件加速比}] \times 总执行时间_{改进前} $$<br>$$ 系统加速比 &#x3D; \frac{总执行时间_{改进前}}{总执行时间_{改进后}} &#x3D; \frac{1}{(1-可改进比例) + \frac{可改进比例}{部件加速比}} $$</li>
</ul>
</li>
</ul>
<p>$Fe &#x3D; \frac{可改进部分占用的时间}{改进前整个任务的执行时间}$，它总小于1  </p>
<p>$Se &#x3D; \frac{改进前改进部分的执行时间}{改进后改进部分的执行时间}$，它总大于1</p>
<p>改进后整个任务的执行时间为:<br>$$ T_n &#x3D; T_0 \cdot (1 - Fe + \frac{Fe}{Se}) $$<br>其中$T_0$为改进前的整个任务的执行时间</p>
<p>改进后整个系统的加速比为:<br>$$ S_n &#x3D; \frac{T_0}{T_n} &#x3D; \frac{1}{(1-Fe) + \frac{Fe}{Se}} $$<br>其中，$(1-Fe)$表示不可改进部分，当$Se -&gt; \inf$时， $S_n &#x3D; \frac{1}{1-Fe}$。因此可改进极限受Fe的约束</p>
<p>当存在多个部件的时候<br>$$ S &#x3D; \frac{1}{(1 - \sum_i f_i) + \sum_i \frac{f_i}{S_i}} $$</p>
<ul>
<li>加速比$S_n$和可增强性能部分$F_e$的关系<ul>
<li>为使系统能获得较高性能加速比，则可曾倩部分必须占有较大的比例；否则，增强该功能就没有多大意义</li>
</ul>
</li>
</ul>
<h5 id="性能递减规则"><a href="#性能递减规则" class="headerlink" title="性能递减规则"></a>性能递减规则</h5><p>如果仅仅对计算机中的一部分做性能改进，则改进越多，系统获得的改进效果越来越不明显</p>
<p>推论：如果只针对整个任务的一部分进行优化，那么所获得的加速比不大于$\frac{1}{1-F_e}$</p>
<h4 id="CPU的性能"><a href="#CPU的性能" class="headerlink" title="CPU的性能"></a>CPU的性能</h4><ol>
<li>将程序执行的时间进行分解<ol>
<li>计算机工作的时钟频率：计算机系统中于实现技术和工艺有关的因素。单位是MHz(f)</li>
<li>总时钟周期数：程序执行的cpu时间————CPU时间&#x3D;总时钟周期数 &#x2F; 时钟频率</li>
</ol>
</li>
<li>指令时钟数CPI(Cycles Per Instruction)<ul>
<li>一个与计算机体系结构有关的参数</li>
<li>$CPI &#x3D; \frac{总时钟周期数}{IC}$ </li>
<li>IC：程序执行过程中所处理的指令数</li>
</ul>
</li>
<li>程序执行的CPU时间可以写成<ul>
<li>$总CPU时间 &#x3D; CPI \times IC \div 时钟频率$  </li>
<li>$总CPU时间 &#x3D; CPI \times IC \times CT$</li>
<li>CPI：反映了计算机实现技术、计算机指令集结构和计算机组织</li>
<li>IC：反映了计算机指令的结构和编译技术</li>
<li>时钟频率&#x2F;时钟周期时间反映了计算机实现技术、生产工艺和计算机组织</li>
</ul>
</li>
<li>对CPU性能进行进一步细化<ul>
<li>$CPI_i$：对第i种指令的处理时间</li>
<li>$IC_i$：在程序中第i种指令出现的次数</li>
<li>程序执行时间：$CPU时间 &#x3D; \sum _{i &#x3D; 1}^{n}(CPI_i \times IC_i) \div 时钟频率$</li>
<li>$CPI &#x3D; \frac{\sum <em>{i &#x3D; 1}^nb (CPI_i \times IC_i)}{IC} &#x3D; \sum</em>{i&#x3D;1}^n (CPI_i \times IC_i \div IC)$</li>
<li>其中，$IC_i\div Ic$反映了第i中指令在程序中所占的比例</li>
</ul>
</li>
</ol>
<ul>
<li>性能优化<ul>
<li>独立的性能优化技术<ul>
<li>编译优化</li>
<li>高级电路或架构</li>
</ul>
</li>
<li>非独立的性能优化技术<ul>
<li>减少指令数量</li>
<li>降低CPI</li>
<li>减少周期时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="计算机性能的评测"><a href="#计算机性能的评测" class="headerlink" title="计算机性能的评测"></a>计算机性能的评测</h4><ul>
<li>任务执行时间<ul>
<li>可被观察、被测量，是评估一个系统性能的核心指标，其快慢是用户最能直观感受到的服务体验</li>
<li>响应时间、服务时间、处理延迟等</li>
</ul>
</li>
<li>任务是相对的<ul>
<li>应用程序，I&#x2F;O请求</li>
</ul>
</li>
<li>通过任务执行时间相对快慢来评价系统的性能高低</li>
<li>任务吞吐率<ul>
<li>单位时间内完成的任务总数</li>
<li>网络：每秒位数(bps)；存储设备：MB&#x2F;s或IOPS；数据库：每秒查询数(QPS)</li>
</ul>
</li>
<li>实际吞吐率依赖于工作负载行为<ul>
<li>服务装置通常是被被动接受并处理任务</li>
<li>单位时间内任务发送数量称之为负载强度</li>
<li>不断增加负载强度到一定值之后，服务装置实际吞吐率不会再增加，这个吞吐率称之为峰值吞吐率，也被称为处理容量或带宽</li>
<li>峰值吞吐率或者带宽是系统内在禀性的反映</li>
<li>如果系统只能穿行执行任务，则平均吞吐率就是平均执行实现的倒数</li>
</ul>
</li>
<li>响应时间和吞吐率<ul>
<li>相同点：都认为能够以最短时间完成任务的计算机就是最快的</li>
<li>不同点：响应时间针对单任务，吞吐率针对多任务</li>
</ul>
</li>
</ul>
<h2 id="计算机体系结构的发展"><a href="#计算机体系结构的发展" class="headerlink" title="计算机体系结构的发展"></a>计算机体系结构的发展</h2><h3 id="冯诺依曼结构及其改进"><a href="#冯诺依曼结构及其改进" class="headerlink" title="冯诺依曼结构及其改进"></a>冯诺依曼结构及其改进</h3><ul>
<li>存储程序原理的基本点：指令驱动<ul>
<li>程序预先存放再计算机存储器中，机器一旦启动，就能按照程序指定的逻辑顺序执行这些程序，自动完成由程序所描述的处理工作</li>
</ul>
</li>
<li>冯诺依曼结构的主要特点<ul>
<li>计算机以运算器为中心</li>
<li>在存储器中，指令和数据同等对待<ul>
<li>指令和数据一样可以进行运算，即由指令组成的程序是可以修改的</li>
</ul>
</li>
<li>存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的</li>
<li>指令的执行是顺序的<ul>
<li>一般是按照指令在存储器中存放的顺序执行</li>
<li>程序的分支由转移指令实现</li>
<li>由指令计数器PC指明当前正在执行的指令在存储器中的地址</li>
</ul>
</li>
<li>指令由操作码和地址吗组成</li>
<li>指令和数据均以二进制编码表示，采用二进制运算</li>
</ul>
</li>
<li>对系统结构进行的改进<ul>
<li>输入&#x2F;输出方式的改进<ul>
<li>程序控制<ul>
<li>程序等待</li>
<li>程序中断</li>
</ul>
</li>
<li>DMA<ul>
<li>成组传递</li>
<li>周期挪用</li>
</ul>
</li>
<li>I&#x2F;O处理机<ul>
<li>通道</li>
<li>外围处理机</li>
</ul>
</li>
</ul>
</li>
<li>采用并行处理技术</li>
<li>存储器组织结构的发展<ul>
<li>相联存储器与相联处理机</li>
<li>通用寄存器组</li>
<li>高速缓冲存储器Cache</li>
</ul>
</li>
<li>指令系统的发展<ul>
<li>复杂指令集计算机CISC</li>
<li>精简指令集计算机RISC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="计算机系统结构中并行性的发展"><a href="#计算机系统结构中并行性的发展" class="headerlink" title="计算机系统结构中并行性的发展"></a>计算机系统结构中并行性的发展</h2><h3 id="并行性的概念"><a href="#并行性的概念" class="headerlink" title="并行性的概念"></a>并行性的概念</h3><ul>
<li>并行性<ul>
<li>计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作。——只要在时间上相互重叠，就存在并行性</li>
</ul>
</li>
<li>同时性：两个或两个以上的事件在同一时刻发生</li>
<li>并发性：两个或两个以上的事件在同一时间间隔内发生</li>
<li>从处理数据的角度来看，并行性等级从低到高可分为<ul>
<li>字串位串：每次只对一个字的一位进行处理：最基本的串行处理方式，不存在并行性</li>
<li>字串位并：同时对一个自的全部位进行处理，不同字之间是串行的 —— 开始出现并行性</li>
<li>字并位串：同时对许多字的同一位（称为位片）进行处理 —— 具有较高的并行性</li>
<li>全并行：同时对许多字的全部位或部分位进行处理 —— 最高一级的并行</li>
</ul>
</li>
<li>从执行程序的角度来看，并行性等级从低到高可分为<ul>
<li>指令内部并行：单挑指令中各微操作之间的并行</li>
<li>指令级并行：并行执行两条或以上的指令</li>
<li>线程级并行：并行执行两个或以上的线程 —— 通常是一个进程内派生的多个线程为调度单位</li>
<li>任务级或过程级并行：并行执行两个或以上的过程或任务（程序段）—— 以子程序或进程为调度单元</li>
<li>作业或程序级并行：并行执行两个或以上的作业或程序</li>
</ul>
</li>
</ul>
<h3 id="提高并行性的技术途径"><a href="#提高并行性的技术途径" class="headerlink" title="提高并行性的技术途径"></a>提高并行性的技术途径</h3><ul>
<li>时间重叠<ul>
<li>引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度</li>
</ul>
</li>
<li>资源重复<ul>
<li>引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能</li>
</ul>
</li>
<li>资源共享<ul>
<li>一种软件方法，使多个任务按照一定时间顺序轮流使用同一套硬件设备</li>
</ul>
</li>
</ul>
<h3 id="单片系统中并行性的发展"><a href="#单片系统中并行性的发展" class="headerlink" title="单片系统中并行性的发展"></a>单片系统中并行性的发展</h3><ul>
<li>在发展高性能单处理机过程中，起主导作用的是时间重叠原理<ul>
<li>实现时间重叠的基础：部件功能专用化<ul>
<li>把一件工作按功能分割为若干相互联系的部分</li>
<li>把每一部分指定给专门的部件完成</li>
<li>然后按时间重叠原理把各部分的执行过程在时间上重叠起来，使所有部件依次分工完成一组同样的工作</li>
</ul>
</li>
</ul>
</li>
<li>在单处理机中，资源重复原理的运用也已十分普遍<ul>
<li>多体存储器</li>
<li>多操作部件<ul>
<li>通用部件被分解为若干个专用部件，如加法、乘法、触发、逻辑运算部件等，而且同一种部件也可以重复设置多个</li>
<li>如果指令所需的操作部件空闲，就可以开始执行这条指令（操作数已经准备好）。实现了指令级并行</li>
</ul>
</li>
<li>阵列处理机（并行处理器）<ul>
<li>设置许多相同的处理单元，让它们在同一个控制器的指挥下，按照同一条指令的要求，对向量或数组的各元素同时进行同一操作，就形成了阵列处理机</li>
<li>在单处理机中，资源共享的概念实质上是用单处理机模拟多处理机的功能，形成所谓虚拟机的概念</li>
<li>分时系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多机系统中并行性的发展"><a href="#多机系统中并行性的发展" class="headerlink" title="多机系统中并行性的发展"></a>多机系统中并行性的发展</h3><ul>
<li>多机系统遵循时间重叠、资源重复、资源共享原理，发展为3中不同的多处理机<ul>
<li>同构型多处理机、异构型多处理机、分布式系统</li>
</ul>
</li>
<li>耦合度<ul>
<li>反映多机系统中各机器之间物理连接的紧密程度和交互作用能力的强弱</li>
<li>紧密耦合系统（直接耦合系统）：在这种系统中，计算机之间的物理连接的频带较高，一般是铜鼓哦总线或告诉开关互联，可以共享主存</li>
<li>松散耦合系统（简介耦合系统）：一般是铜鼓哦通道或通信线路实现计算机之间的互联，可以共享外存设备（磁盘、磁带等）。机器之间的相互作用是在文件或数据集一级上进行<ul>
<li>表现为两种形式</li>
<li>多台计算机和共享的外存设备连接，不同机器之间实现功能上的分工（功能专用化），机器处理的结果以文件或数据集的形式发送到共享外存设备，供其它机器继续处理</li>
<li>计算机网，通过通信线路连接，实现更大范围的资源共享</li>
</ul>
</li>
</ul>
</li>
<li>功能专用化（实现时间重叠）<ul>
<li>专用外围处理机：e.g. 输入&#x2F;输出功能的分离</li>
<li>专用处理机：e.g. 数组运算、高级语言翻译、数据库管理等，分离出来</li>
<li>异构型多处理机系统<ul>
<li>由于多个不同类型、至少担负不同功能的处理机组成，它们按照作业要求的顺序，利用时间重叠原理，一次对它们的多个任务进行加工，各自完成规定的功能动作</li>
</ul>
</li>
</ul>
</li>
<li>机间互联<ul>
<li>容错系统</li>
<li>可重构系统</li>
<li>同构型多处理机系统</li>
</ul>
</li>
</ul>
<h1 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>流水线技术<ul>
<li>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现</li>
<li>把多个处理过程在时间上错开，一次通过各功能段，这样，每个子过程就可以与其它的子过程并行进行</li>
</ul>
</li>
<li>流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度</li>
<li>浮点加法流水线示例<ul>
<li>把流水线技术应用于运算的执行过程，就形成了运算操作流水线，也称为部件级流水线</li>
<li>把浮点加法的全过程分解为求阶差、对阶、尾数相加、规格化四个子过程</li>
<li>理想情况，提高3倍速度</li>
</ul>
</li>
<li>时-空图<ul>
<li>时-空图从时间和空间两个方面描述了流水线的工作过程。</li>
<li>时-空图中，横坐标代表时间，纵坐标代表各流水线的各个段</li>
</ul>
</li>
<li>流水技术的特点<ul>
<li>流水线把一个处理过程分解为若干个子过程（段），每个子过程由一个专门的功能部件来实现</li>
<li>流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流<ul>
<li>时间最长的段将称为流水线的瓶颈</li>
</ul>
</li>
<li>流水线每一个段的后面都要由一个缓冲寄存器（锁存器），称为流水寄存器<ul>
<li>作用：在相邻的两段之间传送数据，以供后面要用到的信息，并把各段的处理工作相互隔离</li>
</ul>
</li>
<li>流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率</li>
<li>流水线需要由通过时间和排空时间<ul>
<li>通过时间：第一个任务从进入流水线到流出结果所需的时间</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><ul>
<li>部件级、处理机级及处理机间流水线（按照流水技术用与计算机系统的等级不同）<ul>
<li>部件级流水线（运算操作流水线）：把处理机中的部件分段，再把这些分段相互连接起来，使得各种类型的运算操作都能够按照流水方式进行</li>
<li>处理机级流水线（指令流水线）：把指令的执行过程按照流水方式处理。把每一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行</li>
<li>系统级流水线（宏流水线）：把多台处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分</li>
</ul>
</li>
<li>单功能流水线与多功能流水线<ul>
<li>单功能流水线：只能完成一种固定功能的流水线</li>
<li>多功能流水线：流水线的各段可以进行不同的连接，以实现不同的功能</li>
</ul>
</li>
<li>静态流水线与动态流水线（按照同一时间内各段之间的连接方式对多功能流水线作进一步的分类）<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作<ul>
<li>对于静态流水线来说，只有当输入的是统一穿相同的运算任务时候流水线的效率才能得到充分的发挥</li>
</ul>
</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式hi链接，同时执行多种功能<ul>
<li>优点：灵活，能够提高流水线各段的使用率，从而提高处理速度</li>
<li>缺点：控制复杂</li>
</ul>
</li>
</ul>
</li>
<li>线性流水线与非线性流水线（按照流水线中是否由反馈回路来进行分类）<ul>
<li>线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次</li>
<li>非线性流水线：流水线中除了有串行的连接外，还有反馈回路</li>
<li>非线性流水线的调度问题：确定什么时候向流水线引进新的任务，才能使该任务不会与先前进入流水线的任务发生冲突——争用流水段</li>
</ul>
</li>
<li>顺序流水线与乱序流水线（根据任务流入和流出的顺序是否相同来进行分类）<ul>
<li>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的</li>
<li>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）</li>
</ul>
</li>
</ul>
<h2 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h2><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>吞吐率： 在单位时间内流水线所完成的任务数量或输出结果的数量<br>$$ TP &#x3D; \frac{n}{T_k} $$</p>
<h5 id="各段时间均相等的流水线"><a href="#各段时间均相等的流水线" class="headerlink" title="各段时间均相等的流水线"></a>各段时间均相等的流水线</h5><ul>
<li>流水线完成n个连续任务所需要的总时间为(假设一条k段线性流水线)$T_k &#x3D; k \Delta t + (n-1) \Delta t &#x3D; (n + k - 1) \Delta t$</li>
<li>流水线的实际吞吐率$TP &#x3D; \frac{n}{(n + k - 1) \Delta t}$</li>
<li>最大吞吐率$TP_{max} &#x3D; lim_{n -&gt; \infty} \frac{n}{(n + k - 1) \Delta t} &#x3D; \frac{1}{\Delta t}$</li>
<li>最大吞吐率与实际吞吐率的关系$TP &#x3D; \frac{n}{n + k - 1}TP_{max}$</li>
<li>流水线的实际吞吐率小于最大吞吐率，它除了与每个段的时间有关外，还与流水线的段数k以及输入到流水线中的任务n有关</li>
<li>只有当$n &gt;&gt; k$时，才有$TP \approx TP_{max}$</li>
</ul>
<h5 id="各段时间不完全相等的流水线"><a href="#各段时间不完全相等的流水线" class="headerlink" title="各段时间不完全相等的流水线"></a>各段时间不完全相等的流水线</h5><p>实际吞吐率$TP &#x3D; \frac{n}{\sum_{i&#x3D;1}^k \Delta t_i + (n - 1) max(\Delta t_1, \Delta t_2, …, \Delta t_k)}$</p>
<p>流水线的最大吞吐率为$TP_{max} &#x3D; \frac{1}{max(\Delta t_1, \Delta t_2, …, \Delta t_k)}$</p>
<h4 id="解决流水线瓶颈问题的常用方法"><a href="#解决流水线瓶颈问题的常用方法" class="headerlink" title="解决流水线瓶颈问题的常用方法"></a>解决流水线瓶颈问题的常用方法</h4><ul>
<li>细分瓶颈段</li>
<li>重复设置瓶颈段<ul>
<li>缺点：控制逻辑比较复杂，所需的硬件增加了</li>
</ul>
</li>
</ul>
<h3 id="流水线的加速比"><a href="#流水线的加速比" class="headerlink" title="流水线的加速比"></a>流水线的加速比</h3><p>加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</p>
<p>假设：不使用流水线（顺序执行）所用的时间为$T_s$，使用流水线后所用的时间为$T_k$，则该流水线的加速比$S&#x3D;\frac{T_s}{T_k}$</p>
<h5 id="各段时间相等的流水线"><a href="#各段时间相等的流水线" class="headerlink" title="各段时间相等的流水线"></a>各段时间相等的流水线</h5><p>一条k段流水线完成n个连续任务，所需时间为$T_k &#x3D; (k + n - 1) \Delta t$</p>
<p>顺序执行n个任务，所需时间为$T_s &#x3D; nk\Delta t$</p>
<p>流水线的实际加速比为$S &#x3D; \frac{nk}{k + n - 1}$</p>
<p>最大加速比$S_{max} &#x3D; lim_{n -&gt; \inf} \frac{nk}{n + k - 1} &#x3D; k$</p>
<h5 id="各段时间不完全相等的流水线-1"><a href="#各段时间不完全相等的流水线-1" class="headerlink" title="各段时间不完全相等的流水线"></a>各段时间不完全相等的流水线</h5><p>一条k段流水线完成n个连续任务的实际加速比为<br>$$ S &#x3D; \frac{n \sum <em>{i&#x3D;1}^k \Delta t_i}{\sum</em>{i&#x3D;1}^k \Delta t_i + (n - 1) max (\Delta t1, … \Delta t_k)} $$</p>
<h3 id="流水线的效率"><a href="#流水线的效率" class="headerlink" title="流水线的效率"></a>流水线的效率</h3><p>流水线的效率：流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率</p>
<p>由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷的工作</p>
<p>从时空图的角度来看，效率就是n个任务占用的时空面积&#x2F;k个段的总时空面积(最大矩形的面积)</p>
<h5 id="各段时间相等"><a href="#各段时间相等" class="headerlink" title="各段时间相等"></a>各段时间相等</h5><p>各段的效率$e_i$相同，$e_i&#x3D;\frac{n\Delta t}{T_k} &#x3D; \frac{n}{k + n - 1}$</p>
<p>整条流水线的效率为$E &#x3D; \frac{e_1 + e_2 + … + e_k}{k} &#x3D; \frac{ke_1}{k} &#x3D; \frac{k n \Delta t}{kT_k} &#x3D; \frac{n}{k + n - 1}$</p>
<p>最高效率为$E_{max} &#x3D; lim_{n -&gt; \inf} \frac{n}{k + n - 1} &#x3D; 1$</p>
<p>当流水线各段时间相等时候，流水线的效率与吞吐率成正比$E &#x3D; TP \cdot \Delta t$</p>
<p>流水线的效率是它的实际加速比S与它的最大加速比k的比值$E&#x3D;\frac{S}{k}$</p>
<h5 id="各段时间不相等"><a href="#各段时间不相等" class="headerlink" title="各段时间不相等"></a>各段时间不相等</h5><p>$$ E &#x3D; \frac{n \cdot \sum <em>{i&#x3D;1}^k \Delta t_i}{k[\sum</em>{i&#x3D;1}^k\Delta t_i + (n-1)\cdot max(\Delta t_1, …, \delta t_k)]} $$</p>
<h3 id="流水线设计中的若干问题"><a href="#流水线设计中的若干问题" class="headerlink" title="流水线设计中的若干问题"></a>流水线设计中的若干问题</h3><ul>
<li>瓶颈问题<ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间</li>
<li>在设计流水线时，要尽可能使各段时间相等</li>
</ul>
</li>
<li>流水线的额外开销<ul>
<li>流水寄存器延迟：建立时间，传输延迟</li>
<li>时钟偏移开销：时钟到达各流水寄存器的最大差值时间</li>
</ul>
</li>
<li>明确意义<ul>
<li>流水线不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率</li>
<li>适当增加流水线的深度（段数）可以提高流水线的性能</li>
<li>流水线的深度受限于流水线的额外开销</li>
<li>当时钟周期小到与额外开销相同时，流水已经没有意义。因为这时在每一个时钟周期中已经没有时间来做有用的工作</li>
</ul>
</li>
</ul>
<h2 id="非线性流水线的调度"><a href="#非线性流水线的调度" class="headerlink" title="非线性流水线的调度"></a>非线性流水线的调度</h2><ul>
<li>在非线性流水线中，存在反馈回路，当一个任务在流水线中流过时，可能要多次经过某些段</li>
<li>流水线调度要解决的问题：应按什么样的时间间隔向流水线输入新任务，才能既不发生功能段使用冲突，又能使流水线又较高的吞吐率和效率</li>
</ul>
<h3 id="单功能非线性流水线的最优调度"><a href="#单功能非线性流水线的最优调度" class="headerlink" title="单功能非线性流水线的最优调度"></a>单功能非线性流水线的最优调度</h3><ul>
<li>向一条非线性流水线的输入端连续输入两个任务之间的时间间隔称为非线性流水线的启动距离</li>
<li>会引起非线性流水线功能段使用冲突的启动距离则称为禁用启动距离</li>
<li>启动距离和禁用启动距离一般都是用时钟周期数来表示，是一个正整数</li>
<li>预约表<ul>
<li>横向（向右）：时间（一般用时钟周期表示）</li>
<li>纵向（向下）：流水线的段</li>
<li>如果在第n个时钟周期使用了第k段，则在第k行和第n列的交叉处各自里又一个勾</li>
<li>如果在第k行和第n列的交叉处的格子里有一个勾，则表示在第n个时钟周期要使用第k段</li>
</ul>
</li>
</ul>
<h4 id="预约表"><a href="#预约表" class="headerlink" title="预约表"></a>预约表</h4><h5 id="根据预约表写出禁止表F"><a href="#根据预约表写出禁止表F" class="headerlink" title="根据预约表写出禁止表F"></a>根据预约表写出禁止表F</h5><ul>
<li>禁止表F：一个由禁用启动距离构成的集合</li>
<li>具体方法：对于预约表的每一行的任何一对勾，用它们所在的列号相减，列出各种可能的差值，然后删除相同的，剩下的就是禁止表的元素</li>
<li>根据禁止表写出初始冲突向量$C_0$（进行从一个集合到二进制位串的变换）<ul>
<li>冲突向量C：一个N位的二进制串</li>
<li>设$C_0&#x3D;(c_NC_{N-1}…C_2c_1)$，则当$i \in F$，$c_i &#x3D; 1$，否则$f_i&#x3D;0$</li>
<li>$c_i&#x3D;0$：允许间隔i个时钟周期后送入后续任务</li>
<li>$c_i&#x3D;1$：不允许间隔i个时钟周期后送入后续任务</li>
</ul>
</li>
<li>根据冲突向量$C_0$画出状态转换图<ul>
<li>当第一个任务进入流水线后，初始冲突向量$C_0$决定了下一个任务需要间隔多少个时钟周期才可以进入</li>
<li>在第二个任务流入后<ul>
<li>假设第二个任务是在于第一个任务间隔j个时钟周期流入，这时，有序第一个任务已经在流水线中前进了j个时钟周期，其响应的禁止表中各元素的值都应该减去j，并丢弃小于等于0的值</li>
<li>对冲突向量来说，就是逻辑右移j位</li>
<li>在冲突向量上，就是对它们的冲突向量进行或运算</li>
<li>$(C_0 &gt;&gt; j) | C_0$</li>
</ul>
</li>
<li>推广到更一般的情况<ul>
<li>假设$C_k$：当前的冲突向量；j：允许的时间间隔</li>
<li>则新的冲突向量为$(C_k &gt;&gt; j) | C_0$</li>
</ul>
</li>
<li>对于所有允许的时间间隔都按照上述步骤求出其新的冲突向量，并且把新的冲突向量作为当前冲突向量，反复使用上述步骤，直到不再产生新的冲突向量为止</li>
</ul>
</li>
<li>根据状态转换图写出最优调度方案<ul>
<li>根据流水线状态图，由初始状态触发，任何一个闭合回路即为一种调度方案</li>
<li>列出所有可能的调度方案，计算出每种方案的平均时间间隔，从中找出其最小者即为最优调度方案</li>
</ul>
</li>
</ul>
<h2 id="流水线的相关与冲突"><a href="#流水线的相关与冲突" class="headerlink" title="流水线的相关与冲突"></a>流水线的相关与冲突</h2><h3 id="经典5段流水线"><a href="#经典5段流水线" class="headerlink" title="经典5段流水线"></a>经典5段流水线</h3><ul>
<li>IF取指令周期<ul>
<li>以程序计数器PC中的内容作为地址，从存储器中取出指令并放入寄存器IR</li>
<li>同时PC值加4，指向顺序的下一条地址</li>
</ul>
</li>
<li>ID指令译码&#x2F;读寄存器周期<ul>
<li>对指令进行译码，并用IR中的寄存器地址去访问通用寄存器组，读出所需的操作数</li>
</ul>
</li>
<li>EX执行&#x2F;有效地址计算周期<ul>
<li>load和store指令：ALU把指令中所指定的寄存器的内容与偏移量相加，形成访存有效地址</li>
<li>寄存器-寄存器ALU指令：ALU按照操作码指定的操作对通用寄存器组中读出的数据进行运算</li>
<li>寄存器-立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读出的操作数和指令中给出的立即数进行运算</li>
<li>分支指令：ALU把指令中给出的偏移量与PC相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功</li>
</ul>
</li>
<li>MEM存储器访问&#x2F;分支完成周期<ul>
<li>load指令：用上一个周期计算出的有效地址，从存储器中读出相应的数据</li>
<li>store指令：把指定的数据写入这个有效地址所指出的存储器单元（<strong>完成</strong>）</li>
<li>分支指令：如果分支成功，把转移目标地址送入PC。（<strong>分支指令也在此阶段全部完成</strong>）</li>
<li>其它指令在该周期无操作</li>
</ul>
</li>
<li>WB写回周期<ul>
<li>ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组</li>
</ul>
</li>
</ul>
<p>在以上的实现方案中，分支指令和store指令需要4个周期，其它指令需要5个周期</p>
<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><ul>
<li>相关：两条指令之间存在某种依赖关系。</li>
<li>如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行</li>
<li>三种相关类型<ul>
<li>数据相关</li>
<li>名相关</li>
<li>控制相关</li>
</ul>
</li>
</ul>
<h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><ul>
<li>对于两条指令i和j，如果下述条件之一成立，则称指令j与指令i数据相关<ul>
<li>指令j使用指令i产生的结果</li>
<li>指令j与指令k数据相关，而指令k又与指令i数据相关（数据相关具有传递性）</li>
</ul>
</li>
</ul>
<h4 id="名相关"><a href="#名相关" class="headerlink" title="名相关"></a>名相关</h4><ul>
<li>名：指令所访问的寄存器或存储单元的名称</li>
<li>如果两条指令使用相同的名，但是它们之间并没有数据流动，则称这两条指令存在名相关</li>
<li>指令j与指令i之间的名相关有两种<ul>
<li>反相关：如果指令j写的名与指令i读的名相同（指令j写的名&#x3D;指令i读的名），则成指令i和j发生了反相关</li>
<li>输出相关：如果指令j和指令i写相同的名（指令j写的名&#x3D;指令i写的名），则称指令i和j发生了输出相关</li>
</ul>
</li>
<li>特点<ul>
<li>名相关的两条指令之间并没有数据的传送</li>
<li>如果一条指令中的名改变了，并不影响另外一条指令的执行</li>
<li>换名技术<ul>
<li>通过改变指令中操作数的名来消除名相关</li>
<li>对于寄存器操作数进行换名称为寄存器换名</li>
<li>既可以通过编译器静态实现，也可以用硬件动态实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><ul>
<li>控制相关是指由分支指令引起的相关<ul>
<li>为了保证程序应有的执行顺序，必须严格按控制相关确定的执行顺序</li>
</ul>
</li>
<li>典型的程序结构即使if then结构</li>
<li>带来的限制<ul>
<li>与一条分支指令控制相关的指令不能被移到该分支之前，否则这些指令就不受该分支控制了（then中的指令不能移到if之前）</li>
<li>如果一条指令与某分支指令不存在控制相关，就不能把该指令移到该分支之后</li>
</ul>
</li>
</ul>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ul>
<li>冲突：对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行</li>
<li>类型<ul>
<li>结构冲突：因硬件资源满足不了指令重叠执行的要求而发生的冲突</li>
<li>数据冲突：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突</li>
<li>控制冲突：流水线遇到分支指令和其它会改变PC值的指令所引起的冲突</li>
</ul>
</li>
<li>问题<ul>
<li>导致错误的执行结果</li>
<li>流水线可能会出现停顿，从而降低流水线的效率和实际的加速比</li>
<li>当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行</li>
</ul>
</li>
</ul>
<h4 id="结构冲突"><a href="#结构冲突" class="headerlink" title="结构冲突"></a>结构冲突</h4><ul>
<li>在流水线处理机中，为了能够使各种组合的指令都能顺利的重叠执行，需要对功能部件进行流水或重复设置资源</li>
<li>如果某种指令组合因为资源冲突而不能正常执行，则称该处理机有结构冲突</li>
<li>常见的导致结构冲突的原因<ul>
<li>功能部件不是完全流水</li>
<li>资源份数不够</li>
</ul>
</li>
<li>e.g. 访存冲突<ul>
<li>有些流水线处理机只有一个存储器，将数据和指令放在一起，访存指令会导致访存冲突</li>
<li>解决方法1：设置相互独立的指令存储器和数据存储器，或设置相互独立的指令cache和数据cache</li>
<li>解决方法2：插入暂停周期（流水线气泡）</li>
</ul>
</li>
</ul>
<h4 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h4><ul>
<li>当相关的指令靠得足够近时，它们在流水线中的重叠执行或者重新排序会改变指令读&#x2F;写操作数的顺序，使之不同于它们串行执行时的顺序，则发生了数据冲突</li>
<li>类型<ul>
<li>写后读冲突（RAW）：在i写入之前，j先去读，j读出的内容就是错误的（对应数据相关）</li>
<li>写后写冲突（WAW）：在i写入之前，j先写，导致最后写入的内容是i的而不是j的（对应输出相关）<ul>
<li>写后写冲突只可能发生在这样的流水线中<ul>
<li>流水线中不只一个段可以进行写操作</li>
<li>指令被重新排序了</li>
</ul>
</li>
</ul>
</li>
<li>读后写冲突（WAR）：在i读之前，j先写，i读出的内容是错误的（对应反相关）<ul>
<li>仅发生在这样的情况下<ul>
<li>有些指令的写结果操作提前了，而且有些指令的读操作滞后了</li>
<li>指令被重新排序了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>通过定向技术减少数据冲突引起的停顿<ul>
<li>思路：在计算结果尚未出来之前，后面等待使用该结果的指令并不真正立即需要改计算结果，如果能够将该计算结果从其产生的地方直接送到其它指令需要它的地方，那么就可以避免停顿</li>
<li>实现<ul>
<li>EX段和MEM段之间的流水寄存器中保存的ALU运算结果总是回送到ALU的入口</li>
<li><strong>当定向硬件检测到前一个ALU运算结果写入的寄存器就是当前ALU操作的源寄存器时，那么控制逻辑就选择定向的数据作为ALU的输入，而不采用从通用寄存器组读出的数据</strong></li>
<li>结果数据不仅可以从某一功能部件的输出定向到自身的输入，而且还可以定向到其它功能部件的输入</li>
</ul>
</li>
</ul>
</li>
<li>需要停顿的数据冲突<ul>
<li>不是所有的数据冲突都可以用重定向技术来解决</li>
<li>增加流水线互锁机制，插入暂停</li>
<li>作用：检测发现数据冲突，并使流水线停顿，直至冲突消失</li>
</ul>
</li>
<li>依靠编译器解决数据冲突（软件方法）<ul>
<li>让编译器重新组织指令顺序来消除冲突，称为指令调度或流水线调度。</li>
</ul>
</li>
</ul>
<h4 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h4><ul>
<li>执行分支指令的结果有两种<ul>
<li>分支成功：PC值改变为分支转移的目标地址在条件判定和转移地址计算都完成后，才改变PC值</li>
<li>分支失败：PC的值保持正常递增，指向顺序的下一条指令</li>
</ul>
</li>
<li>处理分支指令最简单的方法：等结果<ul>
<li>“冻结”或“排空”流水线</li>
<li>优点：简单</li>
</ul>
</li>
<li>把由分支指令引起的延迟称为分支延迟</li>
<li>分支指令在目标代码中出现的频度影响实际CPI<ul>
<li>实际CPI &#x3D; 理想CPI + 平均每条指令的停顿周期数</li>
</ul>
</li>
<li>可采取措施来减少分支延迟<ul>
<li>在流水线中尽早判断出分支转移是否成功</li>
<li>尽早计算出分支目标地址</li>
</ul>
</li>
<li>通过软件（编译器）来减少分支延迟的方法<ul>
<li>预测分支失败<ul>
<li>允许分支指令后的指令继续在流水线中流动，好像什么都没有发生</li>
<li>若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动</li>
<li>若确定分支成功，流水线就把在分支指令之后去除的所有指令转化为空操作，并按分支目的地重新取指令</li>
<li>要保证：分支结果出来之前不能改变处理机的状态，以便一旦猜错，处理机能够回退到原先的状态</li>
</ul>
</li>
<li>预测分支成功<ul>
<li>假设分支转移成功，并从分支目标地址处取指令执行</li>
<li>起作用的前提：先知道分支目标地址，后知道分支是否成功</li>
</ul>
</li>
<li>隐藏分支延迟<ul>
<li>从逻辑上“隐藏”分支指令的执行时间，把延迟分支堪称是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令</li>
</ul>
</li>
</ul>
</li>
<li>分支延迟指令的调度<ul>
<li>任务：在延迟槽中放入有用的指令</li>
<li>由编译器完成，能否带来好处取决于编译器能否把有用的指令调度到延迟槽中</li>
<li>三种调度方法<ul>
<li>从前调度<ul>
<li>被调度的指令必须于分支无关</li>
<li>任何情况都起作用</li>
</ul>
</li>
<li>从目标处调度<ul>
<li>必须保证在分支失败时执行被调度的指令不会导致错误，有可能需要复制指令</li>
<li>分支成功时起作用，但由于复制指令，有可能增大程序空间</li>
</ul>
</li>
<li>从失败处调度<ul>
<li>必须保证在分支成功时执行被调度的指令不会导致错误</li>
<li>分支失败时</li>
</ul>
</li>
</ul>
</li>
<li>限制<ul>
<li>可以被放入延迟槽中的指令需要满足一定的条件</li>
<li>编译器预测分支转移方向的能力</li>
</ul>
</li>
<li>改进：分支取消机制（取消分支）</li>
<li>当分支的实际实行方向和事先锁预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化为一个空操作</li>
</ul>
</li>
</ul>
<h1 id="指令级并行及其开发——硬件方法"><a href="#指令级并行及其开发——硬件方法" class="headerlink" title="指令级并行及其开发——硬件方法"></a>指令级并行及其开发——硬件方法</h1><h2 id="指令级并行的概念"><a href="#指令级并行的概念" class="headerlink" title="指令级并行的概念"></a>指令级并行的概念</h2><ul>
<li>开发ILP的方法可以分为两大类<ul>
<li>基于软件的静态开发方法</li>
<li>基于硬件的动态开发方法</li>
</ul>
</li>
<li>流水线处理机的实际CPI<ul>
<li>理想流水线的CPI加上各类停顿的时钟周期数</li>
<li>$CPI_{流水线} &#x3D; CPI_{理想}+停顿_{结构冲突} + 停顿_{数据冲突}+停顿_{控制冲突}$</li>
<li>理想CPI是衡量流水线最高性能的一个指标</li>
<li>IPC：每个时钟周期完成的指令条数</li>
</ul>
</li>
<li>基本程序块<ul>
<li>一串连续的代码除了入口以外，没有其它的分支指令和转入点</li>
<li>程序平均每4~7条指令就会有一个分支</li>
</ul>
</li>
<li>循环级并行：使一个循环中的不同循环体并行执行<ul>
<li>开发循环的不同迭代之间存在的并行性</li>
</ul>
</li>
</ul>
<h2 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h2><ul>
<li>静态调度<ul>
<li>依靠编译器对代码进行静态调度，以减少相关和冲突</li>
<li>它不是在程序执行的过程中，而是在编译期间进行代码调度和优化</li>
<li>通过把相关指令拉开距离来减少可能产生的停顿</li>
</ul>
</li>
<li>动态调度<ul>
<li>在程序的执行过程中，依靠专门硬件对代码调度，减少数据相关导致的停顿</li>
</ul>
</li>
</ul>
<h3 id="动态调度的基本思想"><a href="#动态调度的基本思想" class="headerlink" title="动态调度的基本思想"></a>动态调度的基本思想</h3><ul>
<li>把指令流出的工作拆分为两步<ul>
<li>检测结构冲突</li>
<li>等待冲突数据消失</li>
<li>只要检测到没有结构冲突，就可以让指令流出，并且流出后的指令一旦其操作数就绪就可以立即执行</li>
</ul>
</li>
<li>乱序执行<ul>
<li>指令的执行顺序与程序顺序不相同</li>
<li>指令的完成也是乱序完成的：指令的完成顺序与程序顺序不相同</li>
</ul>
</li>
<li>为了支持乱序执行，把5段流水线的译码阶段再分成两个阶段<ul>
<li>流出(Issue, IS)：指令译码，检查是否存在结构冲突(in order issue)</li>
<li>读操作数(Read Operands, RO)：等待数据冲突消失，然后读操作数</li>
<li>本来的5段流水线中，是不会发生WAR冲突和WAW冲突的，但是乱序执行就有可能发生了。</li>
</ul>
</li>
<li>动态调度的流水线支持多条指令同时处于执行当中<ul>
<li>要求：具有多个功能部件、或者功能部件流水化、或者兼而有之</li>
</ul>
</li>
</ul>
<h2 id="动态分支预测技术"><a href="#动态分支预测技术" class="headerlink" title="动态分支预测技术"></a>动态分支预测技术</h2><ul>
<li>所开发的ILP越多，控制相关的制约就越大，分支预测要有更高的准确度<ul>
<li>在n-流出的处理机中，遇到分支指令的可能性增加了n倍</li>
<li>要给处理器连续提供指令，就需要准确地预测分支</li>
</ul>
</li>
<li>动态分支预测：在程序运行时，根据分支指令过去的表现来预测其将来的行为<ul>
<li>如果分支行为发生了变化，预测结果也跟着改变</li>
</ul>
</li>
<li>分支预测的有效性取决于<ul>
<li>预测的准确性</li>
<li>预测正确和不正确两种情况下的分支开销<ul>
<li>决定分支开销的因素<ul>
<li>流水线的结构</li>
<li>预测的方法</li>
<li>预测错误时的恢复策略等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>动态分支预测的目的<ul>
<li>提高预测分支成功率</li>
<li>尽快找到分支目标地址</li>
</ul>
</li>
</ul>
<h3 id="分支历史表BHT"><a href="#分支历史表BHT" class="headerlink" title="分支历史表BHT"></a>分支历史表BHT</h3><ul>
<li>Branch History Table<ul>
<li>最简单的动态分支预测方法</li>
<li>用BHT来记录分支指令最近一次或几次的执行情况（成功还是失败），并据此进行预测</li>
</ul>
</li>
<li>只有一个预测位的分支预测<ul>
<li>记录分支指令最近一次的历史，BHT中之需要1位二进制位</li>
</ul>
</li>
<li>采用两位二进制位来记录历史<ul>
<li>提高预测的准确度</li>
<li>两位分支预测的性能与n位分支预测的性能差不多</li>
<li>两位分支预测的状态转换，图略</li>
<li>但是在之前的五段流水线中，哪怕是在ID段判断分支计算目标地址，BHT也仍然是在ID段执行的，没法带来什么好处</li>
</ul>
</li>
</ul>
<h3 id="采用分支目标缓冲器BTB"><a href="#采用分支目标缓冲器BTB" class="headerlink" title="采用分支目标缓冲器BTB"></a>采用分支目标缓冲器BTB</h3><ul>
<li>目标：将分支的开销降为0</li>
<li>方法：分支目标缓冲<ul>
<li>将分支成功的分支指令地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识</li>
<li>这个缓冲区就是分支目标缓冲区Branch Target Buffer，或者分支目标cache</li>
</ul>
</li>
</ul>
<h4 id="采用BTB后，在流水线各个阶段所进行的相关操作"><a href="#采用BTB后，在流水线各个阶段所进行的相关操作" class="headerlink" title="采用BTB后，在流水线各个阶段所进行的相关操作"></a>采用BTB后，在流水线各个阶段所进行的相关操作</h4><ul>
<li>当前PC值送存储器和BTB</li>
<li>BTB中存在匹配的项？（IF段）<ul>
<li>ID段</li>
<li>是：以BTB的第二字段作为分支目标地址送给PC<ul>
<li>当前分支成功？<ul>
<li>EX段</li>
<li>是：分支预测正确，继续执行后续指令，不会出现停顿</li>
<li>否：分支预测错误，清除已取的指令，并从另一个分支（即失败处）取指令，从BTB中删除相应的项</li>
</ul>
</li>
</ul>
</li>
<li>否：成功分支指令？<ul>
<li>是：将其PC值和目标地址写入BTB，作为一个新项（EX段）</li>
<li>否：正常执行指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="采用BTB后，各种可能情况下的延迟"><a href="#采用BTB后，各种可能情况下的延迟" class="headerlink" title="采用BTB后，各种可能情况下的延迟"></a>采用BTB后，各种可能情况下的延迟</h4><table>
<thead>
<tr>
<th align="left">指令在BTB中？</th>
<th align="left">预测</th>
<th align="left">实际情况</th>
<th align="left">延迟周期</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是</td>
<td align="left">成功</td>
<td align="left">成功</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">是</td>
<td align="left">成功</td>
<td align="left">不成功</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">不是</td>
<td align="left"></td>
<td align="left">成功</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">不是</td>
<td align="left"></td>
<td align="left">不成功</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h4 id="BTB的另一种形式"><a href="#BTB的另一种形式" class="headerlink" title="BTB的另一种形式"></a>BTB的另一种形式</h4><p>在分支目标缓冲器中增设一个至少是两位的“分支历史表”字段，这样在BTB中如果查找到了对应项目，可以决定是否跳PC值。在原来的BTB中，一旦查找到了就一定跳PC值的。</p>
<h2 id="多指令流出技术"><a href="#多指令流出技术" class="headerlink" title="多指令流出技术"></a>多指令流出技术</h2><ul>
<li>多流出处理机有两种基本风格<ul>
<li>超标量(SuperScalar)<ul>
<li>在每个时钟周期流出的指令条数不固定，依代码的具体情况而定（有上限）</li>
<li>设这个上限为n，则该处理机为n流出</li>
<li>可以通过编译器进行静态调度，也可以使用硬件动态调度</li>
</ul>
</li>
<li>超长指令字VLIW(Very Long Instruction Word)<ul>
<li>在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包</li>
<li>指令包中，指令之间的并行性是通过指令显式地表示出来的</li>
<li>指令调度是由编译器静态完成的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于静态调度的多流出技术"><a href="#基于静态调度的多流出技术" class="headerlink" title="基于静态调度的多流出技术"></a>基于静态调度的多流出技术</h3><ul>
<li>在典型的超标量处理器中，每个时钟周期可以可以流出1到8条指令</li>
<li>指令按序流出，在流出时进行冲突检测<ul>
<li>由硬件检测当前流出的指令之间是否存在冲突以及当前流出的指令与正在执行的指令是否有冲突</li>
</ul>
</li>
</ul>
<h5 id="e-g-一个4流出的静态调度超标量处理机"><a href="#e-g-一个4流出的静态调度超标量处理机" class="headerlink" title="e.g. 一个4流出的静态调度超标量处理机"></a>e.g. 一个4流出的静态调度超标量处理机</h5><ul>
<li>在取指令阶段，流水线将从取指令部件收到1~4条指令（称为流出包）<ul>
<li>在一个时钟周期内，这些指令有可能式全部能流出，也可能只有一部分能流出</li>
</ul>
</li>
<li>流出部件检测结构冲突或数据冲突<ul>
<li>第一阶段：进行流出包内的冲突检测，选出初步判定可以流出的指令</li>
<li>第二阶段：检测所选出的指令与正在执行的指令是否有冲突</li>
</ul>
</li>
</ul>
<h5 id="MIPS处理机实现超标量"><a href="#MIPS处理机实现超标量" class="headerlink" title="MIPS处理机实现超标量"></a>MIPS处理机实现超标量</h5><p>假设，从每个时钟皱隆起流出两条指令，一条整型指令和一条浮点指令</p>
<ul>
<li>要求： 同时取两条指令（64位），译码两条指令（64位）</li>
<li>对指令的处理包括以下步骤<ul>
<li>从cache中取两条指令</li>
<li>确定哪几条指令可以流出（0~2）条指令</li>
<li>把它们发送到响应的功能部件</li>
</ul>
</li>
<li>双流出超标量流水线中指令执行的时空图<ul>
<li>假设：所有浮点指令的执行时间都是两个时钟周期（相当于比整型指令多了一个时钟周期）</li>
</ul>
</li>
<li>采用“1条整型指令+1条浮点指令”并行流出的方式，需要增加的硬件很少</li>
<li>浮点load或浮点store指令将使用整型部件，回增加对浮点寄存器的访问冲突<ul>
<li>增设一个浮点寄存器的读&#x2F;写端口</li>
</ul>
</li>
<li>由于流水线中的指令多了一倍，定向路径也要增加</li>
<li>限制超标量流水线的性能发挥的障碍<ul>
<li>load指令：load后续三条指令都不能使用其结果，否则就会引起停顿</li>
<li>分支延迟<ul>
<li>如果分支指令是流出包中的第一条指令，则其延迟是3条指令</li>
<li>否则就是流出包中的第二条指令，其延迟就是2条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h3><ul>
<li>把能并行执行的多条指令组装称一条很长的指令</li>
<li>设置多个功能部件</li>
<li>指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件</li>
<li>在VLIW处理机中，在指令流出时不需要进行复杂的冲突检测，而是依靠编译器全部安排号了</li>
<li>存在的问题<ul>
<li>程序代码长度增加了<ul>
<li>提高并行性而进行的大量的循环展开</li>
<li>指令字中的操作槽并非总能填满<ul>
<li>解决：采用指令共享立即数字段的方法，或者采用指令压缩存储、调入cache或译码时展开的方法</li>
</ul>
</li>
</ul>
</li>
<li>采用了锁步机制<ul>
<li>任何一个操作部件出现停顿时，整个处理机都要停顿</li>
</ul>
</li>
<li>机器代码的不兼容性</li>
</ul>
</li>
</ul>
<h3 id="多流出处理器受到的限制"><a href="#多流出处理器受到的限制" class="headerlink" title="多流出处理器受到的限制"></a>多流出处理器受到的限制</h3><ul>
<li>程序所固有的指令级并行性</li>
<li>硬件实现上的困难</li>
<li>超标量和超长指令字处理器固有的技术限制</li>
</ul>
<h3 id="超流水线处理机"><a href="#超流水线处理机" class="headerlink" title="超流水线处理机"></a>超流水线处理机</h3><ul>
<li>将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令，这种处理机称为超流水线处理机</li>
<li>对于一台每个时钟周期都能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1&#x2F;n个时钟周期流出一条指令<ul>
<li>实际上该超流水线计算机长度流水线周期为1&#x2F;n个时钟周期</li>
</ul>
</li>
<li>有时候把指令流水线级数位8及以上的流水线处理机称为超流水线处理机</li>
</ul>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储系统的基本知识"><a href="#存储系统的基本知识" class="headerlink" title="存储系统的基本知识"></a>存储系统的基本知识</h2><h3 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h3><p>采用多种存储技术，构成多级存储层次结构</p>
<ul>
<li>程序访问的局部性原理：对于绝大多数程序来说，程序锁访问的指令和数据在地址上不是均匀分布的，而是相对簇聚的</li>
<li>程序访问的局部性包含两个方面<ul>
<li>时间局部性：程序马上将要用到的信息很可能就是现在正在使用的信息</li>
<li>空间局部性：程序马上将要用到的信息很可能与现在正在使用的信息在存储空间上是相邻的</li>
</ul>
</li>
<li>原理：加快经常性事件</li>
</ul>
<h4 id="层次结构存储器"><a href="#层次结构存储器" class="headerlink" title="层次结构存储器"></a>层次结构存储器</h4><ul>
<li>假设第i个存储器$M_i$的访问时间为$T_i$，容量为$S_i$，平均每位价格为$C_i$，则<ul>
<li>访问时间$T_1 &lt; T_2 &lt; … &lt; T_n$</li>
<li>容量$S_1 &lt; S_2 &lt; … &lt; S_n$</li>
<li>平均每位价格$C_1 &gt; C_2 &gt; … &gt; C_b$</li>
</ul>
</li>
</ul>
<h3 id="存储层次的性能参数"><a href="#存储层次的性能参数" class="headerlink" title="存储层次的性能参数"></a>存储层次的性能参数</h3><p>当整个存储系统只有两个层次M1，M2时候</p>
<ul>
<li>存储容量<ul>
<li>一般来说，整个存储系统的容量只用算第二级存储器M2的容量，即S&#x3D;S2</li>
</ul>
</li>
<li>每位价格C<ul>
<li>$C &#x3D; \frac{C_1S_1 + C_2S_2}{S_1 + S_2}$</li>
<li>当$S_1 &lt;&lt; S_2$时,$C \approx C_2$</li>
</ul>
</li>
<li>命令率H和不命中率F<ul>
<li>命中率：CPU访问存储系统时，在M1中找到所需信息的概率<ul>
<li>$H&#x3D;\frac{N_!}{N_1 + N_2}$</li>
<li>N1：访问M1的次数</li>
<li>N2：访问M2的次数</li>
</ul>
</li>
<li>不命中率F：F &#x3D; 1 - H</li>
</ul>
</li>
<li>平均访问时间$T_A$<ul>
<li>$T_A &#x3D; HT_1 + (1 - H) * (T_1 + T_M) &#x3D; T_1 + (1 - H) T_M$</li>
<li>或者$T_A &#x3D; T_1 + FT_M$</li>
<li>当命中时，访问时间即为$T_1$</li>
<li>当不命中时，miss开销$T_M &#x3D; T_2 + T_B$：从向M2发出访问请求到把整个数据块调入M1锁需要的时间<ul>
<li>$T_B$为传入一个信息块所需的时间</li>
</ul>
</li>
<li>不命中时的总访问时间为$T_1 + T_2 + T_B$</li>
</ul>
</li>
</ul>
<h3 id="三级存储系统"><a href="#三级存储系统" class="headerlink" title="三级存储系统"></a>三级存储系统</h3><ul>
<li>三级<ul>
<li>cache</li>
<li>主存</li>
<li>外存（辅存）</li>
</ul>
</li>
<li>可以看成是由cache-主存和主存-辅存层次构成的系统</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">cache-主存</th>
<th align="left">主存-辅存</th>
</tr>
</thead>
<tbody><tr>
<td align="left">目的</td>
<td align="left">为了弥补主存速度的不足</td>
<td align="left">为了弥补主存容量的不足</td>
</tr>
<tr>
<td align="left">存储管理实现</td>
<td align="left">主要由专用硬件实现</td>
<td align="left">主要由软件实现</td>
</tr>
<tr>
<td align="left">访问速度的比值（一级比二级）</td>
<td align="left">几比一</td>
<td align="left">几万比一</td>
</tr>
<tr>
<td align="left">典型的块（页）大小</td>
<td align="left">几十个字节</td>
<td align="left">几百到几千个字节</td>
</tr>
<tr>
<td align="left">CPU对第二级的访问方式</td>
<td align="left">可直接访问</td>
<td align="left">均通过第一级</td>
</tr>
<tr>
<td align="left">不命中时CPU是否切换</td>
<td align="left">不切换</td>
<td align="left">切换到其它进程</td>
</tr>
</tbody></table>
<h3 id="存储层次的四个问题"><a href="#存储层次的四个问题" class="headerlink" title="存储层次的四个问题"></a>存储层次的四个问题</h3><ul>
<li>当把一个块调入高一层（靠近CPU）存储器时，可以放在哪些位置上？ —— 影响规则</li>
<li>当所要访问的块在高一层存储器中时候，如何找到该块？ —— 查找算法</li>
<li>当发生不命中时，应替换哪一块？ —— 替换算法</li>
<li>当进行写访问时，应进行哪些操作？ —— 写策略</li>
</ul>
<h2 id="cache基本知识"><a href="#cache基本知识" class="headerlink" title="cache基本知识"></a>cache基本知识</h2><h3 id="基本结构和原理"><a href="#基本结构和原理" class="headerlink" title="基本结构和原理"></a>基本结构和原理</h3><ul>
<li>cache是按块进行管理的</li>
<li>cache和主存均被分割称大小相同的块（cache line）</li>
<li>信息以块为单位调入cache<ul>
<li>主存块地址（块号）用于查找该块在cache中的位置</li>
<li>块内位移用于确定所访问的数据在该块中的位置</li>
<li>主存地址：块地址+块内位移</li>
</ul>
</li>
</ul>
<h3 id="映像规则"><a href="#映像规则" class="headerlink" title="映像规则"></a>映像规则</h3><ul>
<li>全相联映像<ul>
<li>全相联：主存中的任意块可以被放置到cache中的任意一个文职</li>
<li>特点：空间利用率最高，冲突概率最低，实现最复杂，查找速度慢</li>
</ul>
</li>
<li>直接映像：主存中断每一块只能被防止到cache中的位移一个位置<ul>
<li>特点：空间利用率最低，冲突概率最高，实现最简单，查找速度最快</li>
<li>对于主存的第i块，若它映像到cache的第j块，则$j &#x3D; i mod (M)$，其中M为cache的块数</li>
<li>当$M&#x3D;2^m$时，则当表示为二进制数时，j实际上就是i的低m位</li>
</ul>
</li>
<li>组相联映像<ul>
<li>组相联：主存中的每一块可以被防止到cache中唯一的一个组中的任何一个位置（直接映像到组，组内全相联）</li>
<li>组相联是直接印象和全相联的一种折中</li>
<li>组的选择<ul>
<li>若主存低i块映像到低k组，则$k &#x3D; i mod (G)$</li>
<li>设$G&#x3D;2^g$，当二进制表示的时候，k实际上就是i的低j位</li>
</ul>
</li>
<li>n路组相联：每组中有n个块($n &#x3D; M \div G$)<ul>
<li>n称为相联度</li>
<li>相联度越高，cache空间的利用率就越高，块冲突概率就越低，不命中概率也就越低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul>
<li>通过查找目录表来实现<ul>
<li>目录表的结构<ul>
<li>主存块的块地址的高位部分，称为标识Tag</li>
<li>每个主存块嫩巩唯一地由其标识来确定</li>
</ul>
</li>
<li>只需查找候选位置所对应的目录表项</li>
</ul>
</li>
<li>并行查找的实现方法<ul>
<li>相联存储器<ul>
<li>目录由$2^g$个相联存储区域构成，每个相联存储区的大小为$n \times (h + log_2 n)$位</li>
<li>根据所查找到的组内块地址，从cache存储体中读出的多个信息字中选一个，发送给CPU</li>
</ul>
</li>
<li>但体多字的按地址访问的存储器和比较器</li>
</ul>
</li>
</ul>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><ul>
<li>解决的问题：当新调入一块时，二cache有已经被占满时，如何替换<ul>
<li>直接映像的cache中替换很简单，因为只有一个</li>
</ul>
</li>
<li>替换算法<ul>
<li>随机</li>
<li>先进先出FIFO<ul>
<li><strong>FIFO中，不管一个块是否命中，只要是先进入的块，就一定先出去</strong></li>
</ul>
</li>
<li>最近最少使用发LRU<ul>
<li>选择近期最少被访问的块作为被替换的块</li>
<li>实际上选择最久没有被访问过的块作为被替换的块</li>
<li>优点：命中率较高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LRU算法的硬件实现——堆栈法"><a href="#LRU算法的硬件实现——堆栈法" class="headerlink" title="LRU算法的硬件实现——堆栈法"></a>LRU算法的硬件实现——堆栈法</h4><ul>
<li>用一个堆栈来记录组相联cache的同一组中各块被访问的先后次序</li>
<li>用堆栈元素的物理位置来反映先后次序<ul>
<li>栈底记录最早被访问的块，栈顶记录刚访问过的块</li>
<li>当需要替换时，从栈底得到应该被替换的块</li>
</ul>
</li>
<li>栈中的内容必须动态更新<ul>
<li>当cache访问命中时，通过用块地址进行相联查找，在堆栈中找到相应的元素，然后把该元素的上面的所有元素下压一个位置，同时把本次访问呢的块地址抽出来，从最上面压入栈顶。而该元素下面的所有元素则保持不动。</li>
<li>如果cache访问不命中，则把本次访问的块地址从最上面压入栈顶，堆栈中所有原来的元素都下移一个位置。如果cache中该组已经没有空闲块，就需要替换一个块。这时从栈底被挤出去的块地址就是需要被替换的块的块地址</li>
</ul>
</li>
<li>堆栈法所需要的硬件<ul>
<li>需要为每一组都设置一个项数于相联读相同的小堆栈，每一项的位数位$log_2n$位</li>
</ul>
</li>
<li>硬件堆栈所需的功能<ul>
<li>相联比较</li>
<li>能全部下移、部分下移和从中间取出一项的功能</li>
</ul>
</li>
<li>速度低，成本高，只适用于相联度较小的LRU算法</li>
</ul>
<h3 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h3><ul>
<li>占的访存比例不大，但是影响力很大</li>
<li>写操作必须在确认是命中后才可以进行</li>
<li>写访问有可能导致cache和主存内容的不一致</li>
<li>两种写策略<ul>
<li>写直达法（写穿）：执行写操作时，不仅写入cache，而且也写入下一级存储器</li>
<li>写回：执行写操作时，只写入cache，仅当cache中相应的块被替换时，才写回主存</li>
<li>写策略是区分不同cache设计方案的一个重要标志</li>
</ul>
</li>
<li>两种写策略的比较<ul>
<li>写回：速度块，所使用的存储器带宽低</li>
<li>写穿：易于实现，一致性好</li>
</ul>
</li>
<li>采用写穿法的时候，若在进行写操作，CPU必须等待，直到写操作结束，称为CPU写停顿<ul>
<li>减少些停顿的一种常用的优化技术：采用写缓冲器</li>
</ul>
</li>
<li>写操作时的调块<ul>
<li>按写分配（写时取）<ul>
<li>写不命中时，先把所写单元所在的块调入cache，再行写入</li>
</ul>
</li>
<li>不按写分配（绕写法）<ul>
<li>写不命中时，直接写入下一级存储器而不调块</li>
</ul>
</li>
</ul>
</li>
<li>写策略与调块<ul>
<li>写回——按写分配</li>
<li>写穿——不按写分配</li>
</ul>
</li>
</ul>
<h3 id="cache的性能分析"><a href="#cache的性能分析" class="headerlink" title="cache的性能分析"></a>cache的性能分析</h3><ul>
<li>不命中率<ul>
<li>与硬件速度无关</li>
</ul>
</li>
<li>平均访存时间<ul>
<li>平均访存时间 &#x3D; 命中时间 + 不命中率 * 不命中开销</li>
</ul>
</li>
<li>程序执行时间<ul>
<li>CPU时间 &#x3D; （CPU执行周期数 + 存储器停顿周期数） * 时钟周期时间</li>
<li>存储器停顿时钟周期数 &#x3D; “读”的次数 * 读不命中率 * 读不命中开销 + “写”的次数 * 写不命中率 * 写不命中开销</li>
<li>&#x3D; 访存次数 * 不命中率 * 不命中开销</li>
<li>CPU时间 &#x3D; IC * （CPI + 访存次数 &#x2F; 指令数 * 不命中率 * 不命中开销） * 时钟周期时间</li>
<li>&#x3D; IC * （CPI + 每条指令的平均访存次数 * 不命中率 * 不命中开销） * 时钟周期时间</li>
</ul>
</li>
</ul>
<h2 id="降低cache不命中率"><a href="#降低cache不命中率" class="headerlink" title="降低cache不命中率"></a>降低cache不命中率</h2><h3 id="三种类型的不命中"><a href="#三种类型的不命中" class="headerlink" title="三种类型的不命中"></a>三种类型的不命中</h3><ul>
<li><p>强制性不命中</p>
<ul>
<li>当第一次访问一个块时，该块不在cache中，需从下一级存储器中调入cache，这就是强制性不命中（冷启动不命中，首次访问不命中）</li>
</ul>
</li>
<li><p>容量不命中</p>
<ul>
<li>如果程序执行时所需的块不能全部调入cache中，则当某些块被替换后，若又重新被访问，就会发生不命中。</li>
</ul>
</li>
<li><p>冲突不命中</p>
<ul>
<li>在组相联或直接映像cache中，若太多的块映像到同一组（块）中，则回出现该组中某个别块被别的块替换（即使别的组或块又空闲位置），然后又被重新访问的情况。（碰撞不命中）</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>相联度越高，冲突不命中越少</li>
<li>强制性不命中和容量不命中不受相联度的影响</li>
<li>强制性不命中不受cache容量的映像</li>
<li>容量不命中随着容量的增加而减少</li>
</ul>
</li>
<li><p>减少三种不命中的方法</p>
<ul>
<li>强制性不命中：增加块大小，预取（本身很少）</li>
<li>容量不命中：增加容量（成本、抖动现象）</li>
<li>冲突不命中：提高相联度（理想情况、全相联）</li>
</ul>
</li>
<li><p>许多降低不命中率的方法回增加命中时间或不命中开销</p>
</li>
</ul>
<h3 id="增加cache块大小"><a href="#增加cache块大小" class="headerlink" title="增加cache块大小"></a>增加cache块大小</h3><ul>
<li>不命中率与块大小的关系<ul>
<li>对于给定的cache容量，当块大小增加时，不命中率开始下井，后来反而上升了</li>
<li>原因<ul>
<li>一方面减少了强制性不命中</li>
<li>另一方面，增加块大小回减少cache中的块的数目，所以增加冲突不命中</li>
</ul>
</li>
<li>cache容量越大，使不命中率达到最低的块大小就越大</li>
</ul>
</li>
<li>增加块大小：增加冲突，增加不命中开销</li>
</ul>
<h3 id="增加cache的容量"><a href="#增加cache的容量" class="headerlink" title="增加cache的容量"></a>增加cache的容量</h3><ul>
<li>增加成本</li>
<li>可能增加命中时间</li>
<li>一般在片外cache中用得比较多</li>
</ul>
<h3 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h3><ul>
<li>采用相联度超过16的方案实际意义不大</li>
<li>2:1cache经验规则<ul>
<li>容量位N的直接映像，cache的不命中率和容量位N&#x2F;2的两路组相联cache的不命中率差不多相同</li>
</ul>
</li>
<li>提高相联度是以增加命中时间位代价的</li>
</ul>
<h3 id="伪限量cache（列相联cache）"><a href="#伪限量cache（列相联cache）" class="headerlink" title="伪限量cache（列相联cache）"></a>伪限量cache（列相联cache）</h3><p>多路组相联的低命中率和直接映像的命中速度</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">直接映像</td>
<td align="left">命中时间小</td>
<td align="left">不命中率高</td>
</tr>
<tr>
<td align="left">组相联</td>
<td align="left">不命中率低</td>
<td align="left">命中时间长</td>
</tr>
</tbody></table>
<ul>
<li>伪相联cache的优点<ul>
<li>命中时间小</li>
<li>不命中率低</li>
</ul>
</li>
<li>基本思想及工作原理<ul>
<li>在逻辑上把直接映像cache的空间上下分为两个区，对于任何一次访问，伪相联cache先按直接映像cache的方式去处理，若命中，则其访问过程与直接映像cache的情况一样。若不命中，则再去零一去相应位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器。</li>
</ul>
</li>
<li>快速命中与慢速命中<ul>
<li>要保证绝大多数命中都是快速命中</li>
</ul>
</li>
<li>缺点：多种命中时间-&gt;CPU流水线复杂化</li>
</ul>
<h3 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h3><ul>
<li>指令和数据都可以预取</li>
<li>预取内容既可以放入cache，也可放在外缓冲器中</li>
<li>指令预取通常由cache之外的硬件完成</li>
<li>预取利用存储器的空闲带宽，不能影响对正常不命中的处理，否则可能会降低性能</li>
</ul>
<h3 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h3><p>在编译时加入预取指令，在数据被用到之前发出预取请求</p>
<ul>
<li>按照预取数据所存放的位置，可以把预取分为两种类型<ul>
<li>寄存器预取：把数据取到寄存器中</li>
<li>cache预取：指将数据取到cache中</li>
</ul>
</li>
<li>按照预取的处理方式不同，可把预取分为<ul>
<li>故障性预取：在预取时，若出现虚地址故障或违反保护权限，就会发生异常</li>
<li>非故障性预取：在遇到这种情况时则不会发生异常，因为这是它会放弃预取，转变为空操作</li>
</ul>
</li>
<li>在预取数据的同时，处理器应能继续执行，只有这样预取才又意义（非阻塞，不锁定cache）</li>
<li>编译器控制预取的目的：使执行指令和读取数据能重叠执行</li>
<li>每次预取需要花费一条指令的开销<ul>
<li>保证这种开销不超过预取所带来的收益</li>
<li>避免不必要的预取（预取准，何时预取）</li>
</ul>
</li>
</ul>
<h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><ul>
<li>基本思想：通过对软件进行优化来降低不命中率</li>
<li>程序代码和数据重组<ul>
<li>可以重新组织程序而不映像程序的正确性<ul>
<li>把一个程序中的过程重新排序，就可能会减少冲突不命中</li>
<li>把基本块对齐，使得程序的入口点与cache块的起始位置对齐，就可以减少顺序代码执行时所发生的cache不命中的可能性（提高大cache块的效率）</li>
</ul>
</li>
<li>如果编译器知道一个分支指令很可能成功转移，那么就可以通过两步来改善空间局部性<ul>
<li>把转移目标出的基本快和紧跟着该分支指令后的基本快进行对调</li>
<li>把该分支指令转换为操作语义相反的分支指令</li>
</ul>
</li>
<li>数据对存储位置的限制更少，更便于调整数据</li>
</ul>
</li>
</ul>
<h3 id="“牺牲”cache"><a href="#“牺牲”cache" class="headerlink" title="“牺牲”cache"></a>“牺牲”cache</h3><ul>
<li>基本思想<ul>
<li>在cache和它从下一级存储器调数据的通路之间设置一个全相联的小cache，称为“牺牲”cache，用于存放被替换出去的块（称为牺牲者），以备重用</li>
</ul>
</li>
</ul>
<h2 id="减少cache不命中开销miss-penalty"><a href="#减少cache不命中开销miss-penalty" class="headerlink" title="减少cache不命中开销miss penalty"></a>减少cache不命中开销miss penalty</h2><h3 id="采用两级cache"><a href="#采用两级cache" class="headerlink" title="采用两级cache"></a>采用两级cache</h3><ul>
<li>性能分析<br>$$ 平均访存时间 &#x3D; 命中时间_{L1} + 不命中率_{L1} * 不命中开销_{L1} $$<br>$$ 不命中开销_{L1} &#x3D; 命中时间_{L2} + 不命中率_{L2} * 不命中开销_{L2} $$</li>
<li>局部不命中率与全局不命中率<ul>
<li>局部不命中率 &#x3D; 该级cache的不命中次数 &#x2F; 到达该级cache的访问次数</li>
<li>全局不命中率 &#x3D; 该级cache的不命中次数 &#x2F; CPU发出的访存的总次数</li>
<li>$全局不命中率_{L2} &#x3D; 不命中率_{L1} * 不命中率_{L2}$</li>
<li>评价第二级cache的时候，应使用全局不命中率这个指标。它指出了在CPU发出的访存中，究竟又多大比例是穿过各级cache，最终到达存储器的。</li>
</ul>
</li>
<li>采用两级cache时候，每条指令的平均访存停顿时间<ul>
<li>$每条指令的平均访存停顿时间 &#x3D; 每条指令的平均不命中次数_{L1}*命中时间_{L2} + 每条指令的平均不命中次数_{L2}*不命中开销$</li>
</ul>
</li>
</ul>
<h3 id="第二级cache的参数"><a href="#第二级cache的参数" class="headerlink" title="第二级cache的参数"></a>第二级cache的参数</h3><ul>
<li>容量<ul>
<li>第二级cache的容量一般比第一级大许多</li>
</ul>
</li>
<li>相联度<ul>
<li>第二级cache可采用较高的相联度或伪相联方法</li>
</ul>
</li>
<li>块大小<ul>
<li>第二季cache采用较大的块</li>
<li>为减少平均访存时间，可以让容量较小的第一级cache采用较小的块，而容量较大的第二级cache采用较大的块</li>
</ul>
</li>
</ul>
<h3 id="让读不命中优先于写"><a href="#让读不命中优先于写" class="headerlink" title="让读不命中优先于写"></a>让读不命中优先于写</h3><p>写缓冲器：在写穿法的时候，一般也不是直接把数据写到内存上，而是写到一个写缓冲器中，等CPU写完以后写缓冲器中的内容又再写到主存上。但是这样会带来问题：</p>
<ul>
<li>cache中的写缓冲器导致存储器访问的复杂化<ul>
<li>在读不命中时，所读单元的最新值有可能还在写缓冲器中，尚未写入主存</li>
</ul>
</li>
<li>解决方法（读不命中的处理）<ul>
<li>推迟对读不命中的处理，直至写缓冲器清空（缺点：读不命中的开销增加）</li>
<li>检查写缓冲器的内容（没有冲突就继续读）</li>
</ul>
</li>
</ul>
<h3 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h3><p>写穿cache。依靠写缓冲来减少对下一级存储器写操作的时间。</p>
<ul>
<li>如果写缓冲器为空，就把数据和相应地址写入该缓冲器</li>
<li>把这次的写入地址于写缓冲器中已有的所有地址进行比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据于该项合并，就叫做写缓冲合并</li>
</ul>
<h3 id="请求字处理技术"><a href="#请求字处理技术" class="headerlink" title="请求字处理技术"></a>请求字处理技术</h3><ul>
<li>请求字<ul>
<li>从下一级存储器调入cache的块中，只有一个字是立即需要的，这个字称为请求字</li>
</ul>
</li>
<li>应尽早把请求字发送给CPU<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起，一旦请求字到达，就立即发送给CPU，让CPU继续执行</li>
<li>请求字优先：调块时，从请求字所在的位置</li>
</ul>
</li>
</ul>
<h3 id="非阻塞cache技术"><a href="#非阻塞cache技术" class="headerlink" title="非阻塞cache技术"></a>非阻塞cache技术</h3><ul>
<li>非阻塞cache：cache不命中中时仍然允许CPU进行其它的命中访问</li>
<li>进一步提高性能<ul>
<li>多重不命中下命中</li>
<li>不命中下不命中</li>
</ul>
</li>
</ul>
<h2 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h2><h3 id="虚拟cache"><a href="#虚拟cache" class="headerlink" title="虚拟cache"></a>虚拟cache</h3><ul>
<li>物理cache<ul>
<li>使用物理地址进行访问的传统cache</li>
<li>表示存储器中存放的是物理地址，进行地址检测也是用物理地址</li>
<li>缺点：地址转换和访问cache串行进行，访问速度很慢</li>
</ul>
</li>
<li>虚拟cache<ul>
<li>可以直接用虚拟地址进行访问的cache，表示存储器中存放的是虚拟地址，进行地址检测用的也是虚拟地址</li>
<li>优点：再不命中时不需要进行地址转换，省去了地址转换的时间。即使不命中，地址转换和访问cache也是并行进行的，起速度比物理cache块很多</li>
<li>清空问题<ul>
<li>解决方法：再地址标识中增加PID字段（进程标识符）</li>
</ul>
</li>
</ul>
</li>
<li>虚拟索引 + 物理标识<ul>
<li>优点：兼等虚拟cache和物理cache的好处</li>
<li>局限性：cache容量受到限制</li>
</ul>
</li>
</ul>
<h3 id="cache访问流水化"><a href="#cache访问流水化" class="headerlink" title="cache访问流水化"></a>cache访问流水化</h3><h2 id="cache优化方法总结"><a href="#cache优化方法总结" class="headerlink" title="cache优化方法总结"></a>cache优化方法总结</h2><ul>
<li>增加块大小<ul>
<li>减少强制不命中</li>
<li>增加容量和冲突不命中，增加不命中开销</li>
</ul>
</li>
<li>增加cache容量<ul>
<li>增加命中时间，增加能耗</li>
</ul>
</li>
<li>增加相联度<ul>
<li>减少冲突不命中</li>
<li>增加命中时间，增加能耗</li>
</ul>
</li>
<li>多级cache<ul>
<li>降低不命中时间，优化平均访问时间</li>
</ul>
</li>
<li>让读不命中优先于写<ul>
<li>降低不命中开销</li>
</ul>
</li>
<li>虚拟cache<ul>
<li>减少命中时间</li>
</ul>
</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li>页式存储器把空间划分为大小相同的块</li>
<li>段式存储器把空间划分为可变长的块</li>
<li>页是对空间的机械化分，而段是按程序的逻辑意义进行划分</li>
</ul>
<h3 id="快速地址转换技术"><a href="#快速地址转换技术" class="headerlink" title="快速地址转换技术"></a>快速地址转换技术</h3><ul>
<li>地址变换缓冲器TLB<ul>
<li>TLB是一个专用的告诉缓冲器，用于存放近期经常使用的页表项</li>
<li>TLB中的内容是页表部分内容的一个副本</li>
<li>TLB也利用了局部性原理</li>
</ul>
</li>
<li>TLB中的项由两部分构成：标识和数据<ul>
<li>标识中存放的是虚地址的一部分</li>
<li>数据部分中存放的则是物理页帧号、有效位、存储保护信息、使用位、修改位等</li>
</ul>
</li>
</ul>
<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="I-O系统的性能"><a href="#I-O系统的性能" class="headerlink" title="I&#x2F;O系统的性能"></a>I&#x2F;O系统的性能</h2><ul>
<li>输入输出系统简称I&#x2F;O系统<ul>
<li>I&#x2F;O设备</li>
<li>I&#x2F;O设备与处理机的连接</li>
</ul>
</li>
<li>I&#x2F;O系统是计算机系统中的一个重要组成部分<ul>
<li>完成计算机与外界的信息交换</li>
<li>给计算机提供大容量的外部存储器</li>
</ul>
</li>
<li>按照主要完成的工作进行分类<ul>
<li>存储I&#x2F;O系统</li>
<li>通信I&#x2F;O系统</li>
</ul>
</li>
<li>评价I&#x2F;O系统性能的参数<ul>
<li>连接特性<ul>
<li>哪些I&#x2F;O设备可以和计算机系统相连接</li>
</ul>
</li>
<li>I&#x2F;O系统的容量<ul>
<li>I&#x2F;O系统可以容纳的I&#x2F;O设备数</li>
</ul>
</li>
<li>响应时间和吞吐率等</li>
</ul>
</li>
<li>系统的响应时间（衡量计算机系统的一个更好的指标）<ul>
<li>从用户输入命令开始，到得到结果所花费的时间</li>
<li>由两部分构成<ul>
<li>I&#x2F;O系统的响应时间</li>
<li>CPU的处理时间</li>
</ul>
</li>
<li>多进程技术只能够提供高系统吞吐率，并不能够减少系统响应时间</li>
</ul>
</li>
<li>另一种衡量I&#x2F;O系统性能的方法：考虑I&#x2F;O操作对CPU执行的打扰情况<ul>
<li>即考察由于其它进程的I&#x2F;O操作，使得某个进程的执行时间增加了多少</li>
</ul>
</li>
<li>I&#x2F;O系统对CPU的性能影响很大，若两者的性能不匹配，I&#x2F;O系统就有可能成为整个系统的瓶颈</li>
</ul>
<h2 id="I-O系统的可靠性、可用性和可信性"><a href="#I-O系统的可靠性、可用性和可信性" class="headerlink" title="I&#x2F;O系统的可靠性、可用性和可信性"></a>I&#x2F;O系统的可靠性、可用性和可信性</h2><ul>
<li>反映外设可靠性能的参数<ul>
<li>可靠性</li>
<li>可用性</li>
<li>可信性</li>
</ul>
</li>
<li>系统的可靠性：系统从某个初始参考点开始一直连续提供服务的能力<ul>
<li>用平均无故障时间MTTF来衡量</li>
<li>MTTF的倒数就是系统的失效率</li>
<li>如果系统中每个模块的生存期服从指数分布，则系统整体的失效率是各部件的失效率之和（串联模式下）</li>
<li>系统中断服务的时间用平均修复时间MTTR来衡量</li>
</ul>
</li>
<li>系统的可用性：系统正常工作的时间在连续两次正常服务间隔时间中所占的比率<ul>
<li>可用性 &#x3D; $\frac{MTTF}{MTTF + MTTR}$</li>
<li>平均失效间隔时间MTBF: MTTF + MTTR</li>
</ul>
</li>
<li>系统的可信度：服务的质量。即在多大程度上可以合理地认为服务是可靠的</li>
<li>提高系统组成部件可靠性的方法<ul>
<li>有效构建方法<ul>
<li>在构建系统的过程中消除故障隐患，这样建立起来的系统就不会出现故障</li>
</ul>
</li>
<li>纠错方法<ul>
<li>在系统构建中采用容错的方法，这样即使出现故障，也可以通过容错信息保证系统正常工作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可靠性模型"><a href="#可靠性模型" class="headerlink" title="可靠性模型"></a>可靠性模型</h3><p>可靠度<code>R(t)</code>，不可靠度<code>F(t)</code>，关系: $R(t) + F(t) &#x3D; 1$</p>
<ul>
<li>串联系统<ul>
<li>系统由n个部件串联而称，其中任何一个部件失效就引起系统的失效</li>
<li>串联系统寿命等于其中最先失效部件的寿命</li>
<li>若每个单元的可靠度分别为$R_1, …, R_n$，且每个单元相互独立，则系统可靠度为$R_s &#x3D; \prod _{i&#x3D;1}^n R_i$</li>
<li>想要提高串联系统的可靠性，就要提高单元可靠度，减少串联单元数目</li>
</ul>
</li>
<li>并联系统<ul>
<li>系统由n个部件并联而称，当这n个部件都失效时才引起系统失效</li>
<li>并联系统寿命等于其中最后失效部件的寿命</li>
<li>若每个单元的可靠度分别为$R_1, …, R_n$,且每个单元相互独立，则系统可靠度为$R_s &#x3D; 1 - \prod _{i&#x3D;1}^n (1-R_i)$</li>
<li>想要提高并联系统可靠性，就要提高单元可靠度，增加并联单元数目</li>
</ul>
</li>
<li>串并联系统，n代表串联倍数，m代表并联倍数<ul>
<li>$R(t) &#x3D; 1 - [1-R_i^n(t)]^m$</li>
<li>e.g. RAID01是串并联系统</li>
</ul>
</li>
<li>并串联系统<ul>
<li>$R(t) &#x3D; [1-(1-R_i(t))^m]^n$</li>
<li>e.g. RAID10是并串联系统</li>
</ul>
</li>
</ul>
<h2 id="廉价磁盘冗余阵列RAID"><a href="#廉价磁盘冗余阵列RAID" class="headerlink" title="廉价磁盘冗余阵列RAID"></a>廉价磁盘冗余阵列RAID</h2><ul>
<li>磁盘阵列DA(Disk Array)：使用多个磁盘（包括驱动器）的组合来代替一个大容量的磁盘<ul>
<li>多个磁盘并行工作</li>
<li>以条带为单位把数据均匀地分布到多个盘上（交叉存放）</li>
<li>条带存放可以使多个数据读&#x2F;写请求并行地被处理，从而提高总的I&#x2F;O性能</li>
</ul>
</li>
<li>并行性的含义<ul>
<li>多个独立的请求可以由多个盘来并行的处理<ul>
<li>减少了I&#x2F;O请求的排队等待时间</li>
</ul>
</li>
<li>如果一个请求访问多个块，就可以由多个盘合作来并行处理<ul>
<li>提高了单个请求的数据传输率</li>
</ul>
</li>
</ul>
</li>
<li>问题：阵列中磁盘数量的增加会导致磁盘阵列的可靠性下降<ul>
<li>如果使用了N个磁盘构成磁盘阵列，那么整个整列的可靠性将降低为单个磁盘的1&#x2F;N</li>
<li>解决方法：在磁盘阵列中设置冗余信息盘<ul>
<li>当单个磁盘失效时，丢失的信息可以通过冗余盘中的信息重新构建</li>
</ul>
</li>
</ul>
</li>
<li>大多数磁盘阵列的组成可以由以下两个特征来区分<ul>
<li>数据交叉存放的粒度<ul>
<li>细粒度磁盘阵列是在概念上把数据分割称相对较小的单位交叉存放<ul>
<li>优点：所有I&#x2F;O请求都能够获得很高的数据传输率</li>
<li>缺点：在任何时间，都只有一个逻辑I&#x2F;O在处理当中，而且所有的磁盘都会因为每个请求进行定位而浪费时间</li>
</ul>
</li>
<li>粗粒度磁盘阵列是把数据以相对较大的单位交叉存放<ul>
<li>多个较小规模的请求可以同时得到处理</li>
<li>对于较大规模的请求有能获得较高的传输率</li>
</ul>
</li>
</ul>
</li>
<li>冗余数据的计算方法以及在磁盘阵列中的存放方式</li>
</ul>
</li>
<li>在磁盘阵列中设置冗余信息需要解决以下两个问题<ul>
<li>如何计算冗余信息<ul>
<li>大多采用奇偶校验码</li>
<li>也有采用汉明码或者reed-solomon码的</li>
</ul>
</li>
<li>如何把冗余信息分布到磁盘阵列中的各个盘<ul>
<li>把冗余信息集中存放在少数的几个盘中</li>
<li>把冗余信息均匀地存放到所有盘中</li>
</ul>
</li>
</ul>
</li>
<li>RAID的分级及其特性<table>
<thead>
<tr>
<th align="left">RAID级别</th>
<th align="left">可以容忍的故障个数&amp;数据盘为8时需检测盘的个数</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">公司产品</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0，非冗余，条带存放</td>
<td align="left">0个故障；0个检测盘</td>
<td align="left">没有空间开销</td>
<td align="left">没有纠错能力</td>
<td align="left">广泛应用</td>
</tr>
<tr>
<td align="left">1，镜像</td>
<td align="left">1个故障；8个检测盘</td>
<td align="left">不需要计算奇偶校验，数据恢复快，读数据快。而且其小规模写操作比更高级别的RAID快</td>
<td align="left">检测空间开销最大（需要的检测盘最多</td>
<td align="left">EMC, HP, IBM</td>
</tr>
<tr>
<td align="left">2，存储式ECC</td>
<td align="left">1个故障；4个检测盘</td>
<td align="left">不依靠故障盘进行自诊断</td>
<td align="left">检测空间开销的级别是$log_2m$(m为盘的个数)</td>
<td align="left">没有</td>
</tr>
<tr>
<td align="left">3，位就校验</td>
<td align="left">1个故障；1个检测盘</td>
<td align="left">检测空间开销小（需要的检测盘少），大规模读写操作的带宽高</td>
<td align="left">对小规模、随机读写操作没有提供特别的支持</td>
<td align="left">外存概念</td>
</tr>
<tr>
<td align="left">4，块交叉奇偶校验</td>
<td align="left">1个故障；1个检测盘</td>
<td align="left">检测空间开销小，小规模的读操作带宽更高</td>
<td align="left">礁岩盘是小规模写的瓶颈</td>
<td align="left">网络设备</td>
</tr>
<tr>
<td align="left">5，块交叉分布奇偶校验</td>
<td align="left">1个故障，1个检测盘</td>
<td align="left">检测空间开销小，小规模的读写操作带宽更高</td>
<td align="left">小规模写操作需要访问磁盘4次</td>
<td align="left">广泛应用</td>
</tr>
<tr>
<td align="left">6，P+Q双奇偶校验</td>
<td align="left">2个故障；2个校验盘</td>
<td align="left">具有容忍2个故障的能力</td>
<td align="left">小规模写操作需要访问磁盘6次，检测空间开销加倍（与RAID3,4,5相比）</td>
<td align="left">网络设备</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><ul>
<li>非冗余磁盘真理，无冗余信息</li>
<li>严格来说不属于RAID系列</li>
<li>把数据切分称条带，以条带位单位交叉地分布存放到多个磁盘中</li>
</ul>
<h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><ul>
<li>镜像磁盘，对所有磁盘数据提供一份冗余的备份<ul>
<li>每当数据写入磁盘时，将该数据也写入其镜像盘。在系统中所有的数据都有两份</li>
</ul>
</li>
<li>特点<ul>
<li>能实现快速的读取操作</li>
<li>对于写入操作，镜像的两个磁盘都要写入。但可以并行进行，而且不需要计算校验信息，所以其速度比某些级别的RAID快</li>
<li>可靠性高，数据恢复很简单</li>
<li>实现成本最高</li>
</ul>
</li>
</ul>
<h3 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h3><ul>
<li>存储器式的磁盘阵列（按汉明码的思路构建）</li>
</ul>
<h3 id="RAID3"><a href="#RAID3" class="headerlink" title="RAID3"></a>RAID3</h3><ul>
<li>位交叉奇偶校验磁盘阵列</li>
<li>特点<ul>
<li>采用奇偶校验<ul>
<li>写数据时，为每行数据形成奇偶校验位并写入校验盘</li>
<li>读出数据时，如果控制器发现某个磁盘出故障，就可以根据故障盘意外的所有其它盘中的正确信息恢复故障盘中的数据（通过异或运算实现）</li>
</ul>
</li>
<li>细粒度的磁盘阵列，即采用的条带宽度较小（可以式一个字节或一位）<ul>
<li>多个磁盘的并行访问</li>
<li>不能同时进行多个I&#x2F;O请求的处理</li>
</ul>
</li>
<li>只需要一个礁岩盘，校验空间开销比较小</li>
</ul>
</li>
</ul>
<h3 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h3><ul>
<li>块交叉就校验磁盘阵列</li>
<li>采用比较大的条带，以块为单位进行交叉存放和计算奇偶校验<ul>
<li>实现目标：能同时处理多个小规模访问请求</li>
</ul>
</li>
<li>读写特点<ul>
<li>读取操作<ul>
<li>每次只需访问数据所在的磁盘</li>
<li>仅在该磁盘出现故障时，才会去读礁岩盘，并进行数据重建</li>
</ul>
</li>
<li>写入操作<ul>
<li>假定：有3个数据盘和一个冗余盘</li>
<li>写数据需要2次磁盘读和2次磁盘写操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>RAID3,4存在的问题<br>每次读写都必须读写校验盘压力太大，会成为读写速度的瓶颈</p>
</blockquote>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><ul>
<li>块交叉分布奇偶校验磁盘阵列</li>
<li>数据以块交叉的方式存于各盘，无专用冗余盘，校验信息均匀分布在所有磁盘上</li>
<li>重建与初始化<ul>
<li>重建：读出非故障盘上的数据，按照校验信息的计算方法得到故障盘上的数据，然后写入到新替换的盘上</li>
<li>重构：重建的微观操作过程</li>
</ul>
</li>
</ul>
<h4 id="校验信息的正确完整性问题"><a href="#校验信息的正确完整性问题" class="headerlink" title="校验信息的正确完整性问题"></a>校验信息的正确完整性问题</h4><ul>
<li>磁盘上初始信息式随机的</li>
<li>满条块写和大写可以保证校验信息的正确</li>
<li>若原始校验信息不正确，则小写不能保证校验信息的正确</li>
</ul>
<h4 id="RAID5初始化过程"><a href="#RAID5初始化过程" class="headerlink" title="RAID5初始化过程"></a>RAID5初始化过程</h4><ul>
<li>原则：保证校验信息一致正确</li>
<li>方法：全部写0</li>
<li>计算校验</li>
</ul>
<h3 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h3><ul>
<li>P+Q双校验磁盘阵列</li>
<li>特点<ul>
<li>校验空间开销是RAID5的两倍</li>
<li>容忍两个磁盘出错</li>
<li>应用越来越广</li>
</ul>
</li>
</ul>
<h3 id="RAID10和RAID01"><a href="#RAID10和RAID01" class="headerlink" title="RAID10和RAID01"></a>RAID10和RAID01</h3><ul>
<li>RAID10又称RAID1+0，先进行镜像，再进行条带存放</li>
<li>RAID01先进行条带存放，再进行镜像</li>
</ul>
<h3 id="RAID的实现与发展"><a href="#RAID的实现与发展" class="headerlink" title="RAID的实现与发展"></a>RAID的实现与发展</h3><ul>
<li>实现盘阵列的方式主要有三种<ul>
<li>软件方式：阵列管理软件由主机来实现<ul>
<li>优点：成本低</li>
<li>缺点：过多地占用主机时间，且打款指标上不去</li>
</ul>
</li>
<li>阵列卡方式：把RAID管理软件固化在I&#x2F;O控制卡上，从而可不占用主机时间，一般用于工作站和PC机</li>
<li>子系统方式：一种基于通用接口总线的开放式平台，可用于各种主机平台和网络系统</li>
</ul>
</li>
</ul>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><ul>
<li>在计算机系统中，各子系统之间可以通过总线互相连接</li>
<li>优点：成本低、简单</li>
<li>主要缺点：它是由不同的外设分时共享的，形成了信息交换的瓶颈，从而限制了系统中总的I&#x2F;O吞吐量</li>
</ul>
<h3 id="总线的设计"><a href="#总线的设计" class="headerlink" title="总线的设计"></a>总线的设计</h3><ul>
<li>总线设计存在很多技术难点<ul>
<li>一个重要原因：总线上信息传送的速度极大地受限于各种物理因素，如总线的长度、设备数目、信号强度灯</li>
<li>另外，我们一方面需要I&#x2F;O操作响应快，另一方面又要提高吞吐量，这可能造成设计需求上的冲突</li>
</ul>
</li>
<li>设计总线时需要考虑的一些问题</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">高性能</th>
<th align="left">低价格</th>
</tr>
</thead>
<tbody><tr>
<td align="left">总线宽度</td>
<td align="left">独立的地址和数据总线</td>
<td align="left">数据和地址分时公用同一套总线</td>
</tr>
<tr>
<td align="left">数据总线宽度</td>
<td align="left">越宽越快</td>
<td align="left">越窄越便宜</td>
</tr>
<tr>
<td align="left">传输块大小</td>
<td align="left">块越大总线开销越小</td>
<td align="left">单字传送更简单</td>
</tr>
<tr>
<td align="left">总线主设备</td>
<td align="left">多个（需要仲裁）</td>
<td align="left">单个（无需仲裁）</td>
</tr>
<tr>
<td align="left">分离事务</td>
<td align="left">采用一一分离的请求包和回答包能提高总线带宽</td>
<td align="left">不采用一一持续连接成本更低，而且延迟更小</td>
</tr>
<tr>
<td align="left">定时方式</td>
<td align="left">同步</td>
<td align="left">异步</td>
</tr>
</tbody></table>
<ul>
<li>分离事务总线（流水总线）<ul>
<li>在由多个主设备时，可以通过包交换来提高总线带宽</li>
<li>基本思想<ul>
<li>将总线事务分成请求和应答两部分</li>
<li>在请求和应答之间的空闲时间内，总线可以供其它的I&#x2F;O使用，这样就不必再整个I&#x2F;O过程中都独占总线</li>
</ul>
</li>
<li>分离事务总线有较高的带宽，但是它的数据传送延迟通常比独占总线方法大</li>
</ul>
</li>
<li>同步总线<ul>
<li>同步总线的控制线中包含一个时钟，总线上所有设备的所有通信操作都以该时钟为基准</li>
<li>优点：速度快、成本低</li>
<li>缺点：<ul>
<li>由于时钟通过长距离传输后会扭曲，因而同步总线不能用于长距离的连接，特别是对于告诉同步总线来说，更是如此</li>
<li>总线上的所有设备都必须以同样的时钟频率工作</li>
</ul>
</li>
<li>CPU-存储器通常采用同步总线</li>
</ul>
</li>
<li>异步总线<ul>
<li>没有同一的参考时钟，每个设备都有各自的定时方法</li>
<li>采用握手协议</li>
<li>不存在时钟扭曲和同步的问题，传输距离可以比较长</li>
<li>很多I&#x2F;O总线都采用异步总线</li>
<li>同步总线通常比异步总线快</li>
</ul>
</li>
<li>总线标准和实例<ul>
<li>I&#x2F;O总线标准：定义如何将设备于计算机进行连接的文档</li>
</ul>
</li>
</ul>
<h3 id="与CPU的连接"><a href="#与CPU的连接" class="headerlink" title="与CPU的连接"></a>与CPU的连接</h3><ul>
<li>I&#x2F;O总线的物理连接方式有两种选择<ul>
<li>连接到存储器上</li>
<li>连接到cache上</li>
</ul>
</li>
<li>I&#x2F;O总线连接到存储器总线上的方式<ul>
<li>一种典型的组织结构</li>
</ul>
</li>
<li>CPU对I&#x2F;O设备的编址有两种方式<ul>
<li>存储器映射I&#x2F;O（也成为I&#x2F;O设备统一编址）<ul>
<li>将一部分存储器地址空间分配给I&#x2F;O设备，用load指令和store指令对这些地址进行读写将引起I&#x2F;O设备的数据传输</li>
<li>将一部分存储空间流出用于设备控制，对这一部分地址空间进行读写就是向设备发出控制命令</li>
</ul>
</li>
<li>给I&#x2F;O设备独立编址<ul>
<li>需要再CPU中设置专用的I&#x2F;O指令来访问I&#x2F;O设备</li>
<li>CPU需要发出一个标志信号来表示所访问的地址是I&#x2F;O设备的地址</li>
</ul>
</li>
</ul>
</li>
<li>CPU与外部设备进行输入&#x2F;输出的方式分为4种<ul>
<li>程序查询</li>
<li>中断</li>
<li>DMA</li>
<li>通道</li>
</ul>
</li>
</ul>
<h3 id="DMA和虚拟存储器"><a href="#DMA和虚拟存储器" class="headerlink" title="DMA和虚拟存储器"></a>DMA和虚拟存储器</h3><ul>
<li>DMA使用虚拟地址还是物理地址？<ul>
<li>使用物理地址进行DMA传输，存在以下两个问题<ul>
<li>对于超过一页的数据缓冲区，由于缓冲区使用的页面在物理存储器中不一定是连续的，所以传输可能会发生问题</li>
<li>如果DMA正在存储器和缓冲区之间传输数据时，操作系统从存储器中移出（或重定位）一些页面，那么，DMA将会在存储器中错误的页面上进行数据传输</li>
</ul>
</li>
<li>解决方法<ul>
<li>使操作系统I&#x2F;O在传输过程中确保DMA设备所访问的页面都位于物理存储器中，这些页面被称为”钉在了主存中“</li>
<li>“虚拟DMA”技术<ul>
<li>允许DMA设备直接使用虚拟地址，并在DMA期间由硬件将虚拟地址转换为物理地址</li>
<li>在采用虚拟DMA的情况下，如果进程在内存中被移动，操作系统应该能够及时地修改响应的DMA地址表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O和cache数据一致性"><a href="#I-O和cache数据一致性" class="headerlink" title="I&#x2F;O和cache数据一致性"></a>I&#x2F;O和cache数据一致性</h3><ul>
<li>Cache会使一个数据出现两个副本，一个在cache中，另一个在主存中</li>
<li>I&#x2F;O设备可以修改存储器中的内容<ul>
<li>把I&#x2F;O连接到存储器上， 会出现以下情况<ul>
<li>CPU修改了cache的内容后，由于存储器的内容跟不上cache内容的变化，I&#x2F;O系统进行输出操作时所看到的数据是旧值（写穿cache没有这样的问题）</li>
<li>I&#x2F;O系统进行输入操作后，存储器的内容发生了变化，但CPU在cache中所看到的内容依然是旧值</li>
</ul>
</li>
</ul>
</li>
<li>解决内容一致性问题的方法（不管cache是写穿还是写回）<ul>
<li>软件方法<ul>
<li>设法保证I&#x2F;O缓冲器中的所有各块都不在cache中</li>
<li>具体做法有两种<ul>
<li>把I&#x2F;O缓冲器的页面设置为不可进入cache的，在进行输入操作时，操作系统总是把输入的数据放到该页面上</li>
<li>在进行输入操作之前，操作系统先把cache中与I&#x2F;O缓冲器相关的数据“赶出”cache，即把响应的数据块设置为无效状态</li>
</ul>
</li>
</ul>
</li>
<li>硬件方法<ul>
<li>在进行输入操作时，检查响应的I&#x2F;O地址（I&#x2F;O缓冲器中的单元）是否在cache中（即是否有数据副本）</li>
<li>如果发现I&#x2F;O地址在cache中有匹配的项，就把响应的cache块设置为“无效”</li>
</ul>
</li>
<li>把I&#x2F;O直接连接到cache上<ul>
<li>不会产生由I&#x2F;O导致的数据不一致的问题<ul>
<li>所有I&#x2F;O设备和CPU都能在cache中看到最新的数据</li>
<li>I&#x2F;O会和CPU竞争访问cache，在进行I&#x2F;O时，会造成CPU的挺短</li>
<li>I&#x2F;O还可能会破坏cache中CPU访问的内容，因为I&#x2F;O操作可能导致一些新数据被加入cache，而这些新数据可能在近期内并不会被CPU访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可靠性基本理论"><a href="#可靠性基本理论" class="headerlink" title="可靠性基本理论"></a>可靠性基本理论</h2><ul>
<li>可靠度<ul>
<li>可靠度参数(R(t))主要从一个系统能够正常工作的时间长短来描述系统可靠性</li>
<li>定义为：系统在$t_0$时刻正常工作的条件下，在$[t_0, t]$时间区间正常工作的概率 $R(t) &#x3D; p {X &gt; t}$</li>
<li>不可靠度为$F(t) &#x3D; 1 - R(t)$</li>
</ul>
</li>
<li>故障密度函数f(t)（失效密度）<ul>
<li>事后统计：到t时刻在单位时间内发生故障的产品数与最初产品总数之比。</li>
<li>$f(t) &#x3D; \lim _{\Delta t -&gt; 0} \frac{\Delta F(t)}{\Delta t} &#x3D; F’(t) &#x3D; -R’(t)$</li>
</ul>
</li>
<li>故障率$\lambda (t)$（失效率）<ul>
<li>事后统计：到t时刻在单位时间内发生故障的产品数与在时刻t时仍正常产品数之比</li>
<li>$\lambda (t) &#x3D;\frac{f(t)}{R(t)} &#x3D; \frac{F’(t)}{R(t)} &#x3D; \frac{-R’(t)}{R(t)}$</li>
</ul>
</li>
<li>平均寿命MTTF，也记作E(T)<ul>
<li>产品寿命T的数学期望，是f(t)对事件的积分平均值</li>
<li>$E(T) &#x3D; \int _0 ^{\inf} t \cdot f(t)dt &#x3D; \int _0 ^{\inf} R(t)dt$</li>
</ul>
</li>
<li>在一个系统整个寿命周期中，系统失效率随时间的变化规律可以用浴盆曲线来描述<ul>
<li>第一阶段是早期故障期，又称调试期，随着调试进行，早期故障不断排除，进入第二阶段随机故障期，这一时间是正常工作时期，其失效率不随时间变化而变化。随着系统运行时间越来越长，失效率不断增大，系统进入损耗故障期</li>
<li>随机故障期是系统实际使用期，也是系统可靠性建模和分析最关心的时期，这期间系统失效率基本稳定</li>
<li>随机故障期系统的可靠度函数服从指数分布规律$R(t)&#x3D;e^{-\lambda t}$</li>
<li>若产品寿命T的故障密度函数为$f(t)&#x3D;\lambda e^{- \lambda t}$，则称T服从参数为$\lambda$的指数分布</li>
<li>这是系统可靠性建模和分析中很重要的一个特性和假设前提</li>
</ul>
</li>
</ul>
<blockquote>
<p>公式整理<br>可靠度$R(t) &#x3D; 1 - F(t) &#x3D; e^{-\lambda t}$<br>不可靠度$F(t) &#x3D; \int _0 ^t f(t)d(t) &#x3D; 1-e^{-\lambda t}$<br>故障密度函数为$f(t) &#x3D; \lambda e^{-\lambda t}$<br>故障率$\lambda (t) &#x3D; \frac{f(t)}{R(t)} &#x3D; \lambda$<br>平均寿命$MTTF &#x3D; \int _0 ^{\inf} R(t)dt &#x3D; \frac{1}{\lambda}$</p>
</blockquote>
<h3 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a>串联系统</h3><ul>
<li>假设n各部件的工作是相互独立的，第i个部件寿命为$T_i$，可靠度为$R_i&#x3D;P{T_i&gt;t}$，失效率为$\lambda _i(t)$</li>
<li>$T&#x3D;min(T_1, …, T_n)$</li>
<li>可靠度$R(t) &#x3D; P{T&gt;t} &#x3D; \pod R_i (t)$</li>
<li>即可靠度$R(t) &#x3D; \pod _{i&#x3D;1}^k R_i(t)$</li>
</ul>
<h4 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h4><p>若各单元的寿命服从指数分布，则串联系统的寿命也服从于指数分布</p>
<ul>
<li>可靠度$R(t) &#x3D; e^{-\lambda t}$</li>
<li>不可靠度$F(t) &#x3D; 1 - e^{-\lambda t}$</li>
<li>故障密度函数$f(t) &#x3D; \lambda e^{-\lambda t}$</li>
<li>故障率$\lambda (t) &#x3D; \sum \lambda_i (t) &#x3D; \lambda$</li>
<li>平均寿命$MTTF &#x3D; E[T] &#x3D; \frac{1}{\sum \lambda_i} &#x3D; \frac{1}{\lambda}$</li>
</ul>
<h3 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a>并联系统</h3><ul>
<li>假设n各部件的工作是相互独立的，第i个部件寿命为$T_i$，可靠度为$R_i&#x3D;P{T_i&gt;t}$，失效率为$\lambda _i(t)$</li>
<li>$T&#x3D;max(T_1, …, T_n)$</li>
<li>可靠度$R(t) &#x3D; P{T &gt; t} &#x3D; 1-\pod (1 - R_i(t)) &#x3D; \pod_{i&#x3D;1}^m(1-R_i(t))$</li>
<li>不可靠度$F(t) &#x3D; \pod_{i&#x3D;1}^m(F_i(t))$</li>
</ul>
<h4 id="指数分布-1"><a href="#指数分布-1" class="headerlink" title="指数分布"></a>指数分布</h4><p>若各单元寿命服从指数分布时，并联系统寿命<strong>并不服从</strong>指数分布。若个单元相同，则</p>
<ul>
<li>可靠度$R(t) &#x3D; 1- (1$- e^{-\lambda_i t})^m$</li>
<li>不可靠度$F(t) &#x3D; (1-e^{-\lambda_i t})^m$</li>
<li>故障密度函数$f(t) &#x3D; F’(t)$</li>
<li>故障率$\lambda (t) &#x3D; \frac{f(t)}{R(t)} &#x3D; \frac{F’(t)}{R(t)} &#x3D; \frac{-R’(t)}{R(t)}$</li>
<li>平均寿命$MTTF &#x3D; \int <em>0^{\inf} 1-(1-e^{-\lambda_i t})^m dt &#x3D; \frac{1}{\lambda}\sum</em>{i&#x3D;1}^m \frac{1}{i}$</li>
</ul>
<h1 id="互联网络"><a href="#互联网络" class="headerlink" title="互联网络"></a>互联网络</h1><p>互联网络是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中节点之间的相互连接</p>
<ul>
<li>节点：处理器、存储模块或其它设备</li>
<li>在拓扑上，互联网络为输入节点到输出节点之间的一组互联或影响</li>
<li>SIMD计算机和MIMD计算机的关键组成部分</li>
<li>3大要素：互联结构，开关元件，控制方式</li>
</ul>
<h5 id="ICN目的与作用"><a href="#ICN目的与作用" class="headerlink" title="ICN目的与作用"></a>ICN目的与作用</h5><ul>
<li>当前提高计算速度的主要措施，一是改进器件，二是多处理单元并行计算。ICN是供多处理单元传输数据的高速通路，对并行计算时间影响很大。</li>
<li>ICN的主要草所：置换(N-N)，广播(1-N)，选播(1-N’)</li>
</ul>
<h2 id="互联网络的分类"><a href="#互联网络的分类" class="headerlink" title="互联网络的分类"></a>互联网络的分类</h2><ul>
<li>通用&#x2F;专用网<ul>
<li>通用网（原用于计算机之间交换信息的普通网络）</li>
<li>专用网（专用于并行计算系统各处理单元之间并行交换数据的特殊网络）</li>
</ul>
</li>
<li>串行&#x2F;并行网<ul>
<li>串行网（多个节点的发送操作在时间上不能重叠）</li>
<li>并行网（多个节点的发送操作在时间上可以重叠）</li>
</ul>
</li>
<li>同步&#x2F;异步网（并行网再细分）<ul>
<li>同步网（多个节点必须朝同一方向、以同一距离、同时开始发送）</li>
<li>异步网（多个节点可以朝不同方向、以不同距离、不同时开始发送，可能冲突）</li>
</ul>
</li>
<li>静态&#x2F;动态网<ul>
<li>静态网（节点之间有固定连接，且在运行中不能改变的网络）</li>
<li>动态网（节点之间的连接关系不固定，需通过开关导向或地址识别来确定当前的目的节点）</li>
</ul>
</li>
</ul>
<h2 id="互联网络的结构参数与性能指标"><a href="#互联网络的结构参数与性能指标" class="headerlink" title="互联网络的结构参数与性能指标"></a>互联网络的结构参数与性能指标</h2><h3 id="互联网络的结构参数"><a href="#互联网络的结构参数" class="headerlink" title="互联网络的结构参数"></a>互联网络的结构参数</h3><ul>
<li>网络通常是用有向边或无向边连接有限个节点的图来表示</li>
<li>互联网的主要特性参数有<ul>
<li>网络规模N：网络中节点的个数<ul>
<li>表示该网络所能连接的部件的数量</li>
</ul>
</li>
<li>节点度d：与节点相连接的边数（通道数），包括入度和出度<ul>
<li>进入节点的边叫入度</li>
<li>从节点出来的边叫出度</li>
</ul>
</li>
<li>节点距离：对于网络中的任意两个节点，从一个节点触发到另一个节点终止所需要跨越的边数的最小值</li>
<li>网络直径D:网络中任意两个节点之间距离的最大值<ul>
<li>网络直径应尽可能的小</li>
</ul>
</li>
<li>等分宽度b：把由N各节点构成的网络切成节点数相同(N&#x2F;2)的两半，在各种切法中，沿切口边数的最小值<ul>
<li>线等分宽度：$B&#x3D;b \times w$<ul>
<li>w为通道宽度（用位表示）</li>
<li>该参数主要反映了网络最大流量</li>
</ul>
</li>
</ul>
</li>
<li>对称性：从任何节点看到的拓扑结构都相同的网络称为对称网络<ul>
<li>对称网络的实现比较容易，也容易编程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="静态互联网络"><a href="#静态互联网络" class="headerlink" title="静态互联网络"></a>静态互联网络</h2><ul>
<li>线性阵列：一种一维的线性网络，其中N各节点用N-1各链路连接成一行<ul>
<li>端节点的度：1</li>
<li>其余节点的度：2</li>
<li>直径：N-1</li>
<li>等分宽度b：1</li>
<li>线性阵列与总线的区别：<ul>
<li>总线式通过切换与其连接的许多节点来实现时分特性的</li>
<li>线性阵列允许不同的源节点和目的节点对并行地使用其不同的部分</li>
</ul>
</li>
</ul>
</li>
<li>环和带弦环<ul>
<li>环：用一条附加链路将线性阵列的两个端点连接起来而构成。可以单向工作，也可以双向工作<ul>
<li>对称</li>
<li>节点的度：2</li>
<li>双向环的直径：N&#x2F;2</li>
<li>单向环的直径：N-1</li>
<li>环的等分宽度b：2</li>
</ul>
</li>
<li>带弦环<ul>
<li>增加的链路越多，节点度越高，网络直径就越小</li>
</ul>
</li>
</ul>
</li>
<li>全连接网络：每个节点都和剩下的其它节点有直接连接<ul>
<li>节点的度：N-1</li>
<li>直径：1</li>
</ul>
</li>
<li><strong>循环移数网络</strong>：通过在环上每个节点到所有与其距离位2的证书幂的节点之间都增加一条附加链而构成<ul>
<li>如果$|j - i| &#x3D; 2^r$，则节点i与节点j连接</li>
<li><strong>节点的度</strong>：2n-1，其中$n&#x3D;log_2 N$</li>
<li><strong>直径</strong>：$\lceil \frac{n}{2} \rceil$</li>
<li>网络规模：$N&#x3D;2^n$</li>
</ul>
</li>
<li>树形和星形<ul>
<li>树形：二叉树</li>
<li>一棵k层完全平衡的二叉树有N&#x3D;2k-1个节点</li>
<li>最大节点度：3</li>
<li>直径：2(k-1)</li>
<li>等分宽度b&#x3D;1</li>
</ul>
</li>
<li>星形<ul>
<li>最大节点度：N-1</li>
<li>直径较小，是2</li>
<li>等分宽度$b&#x3D;\lfloor \frac{N}{2} \rfloor$</li>
<li>可靠性交叉，中心节点处故障，这个系统就会瘫痪</li>
</ul>
</li>
<li>胖树形</li>
<li>网格形和环网形<ul>
<li>网格形<ul>
<li>一个规模为$N&#x3D;n \times n$的2维网格形网络<ul>
<li>内部节点的度：4</li>
<li>边节点的度：3</li>
<li>角节点的度：2</li>
<li>网络直径D：2(n-1)</li>
<li>等分宽度b：n</li>
</ul>
</li>
<li>一个由$N&#x3D;n^k$个节点构成的k维网格形网络（每维n个节点）的内部节点度d&#x3D;2k，网络直径D&#x3D;k(n-1)</li>
</ul>
</li>
<li><strong>Illiac网络</strong><ul>
<li>把2维网格形状网络的每一列的两个端节点连接起来，再把每一行的尾节点与下一行的头节点连接起来，并把最后一行的尾节点与第一行的头节点连接起来</li>
<li>一个规模为$n \times n$的Illiac网络<ul>
<li>所有节点的度：4</li>
<li>网络直径D：n-1</li>
<li>等分宽度b：2n</li>
</ul>
</li>
</ul>
</li>
<li>环网形<ul>
<li>把2维网格形网络的每一行的两个端点连接起来，把每一列的两个端节点也连接起来</li>
<li>将环形和网格形组合再一起，并能向高维扩展</li>
<li>一个规模为$n \times n$的环网形网<ul>
<li>节点度：4</li>
<li>网络直径：$2 \times \lfloor \frac{n}{2} \rfloor$</li>
<li>等分宽度b：2n</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="互连函数"><a href="#互连函数" class="headerlink" title="互连函数"></a>互连函数</h2><p>变量x：输入</p>
<p>函数f(x)：输出</p>
<p>通过数学表达式简历输入端号与输出端号的连接关系。即在互连函数f的作用下，输入端x连接到输出端f(x)</p>
<p>互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系</p>
<h3 id="几种基本的互连函数"><a href="#几种基本的互连函数" class="headerlink" title="几种基本的互连函数"></a>几种基本的互连函数</h3><ul>
<li>恒等函数：实现同号输入端和输出端之间的连接<ul>
<li>$I(x_{n-1}…x_1x_0) &#x3D; x_{n-1}…x_1x_0$</li>
</ul>
</li>
<li>交换函数：实现二进制地址编码中第k位互反的输入端与输出端之间的连接<ul>
<li>$E(x_{n-1}…x_{k+1}x_kx_{k-1}…x_0) &#x3D; x_{n-1}…x_{k+1}\overline{x_k}x_{k-1}…x_0$</li>
<li>主要用于构造立方体互连网络和各种超立方体互连网络</li>
<li>共有$n&#x3D;log_2 N$中互连函数（N位节点个数）</li>
<li>当N&#x3D;8，n&#x3D;3时，可得到常用的立方体互连函数<ul>
<li>$Cube_0(x_2x_1x_0)&#x3D;x_2x_1\overline{x_0}$</li>
<li>$Cube_1(x_2x_1x_0)&#x3D;x_2\overline{x_1}x_0$</li>
<li>$Cube_3(x_2x_1x_0)&#x3D;\overline{x_2}x_1x_0$</li>
</ul>
</li>
</ul>
</li>
<li>均匀洗牌函数：将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）<ul>
<li>也称为混洗函数（置换）</li>
<li>$\sigma(x_{n-1}…x_0)&#x3D;x_{n-2}…x_0x_{n-1}$</li>
<li>即把输入端的二进制编号循环左移一位</li>
<li>$\sigma^{(n)}(X) &#x3D; \sigma _{(n)}(X) &#x3D; \sigma(X)$</li>
<li>$\sigma ^{(1)} &#x3D; \sigma _{(1)}(X) &#x3D; X$</li>
<li>逆均匀洗牌函数：将输入端的二进制编号循环右移一位而得到所有连接的输出端编号</li>
</ul>
</li>
<li>碟式函数：把输入端的二进制编号的最高位于最低为互换位置，便得到输出端的编号<ul>
<li>$\beta(x_{n-1}…x_1x_0) &#x3D; x_0x_{n-2}…x_1x_{n-1}$</li>
<li>第k个子函数：$\beta <em>{(k)}(x</em>{n-1}…x_kx_{k-1}x_{k-2}…x_1x_0)&#x3D;x_{n-1}…x_kx_0x_{k-2}…x_1x_{k-1}$<ul>
<li>把输入端的二进制编号的低k位中的最高位与最低位互换</li>
</ul>
</li>
<li>第k个超函数：$\beta ^{(k)}(x_{n-1}x_{n-2}…x_{n-j+1}x_{n-k}x_{n-k-1}…x_1x_0)&#x3D;x_{n-k}x_{n-2}…x_{n-k+1}x_{n-1}x_{n-k-1}…x_1x_0$<ul>
<li>把输入端的二进制编号位中的高k位中的最高位与最低位互换</li>
</ul>
</li>
<li>$\beta ^{(n)}(X) &#x3D; \beta _{(n)}(X) &#x3D; \beta(X)$</li>
<li>$\beta ^{(1)} &#x3D; \beta _{(1)}(X) &#x3D; X$</li>
</ul>
</li>
<li>反位序函数：将输入端二进制编号的位序颠倒过来得相应输出端的编号<ul>
<li>$\rho(x_{n-1}x_{n-2}…x_1x_0)&#x3D;x_0x_1…x_{n-2}x_{n-1}$</li>
<li>第k个子函数：$\rho <em>{(k)}(x</em>{n-1}…x_kx_{k-1}x_{k-2}…x_1x_0)&#x3D;x_{n-1}…x_kx_0x_1…x_{k-2}x_{k-1}$<ul>
<li>把输入端的二进制编号的低k位中各位的次序颠倒过来</li>
</ul>
</li>
<li>第k个超函数：$\rho ^{(k)}(x_{n-1}x_{n-2}…x_{n-k+1}x_{n-k}x_{n-k-1}…x_1x_0)&#x3D;x_{n-k}x_{n-k+1}…x_{n-2}x_{n-1}x_{n-k-1}…x_1x_0$<ul>
<li>把输入的那的二进制编号的高k位中各位的次序颠倒过来</li>
</ul>
</li>
<li>$\rho ^{(n)}&#x3D;\rho _{(n)}(X) &#x3D; \rho(X)$</li>
<li>$\rho ^{(1)}(X) &#x3D; \rho _{(1)}(X) &#x3D; X$</li>
</ul>
</li>
<li>移数函数：将各输入端都错开一定的位置（模N）后连到输出端<ul>
<li>$\alpha (x) &#x3D; (x \pm k) mod N$</li>
</ul>
</li>
<li>PM2I函数<ul>
<li>P和M分别表示加和减，2I表示$2^i$<ul>
<li>即“加减$2^i$”函数</li>
</ul>
</li>
<li>移数函数的一种，将各输入端都错开一定的位置（模N）后连接到输出端</li>
<li>$PM2_{+i}(x) &#x3D; x + 2^i mod N$</li>
<li>$PM2_{-i}(x) &#x3D; x - 2^i mod N$</li>
<li>PM2I互连网络供有2n个互连函数</li>
</ul>
</li>
</ul>
<h4 id="子函数与超函数"><a href="#子函数与超函数" class="headerlink" title="子函数与超函数"></a>子函数与超函数</h4><ul>
<li>互联函数（设为s）的第k个子函数：把s作用于输入端的二进制编号位的底k位，记作$s_{(k)}$</li>
<li>互联函数（设为s）的第k个超函数：把s作用于输入端的二进制编号位的高k位，记作$s^{(k)}$</li>
</ul>
<h4 id="逆函数"><a href="#逆函数" class="headerlink" title="逆函数"></a>逆函数</h4><p>对于任意一种函数f(x)，如果存在g(x)，使得$f(x) \times g(x) &#x3D; I(x)$，则称g(x)是f(x)的逆函数，记作$f^{-1}(x)$</p>
<h4 id="单级ICN"><a href="#单级ICN" class="headerlink" title="单级ICN"></a>单级ICN</h4><ul>
<li>定义：单级ICN只使用一级开关。开关的每种接通组合方式可用一个互连函数表示</li>
<li>在互连函数中，<ul>
<li>N表示节点数</li>
<li>$n&#x3D;log_2N$表示维数</li>
<li>$j&#x3D;X_{n-1}…X_0$表示节点</li>
<li>编号的二进制形式，位数位n</li>
</ul>
</li>
</ul>
<h3 id="单级立方体网"><a href="#单级立方体网" class="headerlink" title="单级立方体网"></a>单级立方体网</h3><ul>
<li>该网络由立方体函数定义，立方体函数族有n个成员，$Cube_0, …, Cube_{n-1}$</li>
<li>最坏情况下传输需对输入节点编号的全部n位取反，所以单级立方体网络直径是n，成本$N \cdot log_2 N$</li>
<li>立方体函数性质：结合律、交换律以及自反律</li>
</ul>
<h3 id="单级混洗——交换网"><a href="#单级混洗——交换网" class="headerlink" title="单级混洗——交换网"></a>单级混洗——交换网</h3><ul>
<li>该网络由混洗函数与交换函数定义</li>
<li>混洗函数定义<ul>
<li>shuffle(j) &#x3D; 2j mod (N-1), 当j &lt; N-1</li>
<li>shuffle(j) &#x3D; N-1, 当j &#x3D; N-1</li>
</ul>
</li>
<li>网络直径是2n-1,成本$N \cdot 2$<blockquote>
<p>e.g. 当n&#x3D;3的混洗网络还不足以构成一个连通图，所以还要加上一个$Cube_0$函数，才能偶构成完整的单级混洗——交换网络</p>
</blockquote>
</li>
</ul>
<h3 id="单级加减-2-i-网"><a href="#单级加减-2-i-网" class="headerlink" title="单级加减$2^i$网"></a>单级加减$2^i$网</h3><ul>
<li>该网络由PM2I函数定义，PM2I函数供有n对成员，分别是$PM2_{\pm 0}, PM2_{\pm 1}, …, PM2_{\pm (n-1)}$</li>
<li>性质1：对相同的i值，$PM2_{+i}$与$PM2_{-i}$函数的传送路径相同，方向相反</li>
<li>性质2：$PM2_{+(n-1)} &#x3D; PM2_{-(n-1)}$，所以单级PM2I网络实际只能实现2n-1种不同的置换</li>
<li>单级PM2I网络的直径是$\lceil \frac{n}{2} \rceil$</li>
<li>成本$N(2 \times log_2 N -1)$</li>
<li>该网络包含多个强连通子图（即除去若干边以后仍能保证任何一对节点互相可达），所以这2n个函数并不是实现互联网的最小集合。实际应用中，可以使用他们的一个子集来构造互连网。</li>
</ul>
<h2 id="单级ICN寻径算法"><a href="#单级ICN寻径算法" class="headerlink" title="单级ICN寻径算法"></a>单级ICN寻径算法</h2><p>符号约定：起点$x&#x3D;x_{n-1}…x_0$，终点$y&#x3D;y_{n-1}…y_0$</p>
<ul>
<li>单级立方体网<ul>
<li>二者间路径由地址逻辑差$y_i \oplus x_i$决定。若$y_i \oplus x_i&#x3D;&#x3D;1$则代表$Cube_i$维需要走一步。各个维度先后顺序可任意安排。“1”的个数即位总步数</li>
</ul>
</li>
<li>单级混洗-交换网<ul>
<li>二者间路径也由地址逻辑差$y_i \oplus x_i$决定。如果$y_i \oplus x_i &#x3D;&#x3D; 1$表明$x_i$必须先经过n-i步shuffle到最低位，1步$Cube_0$求反，再经i步shuffle回到原位变成$y_i$。如有多位“1”，可以合并shuffle。</li>
</ul>
</li>
</ul>
<h2 id="动态互连网络"><a href="#动态互连网络" class="headerlink" title="动态互连网络"></a>动态互连网络</h2><h3 id="总线网络"><a href="#总线网络" class="headerlink" title="总线网络"></a>总线网络</h3><ul>
<li>由一组导线和插座构成，经常被i用来实现计算机系统中处理机模块、存储模块和外围设备之间的互连。<ul>
<li>每一次总线只能用于一个源（主部件）到一个或多个目的（从部件）之间的数据传送</li>
<li>多个功能模块之间的竞争总线或时分总线</li>
<li>特点：<ul>
<li>结构简单、实现成本低、带宽较窄</li>
</ul>
</li>
</ul>
</li>
<li>一种由总线连接的多处理机系统<ul>
<li>系统总线再处理机、I&#x2F;O子系统、主存储器以及辅助存储设备（磁盘、磁带机）之间提供了一条公用通路</li>
<li>设备总线通常设置再印刷电路板底板上。处理器板、存储器板和设备接口板都通过插座或电缆插入底板</li>
</ul>
</li>
<li>解决总线带宽较窄问题：采用多总线或多层次的总线<ul>
<li>多总线：设置多条总线<ul>
<li>为不同的功能设置专用的总线</li>
<li>重复设置相同功能的总线</li>
</ul>
</li>
<li>多层次的总线式按层次的架构设置速度不同的总线，使得不同速度的模块有比较适合的总线连接</li>
</ul>
</li>
</ul>
<h3 id="交叉开关网络"><a href="#交叉开关网络" class="headerlink" title="交叉开关网络"></a>交叉开关网络</h3><ul>
<li>单级开关网络<ul>
<li>交叉点开关能在对偶（源、目的）之间形成动态连接，同时实现多个对偶之间的无阻塞连接</li>
<li>带宽和互连特性最好</li>
<li>一个$n \times n$的交叉开关网络，可以无则色地实现$n!$中置换</li>
<li>对一个$n\times n$的交叉开关网络来说，需要$n^2$套交叉开关以及大量的连线。</li>
</ul>
</li>
<li>C.mmp多处理机的互连结构<ul>
<li>用16×16的交叉开关网络把16台处理机与16个存储模块连接在一起</li>
<li>最多可同时实现16台处理机对16个不同存储模块的并行访问<ul>
<li>每个存储模块一次只能满足一台处理机的请求</li>
<li>当多个请求要同时访问同一存储模块时，交叉开关就必须分解所发生的冲突，每一列只能接通一个交叉点开关。</li>
<li>为了支持并行（或交叉）存储器访问，可以在同一行中接通一个交叉点开关</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多级互连网络"><a href="#多级互连网络" class="headerlink" title="多级互连网络"></a>多级互连网络</h3><p>MIMD和SIMD计算机都采用多级互连网络MIN(Multistage Interconnection Network)</p>
<ul>
<li>由a×b开关模块和级间连接构成的通用多级互连网络结构</li>
<li>每一级都用了多个a×b开关<ul>
<li>a个输入和b个输出</li>
<li>在理论上，a和b不一定相等，然而实际上a和b经常选为2的整数幂，即$a&#x3D;b&#x3D;2^k$</li>
<li>相邻各级开关之间都有固定的级间连接</li>
</ul>
</li>
</ul>
<h4 id="多级ICN"><a href="#多级ICN" class="headerlink" title="多级ICN"></a>多级ICN</h4><ul>
<li>定义：多级ICN使用多级开关，使得数据在一次通过网络的过程中可以实现的置换种类更多</li>
<li>通常在N个节点的网络中，多级ICN由n级构成($n&#x3D;log_2 N$)</li>
<li>经典的多级互连网有多级立方体网、多级混洗-交换网和多级PM2I网</li>
<li>多级立方体网和多级混洗-交换网不使用单级互联网中的那种多路选择开关而是用一种2输入&#x2F;2输出的二元交换开关，以减少开关总数。二元交换开关基本接通状态有“直连”、“交换”、“上播”、“下播”，进行数据置换时只能使用前两种。</li>
<li>各种多级互连网络的区别在于所用开关模块、控制方式和级间互连模式的不同<ul>
<li>控制方式：对各个开关模块的控制方式<ul>
<li>级控制：每一级所有开关只用一个控制信号控制，只能同时处于同一种状态。</li>
<li>部分级控制：第i级的所有开关分别用i+1个信号控制</li>
<li>单元空hi：每一个开关都有一个独立的控制信号，可各自处于不同的状态。各开关动作独立，性能比前两种方式都更灵活，结构也更复杂</li>
</ul>
</li>
<li>常用的级间互连模式<ul>
<li>均匀洗牌、碟式、多路洗牌、纵横交叉、立方体连接等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多级混洗-交换网络"><a href="#多级混洗-交换网络" class="headerlink" title="多级混洗-交换网络"></a>多级混洗-交换网络</h4><p>由n级构成，每一级包含一个无条件混洗拓扑线路和一列可控的二元交换开关，前后重复。各级编号是n-1,…,0，降序排列</p>
<ul>
<li>单独一级混洗拓扑线路可完成一次数据混洗</li>
<li>单独一列二元交换开关在处于“交换”状态时可完成一次交换操作($Cube_0$)</li>
<li>如果各级二元交换开关都处于“直连”状态，N个节点的数据通过网络仅经过n次混洗操作，排列顺序最终恢复输入状态（混洗函数性质2）</li>
<li>如果各级二元交换开关都处于“交换”状态，则N个节点的数据在每次混洗之后紧接着一次交换($Cube_0$)，也就是地址码的最低位取反，最后n位地址均被取反</li>
</ul>
<h4 id="多级混洗-交换网络寻径算法"><a href="#多级混洗-交换网络寻径算法" class="headerlink" title="多级混洗-交换网络寻径算法"></a>多级混洗-交换网络寻径算法</h4><ul>
<li>目的：根据给定的输入&#x2F;输出对应关系，确定各开关的状态</li>
<li>名称：源-目的地址异或法</li>
<li>操作：将任意一个输入地址与它要到达的输出地址做异或运算，其结果的$bit_i$位控制数据到达的第i级开关。“0”表示“直连”，“1”表示“交换”</li>
</ul>
<h1 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h1><h3 id="并行计算机系统结构的分类"><a href="#并行计算机系统结构的分类" class="headerlink" title="并行计算机系统结构的分类"></a>并行计算机系统结构的分类</h3><ul>
<li>Flynn分类法<ul>
<li>SISD,SIMD,MISD,MIMD</li>
</ul>
</li>
<li>MIMD已称为通用多处理器系统结构的选择<ul>
<li>MIMD具有灵活性</li>
<li>MIMD可以充分利用商品化微处理器在性能价格比方面的优势<blockquote>
<p>多处理机系统是MIMD计算机的一种实现类型，也是已经商品化的MIMD的唯一形式。<br>多处理机系统由多态处理机连接而成，能够并行执行独立的程序模块，并且相互通信和同步，以实现作业、任务级的并行。<br>MIMD计算机与SIMD计算机的主要区别，在于SIMD只能在同一时刻做多件相同的事情，而MIMD却可以在同一时刻做多件相同或不同的事情（多至零六所致），所以求解同一个问题时采用MIMD将能实现更大比例的并行操作，即处理效率更高。<br>从并行处理的级别看，SIMD是数据级并行处理，流水线是指令级并行处理，MIMD是任务级并行处理</p>
</blockquote>
</li>
</ul>
</li>
<li>根据存储器的组织结构，把现有的MIMD机器分为两类<ul>
<li>集中式共享存储器结构<ul>
<li>最多由几十个处理器构成。各处理器共享集中式物理存储器。也称为<ul>
<li>SMP机器 Symmetric Shared-memory Multiprocessor</li>
<li>UMA机器 Uniform Memory Access</li>
</ul>
</li>
</ul>
</li>
<li>分布式存储器多处理机<ul>
<li>存储器在物理上是分布的。支持较大规模多处理机系统</li>
<li>每个节点包含<ul>
<li>处理器，cache</li>
<li>I&#x2F;O</li>
<li>存储器</li>
<li>互连网络接口</li>
</ul>
</li>
<li>在许多情况下，分布式存储器结构优于集中式共享存储器结构</li>
<li>优点：<ul>
<li>如果大多数的访问是针对本节点的局部存储器，则可降低对存储器和互连网络的带宽要求</li>
<li>对本地存储器的访问延迟时间小</li>
</ul>
</li>
<li>最主要缺点：处理器间的通信较复杂，且各处理器间访问延迟较大</li>
<li>簇：超级节点<ul>
<li>每个节点内包含个数较少（2~8）的处理器</li>
<li>处理器之间可采用另一种互连技术（如总线）相互连接形成簇</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储器系统结构和通信机制"><a href="#存储器系统结构和通信机制" class="headerlink" title="存储器系统结构和通信机制"></a>存储器系统结构和通信机制</h3><ul>
<li>两种存储器系统结构<ul>
<li>共享地址空间<ul>
<li>物理上分离的所有存储器作为一个同一的逻辑空间进行编址。</li>
<li>任何一个处理器可以访问该共享空间中的任何一个单元（具有访问权），而且不同处理器上的同一个物理地址指向的是同一个存储单元</li>
<li>称为：分布式共享存储器系统(DSM: Distributed Shared-Memory)，NUMA机器(Non-Uniformed Memeory Access)</li>
</ul>
</li>
<li>把每个节点中的存储器编址位一个独立地址空间，不同节点中的地址空间是相互独立的<ul>
<li>整个系统的地址空间由多个独立的地址空间构成</li>
<li>每个节点中的存储器只能由本地处理器访问，远程处理器不能直接对其进行访问</li>
<li>每一个处理器-存储器模块实际上是一台单独计算机</li>
<li>多以集群的形式存在</li>
</ul>
</li>
</ul>
</li>
<li>通信机制<ul>
<li>共享存储器通信机制<ul>
<li>共享地址空间的计算机系统采用</li>
<li>处理器间通过load&#x2F;store指令对相同存储器地址读&#x2F;写来实现</li>
</ul>
</li>
<li>消息传递通信机制<ul>
<li>多个独立地址空间的计算机采用</li>
<li>通过处理器间显式地传递消息来完成</li>
<li>消息传递多处理机中，处理器间通过发送消息通信，这些消息请求进行某些操作或者传送数据。</li>
<li>当一个处理器要对远程存储器上的数据进行访问或操作时<ul>
<li>发送消息，请求传递数据或对数据进行操作（远程调用RPC, Remote Process Call）</li>
<li>目的处理器接受到消息后，执行相应操作或代替远程处理器进行访问，并发送应答消息返回结果</li>
</ul>
</li>
<li>同步消息传递：请求处理器发送一个消息后一直要等到应答结果才继续运行</li>
<li>异步消息传递：数据发送方知道别处理器需要数据，通信也可以从数据发送方开始，数据可不经请求就直接送往数据接收方</li>
</ul>
</li>
</ul>
</li>
<li>不同通信机制的优点<ul>
<li>共享存储器通信<ul>
<li>与通常对称式多处理机的通信机制兼容</li>
<li>易于变成，在简化编译器设计方面有优势</li>
<li>采用大家熟悉的共享存储器模型开发应用程序，把重点放到解决对性能影响较大的数据访问上</li>
<li>通信数据量较小时，通信开销较低，带宽利用较好</li>
<li>可通过cache技术减少远程通信频度，减少通信延迟以及对共享数据访问冲突</li>
</ul>
</li>
<li>消息传递通信机制<ul>
<li>硬件较简单</li>
<li>显式通信，更容易搞清何时发生通信以及通信开销是多少</li>
<li>显式通信可让编程者重点注意并行计算的主要通信开销，使之有可能开发出结构更好、性能更高的并行程序</li>
<li>同步很自然地与发送消息相关联，能减少不当同步带来错误的可能性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="并行处理面临的挑战"><a href="#并行处理面临的挑战" class="headerlink" title="并行处理面临的挑战"></a>并行处理面临的挑战</h3><ul>
<li>程序中的并行性优先</li>
<li>相对较大的通信开销</li>
</ul>
<p>多处理机加快运算速度的基本原理是并行计算，即把一个程序分成n等份交给n个处理机同时执行。但是实现难度较大。</p>
<ol>
<li>程序中总有一定比例的不可并行部分，如I&#x2F;O操作</li>
<li>划分开的个部分之间需要通信（同步、互斥），分得越细通信越频繁，而单处理机算法中几乎不需要通信（即使进程间需要通信，时间开销也小到可以忽略）</li>
<li>多处理机分类中的多计算机系统的通信方式是机外传输，每次时间开销比机内开销大成百上千倍</li>
</ol>
<p>对算法的要求：1. 较高的可并行化比例；2. 较低的进程间通信量</p>
<ul>
<li>问题的解决：  <ul>
<li>并行性不足：采用并行性更好的算法</li>
<li>远程访问延迟的降低：考系统结构支持和编程技术</li>
</ul>
</li>
</ul>
<p>在并行处理中，影响性能（负载平衡、同步和存储器访问延迟等）的关键因素常依赖于：应用程序的高层特性，如数据的分配，并行算法的结构以及在空间和时间上对数据的访问模式等</p>
<p>依据特点可把多机工作负载大致分成两类：单个程序在多处理机上的并行工作负载&amp;多个程序在多处理机上的并行工作负载</p>
<p>并行程序的计算&#x2F;通信比率，是反映并行程序性能的一个重要度量。计算&#x2F;通信比率随着处理数据规模的增大而增加，随着处理器数目的增加而减少。</p>
<h2 id="对称式共享存储器系统结构"><a href="#对称式共享存储器系统结构" class="headerlink" title="对称式共享存储器系统结构"></a>对称式共享存储器系统结构</h2><ul>
<li>多个处理器通过共享总线共享了一个存储器</li>
<li>大容量、多级cache降低对内存带宽和总线带宽的要求</li>
<li>支持对共享数据和私有数据cache的缓存<ul>
<li>私有数据供一个单独的处理器使用</li>
<li>共享数据则是供多个处理器使用</li>
</ul>
</li>
<li>共享数据进入cache产生了一个新的问题<ul>
<li>cache一致性问题</li>
</ul>
</li>
</ul>
<h3 id="多处理机cache一致性"><a href="#多处理机cache一致性" class="headerlink" title="多处理机cache一致性"></a>多处理机cache一致性</h3><ul>
<li>多处理机的cache一致性问题<ul>
<li>允许共享数据进入cache，就可能出现多个处理器的cache中都有同一存储块的副本。</li>
<li>当其中某个处理对其cache中的数据进行修改后，就会使得其cache中的数据与其它cache中的数据不一致</li>
</ul>
</li>
<li>存储器的一致性：如果对某个数据项的任何度操作均可得到其最新写入的值，则认为这个存储系统是一致的<ul>
<li>存储系统行为的两个不同方面<ul>
<li>what：度操作得到的是什么值</li>
<li>when：什么时候才能将已写入的值返回给度操作</li>
</ul>
</li>
<li>存储器是一致的，当满足以下条件<ul>
<li>处理器P对单元X进行一次写之后又对单元X进行读，读和写之间没有其它处理器对单元X进行写，则P读到的值总是前面写进去的值</li>
<li>处理器P对单元X进行写之后，零一处理器Q对单元X进行读，读和写之间无其它写，则Q读到的值应位P写进去的值</li>
<li>对同意单元的写是串行化的，即任意两个处理器对同一单元的两次写，从各处理器的角度看来顺序都是相同的</li>
</ul>
</li>
<li>重要假设<ul>
<li>直到所有的处理器均看到了写的结果，这个写操作才算完成</li>
<li>处理器的任何访存均不能改变写的顺序。即允许处理器对读进行重新排序，但必须以程序规定的顺序进行写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现一致性的基本方案"><a href="#实现一致性的基本方案" class="headerlink" title="实现一致性的基本方案"></a>实现一致性的基本方案</h3><ul>
<li>在一致的多处理机中，cache提供两种功能<ul>
<li>共享数据的迁移：减少了对远程共享数据的访问延迟，也减少了对共享存储器带宽的要求</li>
<li>共享数据的赋值：不仅减少了访问共享数据的延迟，也减少了访问共享数据所产生的冲突</li>
<li>一般情况下，小规模对处理机是采用硬件的方法来实现cache的一致性</li>
</ul>
</li>
<li>cache一致性协议：在多个处理器中用来维护一致性的协议<ul>
<li>关键：跟踪记录共享数据快的状态</li>
<li>两类协议（采用不同技术跟踪共享数据状态）<ul>
<li>监听式协议(snooping)<ul>
<li>每个cache除了包含物理存储器中块的数据拷贝外，也保存着各块的共享状态信息</li>
<li>所有cache都可以通过某种广播介质访问，所有cache控制器监听总线来判断它们是否有总线上请求的数据块</li>
</ul>
</li>
<li>目录式协议(directory)<ul>
<li>物理存储器中数据块的共享状态被保存位一个称为目录的地方。开销稍大于前者，但可用于实现更大规模的的多处理机。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>采用两种方法来解决cache一致性问题<ul>
<li>写作废协议：在处理器对某数据项写入之前，保证它拥有对该数据项的唯一访问权（作废其它副本）</li>
<li>写更新协议：当一个处理器对某数据项进行写入时，通过广播使其它cache中所有对应于该数据项的副本进行更新</li>
<li>性能差异<ul>
<li>在对同一个数据进行多次写操作而中间无操作时，写更新协议需进行多次广播，而写作废协议之需要一次作废操作</li>
<li>在对同一cache块的多个字进行操作时，写更新协议对于每一个写操作都要进行一次广播，而写作废协议仅在对该块的第一次写时进行作废操作即可（写操作是针对cache块的，写更新则是针对字&#x2F;字节）</li>
<li>考虑从一个处理器A进行写操作后到另一个处理器B能都读到该写入数据之间的延迟时间（写更新协议的延迟时间较小）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="监听协议的实现"><a href="#监听协议的实现" class="headerlink" title="监听协议的实现"></a>监听协议的实现</h3><ul>
<li>监听协议的基本实现技术<ul>
<li>实现写作废协议的关键：使用广播介质执行作废（假定采用的是总线）<ul>
<li>当一个处理器cache响应本地CPU访问时涉及全局操作，cache控制器需取得总线访问权后，在总线上发相应消息。</li>
<li>所有处理器都一直在监听总线，检测总线上的地址是否在它们的cache中。若在，则相应处理。</li>
</ul>
</li>
<li>写操作的串行化：由总线实现（获取总线控制权的顺序性）</li>
</ul>
</li>
<li>cache发送到总线上的消息主要有以下两种<ul>
<li>RdMiss——读不命中</li>
<li>WtMiss——写不命中</li>
<li>需要通过总线找到相应数据块的最新副本，然后调入本地cache中。<ul>
<li>写穿cache：因为所有写入的数据同时都被写回主存，所以从主存中总可以取到其最新的值</li>
<li>写回cache：得到数据的最新值会困难一些，因为最新值可能在某个cache中，也可能在主存中（不用掌握）</li>
</ul>
</li>
<li>有的监听协议还增设了invalidate消息，用来通知其它各处理器作废其cache中相应的副本<ul>
<li>与WtMiss的区别：invalidate不引起调块</li>
</ul>
</li>
<li>cache的标识(tag)可直接用来实现监听</li>
<li>修改位——最新副本（写回法）</li>
<li>作废一个块只需将其有效位置为无效</li>
<li>给每个cache块增设一个共享位<ul>
<li>“1”：该块是被多个处理器所共享</li>
<li>“0”：仅被某个处理器所独占</li>
<li>块的拥有者：拥有该数据块的唯一副本的处理器</li>
</ul>
</li>
</ul>
</li>
<li>监听协议距离<ul>
<li>在每个节点内嵌入一个有限状态控制器<ul>
<li>该控制器根据来自处理器或总线的请求以及cache块的状态，做出相应的响应</li>
</ul>
</li>
<li>每个数据块的状态取以下3种状态中的一种<ul>
<li>无效(Ivalid): cache中该块的内容为无效</li>
<li>共享(Shared): 该块可能处于共享状态<ul>
<li>在多个处理器中都有副本，这些副本都相同，且与存储器中响应的块相同</li>
</ul>
</li>
<li>已修改(Modified): 该块已经被修改过，并且还没写入存储器（块中的内容是最新的，系统中唯一的最新副本）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式共享存储器系统结构"><a href="#分布式共享存储器系统结构" class="headerlink" title="分布式共享存储器系统结构"></a>分布式共享存储器系统结构</h2><h3 id="目录协议的基本思想"><a href="#目录协议的基本思想" class="headerlink" title="目录协议的基本思想"></a>目录协议的基本思想</h3><ul>
<li>广播和监听的机制使得监听一致性协议的可扩放性很差</li>
<li>寻找替代监听协议的一致性协议</li>
</ul>
<p>即使用目录协议 </p>
<ul>
<li>目录协议<ul>
<li>目录：一种集中的数据结构。对于存储器中的每一个可以调入cache的数据块，在目录中设置一条目录项，用于记录该块的数据状态以及那些cache中有副本等相关信息</li>
<li>特点<ul>
<li>对于任何一个数据块，都可以快速地在唯一的一个位置中找到相关的信息。这使一致性协议避免了广播操作</li>
</ul>
</li>
<li>位向量：记录哪些cache中有副本<ul>
<li>每一位对应于一个处理器</li>
<li>长度与处理器的个数成正比</li>
<li>由位向量指定的处理机的集合称为共享集S</li>
</ul>
</li>
<li>分布式目录<ul>
<li>目录与存储器一起分布到各结点中，从而对于不同目录内容的访问可以在不同的节点进行。</li>
</ul>
</li>
<li>最简单的实现方案：对于存储器中每一块都在目录中设置一项。目录中的信息量与M×N成正比。<ul>
<li>M：存储器中存储块的总数</li>
<li>N：处理器的个数</li>
<li>由于M&#x3D;K×N，K是每个处理器中存储块的数量，所以如果K保持不变，则目录中的信息量就与$N^2$成正比</li>
</ul>
</li>
</ul>
</li>
<li>在目录协议中，存储块的状态有3种<ul>
<li>未缓冲：该块尚未被调入cache，所有处理器的cache中都没有这个块的副本</li>
<li>共享：该块在一个或多个处理机上有这个块的副本， 且这些副本与存储器中的该块相同。</li>
<li>独占：仅有一个处理机有这个块的副本，且该处理机已经对其进行了写操作，所以其内容是最新的，而存储器中该块的数据已经过时。</li>
</ul>
</li>
<li>本地节点、宿主节点以及远程节点的关系<ul>
<li>本地节点：发出访问请求的节点</li>
<li>宿主节点：包含所访问的存储单元及其目录项的节点</li>
<li>远程节点：包含cache block的副本</li>
</ul>
</li>
<li>在节点之间发送的消息<ul>
<li>本地节点发给宿主节点（目录）的消息<ul>
<li>P：发出请求的处理机编号，K：所要访问的地址</li>
<li>RdMiss(P, K): 处理机P读取地址位K的数据时不命中，请求宿主节点提供数据（块），并要求把P加入共享集</li>
<li>WtMiss(P, K): 处理机P对地址K进行写入不命中，请求宿主节点提供数据，并使P成为所访问数据块的独占者</li>
<li>Invalidate(K): 请求向所拥有响应数据块副本（包含地址K）的远程cache发Invalidate消息，作废这些副本。</li>
</ul>
</li>
<li>宿主节点（目录）发送给远程节点的消息<ul>
<li>Invalidate(K): 作废远程cache中包含地址K的数据块</li>
<li>Fetch(K): 从远程cache中取出包含地址K的数据块，并送到宿主节点。把远程cache中那个块的状态改为“共享”</li>
<li>Fetch&amp;Inv(K): 从远程cache中取出包含地址K的数据块，并送到宿主节点。然后作废远程cache中的那个块。</li>
</ul>
</li>
<li>宿主节点发送给本地节点的消息<ul>
<li>DReply(D): D表示数据内容。把从宿主存储器获得的数据返回给本地cache</li>
</ul>
</li>
<li>远程节点发送给宿主节点的消息<ul>
<li>WtBack(K, D): 把远程cache中包含地址K的数据块写回到宿主节点中，该消息是远程节点对宿主节点发来的“取数据”或“取&#x2F;作废”消息的响应。</li>
</ul>
</li>
<li>本地节点发送给被替换块的宿主节点的消息<ul>
<li>MdSharer(P, K): 用于当本地cache中需要替换一个包含地址K的块、且该块未被修改过。这个消息发给该块宿主节点，请求它将P从共享集中删除。如果删除后共享集位空，则宿主节点还要将该块状态改为“未缓存”(U)</li>
<li>WtBack2(P, K, D): 用于当本地cache中需要替换一个包含地址K的块、且该块已经被修改过。这个消息发给该块宿主节点，完成两步：1. 写回该块；2. 进行与MdSharer相同操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="目录协议实例"><a href="#目录协议实例" class="headerlink" title="目录协议实例"></a>目录协议实例</h3><ul>
<li>在基于目录的协议中，目录承担了一致性协议操作主要功能<ul>
<li>本地节点把请求发给宿主节点中的目录，再由目录控制器有选择的向远程节点发出相应小欧希</li>
<li>发出的消息会产生两种不同类型动作<ul>
<li>更新目录状态</li>
<li>使远程节点完成相应操作</li>
</ul>
</li>
</ul>
</li>
<li>目录的状态转换及相应的操作<ul>
<li>目录中存储器块的状态有3种<ul>
<li>未缓存</li>
<li>共享</li>
<li>独占</li>
</ul>
</li>
<li>位向量记录拥有其副本的处理器集合。该集合称为共享集合</li>
<li>对于从本地节点发来的请求，目录所进行的操作包括<ul>
<li>向远程节点发送消息以完成相应的操作。这些远程节点由共享集合指出</li>
<li>修改目录中该块的状态</li>
<li>更新共享集合</li>
</ul>
</li>
<li>目录可能收到3中不同的请求<ul>
<li>读不命中</li>
<li>写不命中</li>
<li>数据写回</li>
</ul>
</li>
<li>当一个块处于未缓存状态时，对该块发出的请求及处理操作为<ul>
<li>RdMiss(读不命中): 将所要访问的存储器数据送往请求方处理机，且该处理机成为该块的唯一共享节点，本块的状态编程共享</li>
<li>WtMiss(写不命中): 将所要访问的存储器数据送往请求方处理机，该块的状态变成独占，表示该块仅存在唯一的副本。其共享集合仅包含该处理机，指出该处理机是其拥有者。</li>
</ul>
</li>
<li>当一个块处于共享状态时，其在处理器中的数据是当前最新的，对该块发出的请求及其处理操作为<ul>
<li>RdMiss: 将存储器数据送往请求方处理机，并将其加入共享集合</li>
<li>WtMiss: 将数据送往请求方处理机，对共享集合中所有的处理机发送作废消息，且将共享集改为仅含有该处理机，该块的状态变为独占</li>
</ul>
</li>
<li>当一个块处于独占状态时，该块的最新值保存在共享集合所指出的唯一处理机（拥有者）中<ul>
<li>RdMiss: 将“取数据”的消息发送往拥有者处理机，将它所返回给宿主节点的数据写入存储器，并进而把该数据送回请求方处理机，将请求方处理机加入共享集合。此时共享集合中仍保留拥有者处理机（因为它仍然拥有一个可读副本）。该块状态变为共享。</li>
<li>WtMiss: 该块将拥有一个新的拥有者。给旧的拥有者处理机发送消息，要求它将数据块送回宿主节点写入存储器，然后再从该节点送给请求方处理机。同时还要求旧拥有者处理机中把该块作废。把请求处理机加入共享者集合，使之成为新的拥有者。该块的状态仍然是独占。</li>
<li>WtBack: 当一个块的拥有者处理机要从其cache中把该块替换出去时，必须将该块写回其宿主节点的存储器中，从而使存储器中相应的块中存放的数据是最新的（宿主节点实际成为拥有者）。该块的状态变成未缓冲，其共享集合为空。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="目录的三种结构"><a href="#目录的三种结构" class="headerlink" title="目录的三种结构"></a>目录的三种结构</h3><ul>
<li>不同目录协议的主要区别主要有两个<ul>
<li>所这是的存储器块的状态及其个数不同</li>
<li>目录的结构</li>
</ul>
</li>
<li>目录协议分为3类<ul>
<li>全映像目录</li>
<li>有限映像目录</li>
<li>链式目录</li>
</ul>
</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ul>
<li>互斥过程：典型的互斥是临界资源的串行使用<ul>
<li>特点：每个进程都需要经历测锁-&gt;上锁-&gt;开锁的过程，共有n次竞争上锁、n次开锁。主需1个锁变量</li>
</ul>
</li>
<li>同步过程：典型的同步操作是栅栏：栅栏强制所有先到达该栅栏的进程进行等待，直到最后一个进程到达，由它释放全部进程，继续执行<ul>
<li>特点：只需1次上锁、1次开锁，n-1个进程需要测锁等待。需要两个锁变量。</li>
</ul>
</li>
<li>锁的类型及其操作<ul>
<li>布尔锁<ul>
<li>状态：开放、锁闭</li>
<li>操作：读锁、加锁、开锁</li>
<li>用途：互斥，保证临界资源操作的唯一性</li>
</ul>
</li>
<li>算数锁<ul>
<li>状态：负（拒绝&#x2F;欠缺数）、零（空闲）、正（累计数&#x2F;富余数）</li>
<li>操作：读锁、增值、减值、清零</li>
<li>用途：同步，记录等待中的进程数，或已通过的进程数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多处理机的锁存储模型"><a href="#多处理机的锁存储模型" class="headerlink" title="多处理机的锁存储模型"></a>多处理机的锁存储模型</h3><p>多处理机系统都用多个局部cache满足各处理机并行访存的需要，但对进程控制用的信号灯（或锁）来说，多副本就破坏了它们的唯一性，造成同一变量再不同处理机看来有不同值的后果。因此信号灯（锁）的管理需要遵循以下原则</p>
<ul>
<li>读信号灯再当地cache进行，只要复件有效</li>
<li>写信号灯必须直接作用于主存元件，采用“写穿”策略</li>
<li>写过程有排它性，硬件推迟其它处理机的写请求</li>
<li>写完元件要通知所有其它cache中的复件作废，即“一写多废”，让其它处理机随后发生“读失效”或“写失效”</li>
<li>信号灯管理系统的时间开销主要来源于“读失效”和“写失效”，或称“总线事务处理”次数</li>
<li>探讨不同的锁管理机制，目的是在程序正确前提下，减少时间开销</li>
</ul>
<h3 id="基本硬件原语"><a href="#基本硬件原语" class="headerlink" title="基本硬件原语"></a>基本硬件原语</h3><ul>
<li><p>在多处理机中实现同步，所需要的主要功能是：</p>
<ul>
<li>一组能以原子操作的方式读出并修改存储单元的硬件原语。它们都能以原子操作的方式读&#x2F;修改存储单元，并指出所进行的操作是否以原子的方式进行。</li>
<li>通常情况下，用户不直接使用基本的硬件原语，原语主要供系统程序员用来编制同步库函数。，</li>
</ul>
</li>
<li><p>典型操作：原子交换EXCH(automic exchange)</p>
<ul>
<li>功能：将一个存储单元的值和一个寄存器值进行交换。建立一个锁，锁值：<ul>
<li>0：表示开的（可用）</li>
<li>1：表示已上锁（不可用）</li>
</ul>
</li>
<li>处理器上锁时，将对应于该锁的存储单元的值于存放在某寄存器中的的1进行交换。<ul>
<li>如果返回值为1，别的处理器已经上了锁</li>
<li>如果返回值为0，存储单元的值此时已经置换为了1，防止了别的进程竞争该锁</li>
</ul>
</li>
<li>实现同步的关键：交换操作的原子性</li>
</ul>
</li>
<li><p>测试并置定(test_and_set)</p>
<ul>
<li>先测试一个存储单元的值，如果符合条件则修改其值</li>
</ul>
</li>
<li><p>读取并加1(fetch_and_increment)</p>
<ul>
<li>返回存储单元的值并自动增加该值</li>
</ul>
</li>
<li><p>使用指令对</p>
<ul>
<li>LL(load linked 或 load locked)：读取“锁”单元原值到指定寄存器。注意该指令通常只访问cache</li>
<li>SC(store conditional)：一条特殊写指令，它首先再读“锁”单元，如果与LL所读值相同，则将指定寄存器中的新值送给“锁”单元，并返回只1表示成功，如果内容不同，直接返回0表示失败。</li>
<li>指令顺序执行：<ul>
<li>如果由LL指明的存储单元的内容在SC对其进行写之前已被其它指令改写过，则第二条指令SC执行失败</li>
<li>如果在两条指令件进行切换也会导致SC执行失败</li>
</ul>
</li>
<li>SC将返回一个值来指出该指令操作是否成功<ul>
<li>“1”：成功</li>
<li>“0”：不成功</li>
</ul>
</li>
<li>LL返回该存储单元初始值</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># implement fetch_and_increment</span><br><span class="line">try:LL R2, 0(R1) # 把0(R1)中的值放入R2中</span><br><span class="line">    ADD R2, R2, 1  </span><br><span class="line">    SC R2, 0(R1) # 再次读取0(R1)，如果和LL读取时候的值相同，则把R2中的值放入0(R1)，R2置1；如果0(R1)的值变化，不动0(R1)的内容，R2置0。</span><br><span class="line">    BEQZ R2, try</span><br></pre></td></tr></table></figure>

<h3 id="用一致性实现锁"><a href="#用一致性实现锁" class="headerlink" title="用一致性实现锁"></a>用一致性实现锁</h3><ul>
<li>采用多处理机的一致性机制来实现自旋锁</li>
<li>自旋锁：处理器环绕一个锁不停地请求获得该锁。适合：锁被占用的时间很少，再获得锁后加锁过程延迟很小</li>
<li>无cache一致性机制：在存储器中保存锁变量，处理器可以不断地通过一个原子操作请求使用权。<ul>
<li>e.g. 利用原子交换操作，并通过测试返回值二直到锁的使用情况。释放锁的时候，处理器只需简单地将锁置为0</li>
</ul>
</li>
<li>机器支持cache一致性<ul>
<li>将锁调入cache，并通过一致性机制使锁值保持一致</li>
<li>优点：<ul>
<li>可使“环绕”的进程只对本地cache中的锁（副本）进行操作，而不用在每次请求占用锁时都进行一次全局的存储器访问</li>
<li>可利用访问锁时所具有的局限性，即处理机最近使用过的锁不久又会使用（减少为获得锁而花费的时间）</li>
</ul>
</li>
<li>改进自旋锁（获得第一条优点，避免写操作）：只对本地cache中锁的副本进行读取和检测，直到发现该锁已经被释放。然后，该程序立即进行交换操作，去跟在其它处理器上的进程征用该锁变量。</li>
</ul>
</li>
</ul>
<h3 id="同步性能问题"><a href="#同步性能问题" class="headerlink" title="同步性能问题"></a>同步性能问题</h3><p>简单自旋锁不能很好地适应可扩缩性。大规模多处理机中，若所有的处理器都同时争用同一个锁，则会导致大量的争用和通信开销。</p>
<ul>
<li>自旋锁的不足<ul>
<li>由于自旋锁的无序竞争，可能造成等待时间演唱，并且存在“不公平”的问题<ul>
<li>随着处理器个数的不断增加，自旋锁竞争性操作增加了系统负担，从而导致更长的等待时间</li>
<li>一个处理器释放自旋锁时要通知等待中的所有处理器，将cache副本作废，那么集合距离上临近它的处理器可能会较先的更新cache，因而增大了获得自旋锁的纪律</li>
</ul>
</li>
<li>由于每个申请自旋锁的处理器均在全局变量slock上忙等待，系统总线将因为处理器件的cache同步而导致繁重的流量（即因读失效或写失效引起的cache调入、调出），从而降低了系统整体的性能。</li>
</ul>
</li>
</ul>
<h1 id="重要公式整理"><a href="#重要公式整理" class="headerlink" title="重要公式整理"></a>重要公式整理</h1><h2 id="第一章-计算机体系结构的基本概念"><a href="#第一章-计算机体系结构的基本概念" class="headerlink" title="第一章 计算机体系结构的基本概念"></a>第一章 计算机体系结构的基本概念</h2><h3 id="amdahl公式"><a href="#amdahl公式" class="headerlink" title="amdahl公式"></a>amdahl公式</h3><p>在一个系统中，Fe表示可改进部分占用的比例，Se表示可改进部分可提升的比例，则系统加速比<br>$$ S_n &#x3D; \frac{1}{(1 - Fe) + \frac{Fe}{Se}}$$<br>当有多个比例的时候，可以使用公式$S_n &#x3D; \frac{1}{(1-\sum _i f_i) + \sum _i \frac{f_i}{S_i}}$，但是更推荐画出比例图以后手动计算一下。</p>
<h3 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h3><p>$$ CPU时间 &#x3D; \frac{总时钟周期数}{时钟频率} $$<br>指令时钟数CPI(Cycles Per Instruction)<br>$$ CPI &#x3D; 总时钟周期数 \div InstructionCount $$<br>因此，CPU时间也可以改写为$CPU时间&#x3D;CPI \times IC \div 时钟频率$</p>
<h2 id="第三章-流水线"><a href="#第三章-流水线" class="headerlink" title="第三章 流水线"></a>第三章 流水线</h2><h3 id="流水线性能指标"><a href="#流水线性能指标" class="headerlink" title="流水线性能指标"></a>流水线性能指标</h3><h4 id="吞吐率-1"><a href="#吞吐率-1" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>对于一个有k段的流水线，完成n个连续任务所需要的时间<br>$$ T_k &#x3D; (k + n - 1) \Delta t $$<br>流水线的实际吞吐率<br>$$ TP &#x3D; \frac{n}{(k + n - 1) \Delta t} $$<br>最大吞吐率<br>$$ TP_{max} &#x3D; lim _{n-&gt;\inf} \frac{n}{(k+n-1)\Delta t} &#x3D; \frac{1}{\Delta t} $$<br>各段时间不等的流水线的实际吞吐率为<br>$$TP &#x3D; \frac{n}{\sum <em>{i&#x3D;1}^k \Delta t_i + (n-1)max(\Delta t_1, \Delta t_2, …, \Delta t_k)}$$<br>流水线的最大吞吐率$TP</em>{max} &#x3D; \frac{1}{max(\Delta t_1, …, \Delta t_k)}$</p>
<h4 id="流水线的加速比-1"><a href="#流水线的加速比-1" class="headerlink" title="流水线的加速比"></a>流水线的加速比</h4><p>流水线的加速比是不使用流水线时所用的时间除以使用流水线后所用的时间</p>
<p>每段时间相等的流水线，加速比为$S&#x3D;\frac{nk}{k+n-1}$</p>
<p>每段时间不相等的流水线，加速比为$S&#x3D;\frac{n \sum _{i&#x3D;1}^k \Delta t_i}{\sum _{i&#x3D;1}^k \Delta t_i + (n-1)max(\Delta t_1, …, \Delta t_k)}$</p>
<h4 id="流水线的效率-1"><a href="#流水线的效率-1" class="headerlink" title="流水线的效率"></a>流水线的效率</h4><p>流水线的效率是设备实际使用时间与整个运行时间的比值。从时空图的角度来看就是方框面积总和除以整个图的构成的矩形面积。</p>
<p>每段时间相同的流水线，效率也相同，$e_1&#x3D;e_2&#x3D;…&#x3D;e_k&#x3D;\frac{n \Delta t}{T_k} &#x3D; \frac{n}{k + n - 1}$</p>
<p>整条流水线的效率$E &#x3D; \frac{n}{k + n - 1}$，容易看出，流水线的效率与吞吐率成正比，$E&#x3D;TP \times \Delta t$</p>
<h2 id="第七章-存储器"><a href="#第七章-存储器" class="headerlink" title="第七章 存储器"></a>第七章 存储器</h2><h3 id="缓存平均访问时间"><a href="#缓存平均访问时间" class="headerlink" title="缓存平均访问时间"></a>缓存平均访问时间</h3><p>基础公式<br>$$ 平均访存时间&#x3D; 命中时间 + 不命中率 \times 不命中开销 $$<br>采用写分配时候，平均访问时间$$ T_A &#x3D; HT_1 + (1-H) * (T_1 + T_2 + T_B) $$<br>其中，H为命中率，$T_1$为访问一级缓存的时间，$T_2$为访问二级缓存的时间，$T_B$为把数据从二级缓存调入一级缓存的时间。</p>
<p>当有两级cache的时候<br>$$ 平均访存时间 &#x3D; 命中时间_{L1} + 不命中率_{L1} \times (命中时间_{L2} + 不命中率_{L2} \times 不命中开销_{L2}) $$</p>
<h3 id="程序执行时间"><a href="#程序执行时间" class="headerlink" title="程序执行时间"></a>程序执行时间</h3><p>考虑访存的时候，<br>$$ CPU时间&#x3D;(CPU执行周期数 + 访存次数 \times 不命中率 \times 不命中开销) * 时钟周期时间 $$<br>$$ CPU时间 &#x3D; IC \times (CPI_{execution} + 每条指令的平均访存次数 \times 不命中率 \times 不命中开销) \times 时钟周期时间 $$</p>
<h3 id="降低cache不命中率-1"><a href="#降低cache不命中率-1" class="headerlink" title="降低cache不命中率"></a>降低cache不命中率</h3><ul>
<li>增加cache块大小</li>
<li>增加cache容量</li>
<li>提高相联度</li>
<li>伪相联cache</li>
<li>硬件预取</li>
<li>编译器控制的预取</li>
<li>编译器优化</li>
<li>“牺牲”cache</li>
</ul>
<h3 id="减少cache不命中开销"><a href="#减少cache不命中开销" class="headerlink" title="减少cache不命中开销"></a>减少cache不命中开销</h3><ul>
<li>多级cache</li>
<li>让读不命中优先于写</li>
<li>写缓冲合并</li>
<li>请求字处理技术</li>
<li>非阻塞cache技术</li>
</ul>
<h2 id="第八章-输入输出系统"><a href="#第八章-输入输出系统" class="headerlink" title="第八章 输入输出系统"></a>第八章 输入输出系统</h2><h3 id="可靠性模型-1"><a href="#可靠性模型-1" class="headerlink" title="可靠性模型"></a>可靠性模型</h3><p>对于一个串联系统，系统的可靠性$R_s$<br>$$ R_s &#x3D; \prod _{i&#x3D;1}^n R_i $$<br>对于并联系统，<br>$$ R_s &#x3D; 1 - \prod _{i&#x3D;1}^n (1- R_i) $$<br>串并联系统，其中n代表串联倍数，m代表并联倍数<br>$$ R(t) &#x3D; 1-(1-R_i ^n (t))^m $$<br>并串联系统<br>$$ R(t) &#x3D; (1-(1-R_i(t))^m)^n $$</p>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础知识</title>
    <url>/2024/04/02/Linux-Basic/</url>
    <content><![CDATA[<h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="1-系统目录结构"><a href="#1-系统目录结构" class="headerlink" title="1. 系统目录结构"></a>1. 系统目录结构</h2><ul>
<li><strong>&#x2F;bin</strong>: ‘bin’是Binaries（二进制文件）的缩写，这个目录存放着最经常使用的命令。比如说很多个Shell的程序都会放在&#x2F;bin文件夹里面。</li>
<li><strong>&#x2F;boot</strong>: 这里存放的是启动Linux时候使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>&#x2F;dev</strong>: dev是Device的缩写，该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同。</li>
<li><strong>&#x2F;ect</strong>: etc是Etcetera的缩写，这个目录是用来存放所有的系统管理所需要的配置文件和子目录。</li>
<li><strong>&#x2F;home</strong>: 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><strong>&#x2F;lib</strong>: lib是Library的缩写，这个目录里面存放这系统最基本的动态连接共享库，其作用类似于windows里的dll文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li><strong>&#x2F;lost+found</strong>: 这个目录一般情况下是空的，但是当系统非法关机，这里就存放了一些文件。</li>
<li><strong>&#x2F;media</strong>: Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下。</li>
<li><strong>&#x2F;mnt</strong>: 系统提供该目录是为了让用户临时挂载别的文件系统的，例如可以把光驱挂载在这里，就可以查看光驱内的内容了。</li>
<li><strong>&#x2F;opt</strong>: opt是optional的缩写，这是给主机额外安装软件所拜访的目录。例如安装ORACLE的数据库就可以放到这里，默认是空的。</li>
<li><strong>&#x2F;proc</strong>: proc是Processes的缩写，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li><strong>&#x2F;root</strong>: 该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>&#x2F;sbin</strong>: 超级用户的二进制文件，存放的是系统管理员使用的系统管理程序。</li>
<li><strong>&#x2F;selinux</strong>: 这个目录是Redhat&#x2F;centos特有的目录，SeLinux是一个安全机制，类似于Windows的防火墙。</li>
<li><strong>&#x2F;srv</strong>: 该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>&#x2F;sys</strong>: 该目录下安装了Linux2.6内核中新出现的一个文件系统sysfs。sysfs文件系统继承了三种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li>
<li><strong>&#x2F;tmp</strong>: tmp是temporary的缩写，用来存放一些临时文件。</li>
<li><strong>&#x2F;usr</strong>: usr是unix shared resources(共享资源)的缩写，是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows下的program files目录。</li>
<li><strong>&#x2F;&#x2F;usr&#x2F;bin</strong>: 系统用户使用的应用程序。</li>
<li><strong>&#x2F;usr&#x2F;sbin</strong>: 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>&#x2F;usr&#x2F;src</strong>: 内核源码默认的放置目录。</li>
<li><strong>&#x2F;var</strong>: var是variable的缩写，这个目录中存放这不断扩充的东西，习惯将哪些经常被修改的目录放在这个目录下，包括各种日志文件。</li>
<li><strong>&#x2F;run</strong>: 一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删除或者清除。如果你的系统上有<code>/var/run/</code>目录，应该让它指向<code>/run</code>。</li>
</ul>
<h2 id="2-一些常用命令"><a href="#2-一些常用命令" class="headerlink" title="2. 一些常用命令"></a>2. 一些常用命令</h2><h3 id="2-1-ls（列出目录）"><a href="#2-1-ls（列出目录）" class="headerlink" title="2.1 ls（列出目录）"></a>2.1 ls（列出目录）</h3><p>语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">ls [--color=&#123;never, auto, always&#125;] 目录名称</span><br><span class="line">ls [--full-time] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>: 全部的文件，联通隐藏文件一起列出来</li>
<li><code>-d</code>: 仅列出目录本身，而不是列出目录内的文件数据</li>
<li><code>-l</code>: 长数据串列出，包含文件的属性与权限等等数据</li>
</ul>
<h3 id="2-2-cd（切换目录）"><a href="#2-2-cd（切换目录）" class="headerlink" title="2.2 cd（切换目录）"></a>2.2 cd（切换目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [相对路径或者绝对路径]</span><br></pre></td></tr></table></figure>
<h3 id="2-3-pwd（显示目前所在的目录）"><a href="#2-3-pwd（显示目前所在的目录）" class="headerlink" title="2.3 pwd（显示目前所在的目录）"></a>2.3 pwd（显示目前所在的目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd [-P]</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-P</code>: 显示出确实的路径，而非使用连接(link)的路径。</li>
</ul>
<h3 id="2-4-mkdir（创建新目录）"><a href="#2-4-mkdir（创建新目录）" class="headerlink" title="2.4 mkdir（创建新目录）"></a>2.4 mkdir（创建新目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-m</code>: 配置文件的权限，直接配置，不考虑默认权限(unmask)</li>
<li><code>-p</code>: 递归的创建目录。</li>
</ul>
<h3 id="2-5-rmdir（删除空的目录）"><a href="#2-5-rmdir（删除空的目录）" class="headerlink" title="2.5 rmdir（删除空的目录）"></a>2.5 rmdir（删除空的目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-p</code>: 从该目录起，依次删除多级空目录，和上面的mkdir类似，可以直接一次性删除多级别&#x3D;目录。</li>
</ul>
<h3 id="2-6-cp（复制文件或目录）"><a href="#2-6-cp（复制文件或目录）" class="headerlink" title="2.6 cp（复制文件或目录）"></a>2.6 cp（复制文件或目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp [-dfilprsu] &lt;source&gt;（来源档） &lt;destination&gt;（目标档）</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果把多个文件放到directory位置</span></span><br><span class="line">cp [options] &lt;source1&gt; &lt;source2&gt; .... &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-d</code>: 若来源档为连接文件的属性(link file)，则复制连接档属性而非文件本身。</li>
<li><code>-f</code>： 为强制的意思，若目标文件已经存在且无法开启，则移除后再尝试一次。</li>
<li><code>-i</code>: 若目标档已经存在时，再覆盖时会先询问动作的进行。</li>
<li><code>-l</code>: 进行硬式连接(hard link)的连接档创建，而非复制文件本身。</li>
<li><code>-p</code>: 连同文件的属性一起复制过去，而非使用默认属性（备份的时候使用）</li>
<li><code>-r</code>: 递归持续复制。</li>
<li><code>-s</code>: 复制成为符号连结档(symbolic link),亦及捷径文件。</li>
<li><code>-u</code>: 若destination比source旧才覆盖destination。</li>
</ul>
<h3 id="2-7-rm（移除文件或目录）"><a href="#2-7-rm（移除文件或目录）" class="headerlink" title="2.7 rm（移除文件或目录）"></a>2.7 rm（移除文件或目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [fir] 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-f</code>: 忽略不存在的文件，不会出现井盖信息。</li>
<li><code>-i</code>: 互动模式，在删除前会询问使用者。</li>
<li><code>-r</code>: 递归删除</li>
</ul>
<h3 id="2-8-mv（移动文件与目录，或修改名称）"><a href="#2-8-mv（移动文件与目录，或修改名称）" class="headerlink" title="2.8 mv（移动文件与目录，或修改名称）"></a>2.8 mv（移动文件与目录，或修改名称）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [-fiu] &lt;source&gt; &lt;destination&gt;</span><br><span class="line">mv [options] &lt;source1&gt; &lt;source2&gt; ... &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><code>-f</code>: 如果目标文件已经存在，不会询问而直接覆盖。</li>
<li><code>-i</code>: 如果目标文件已经存在，会询问是否覆盖。</li>
</ul>
<h2 id="samba配置"><a href="#samba配置" class="headerlink" title="samba配置"></a>samba配置</h2><p>samba是为了用来创建共享文件夹的。可以与局域网下的其它Windows或Linux电脑共享文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure>
<p>编辑<code>smb.conf</code>文件，配置自己的共享文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[samba_share]  # the driver name in which you input in Windows explorer</span><br><span class="line">   comment = Samba Share</span><br><span class="line">   path = /samba_share  # path to your samba shared directory</span><br><span class="line">   browsable = yes</span><br><span class="line">   guest ok = yes</span><br><span class="line">   read only = no</span><br><span class="line">   create mask = 0755</span><br></pre></td></tr></table></figure>
<p>修改文件后需要重启smbd服务<code>sudo systemctl restart smbd</code></p>
<h4 id="添加samba用户"><a href="#添加samba用户" class="headerlink" title="添加samba用户"></a>添加samba用户</h4><p>在局域网内其它电脑连接samba共享文件夹的时候，需要认证用户名和密码。为了方便，可以先用<code>adduser</code>创建一个账户(也可以使用已有账户)，然后把该用户添加到samba用户组中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a sambauser</span><br></pre></td></tr></table></figure>
<p>把<code>sambauser</code>添加到samba用户组中，当认证用户名和密码的时候，就可以使用sambauser的用户名和密码了。</p>
<h2 id="在ubuntu上安装更新版本的cmake"><a href="#在ubuntu上安装更新版本的cmake" class="headerlink" title="在ubuntu上安装更新版本的cmake"></a>在ubuntu上安装更新版本的cmake</h2><h3 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h3><ul>
<li>ubuntu上通过<code>apt</code>安装的cmake版本都非常的老，在构建一些项目的时候可能会无法成功。</li>
<li><code>snap</code>有时候会突然死掉，而且无法通过<code>systemctl</code>重启，这样的情况下甚至没有办法卸载snap安装的cmake</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在Linux上，遇事不决就应该尝试源码构建，这永远是最方便的方法，而且在性能相对较可的电脑上也不会需要很多时间。</p>
<h4 id="获取cmake源码"><a href="#获取cmake源码" class="headerlink" title="获取cmake源码"></a>获取cmake源码</h4><p>先确定自己想要的cmake的版本，目前cmake大版本已经出到了4，但是我暂时用不到4的任何特性，所以我选择安装cmake3.31.3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version=3.11</span><br><span class="line">build=3</span><br><span class="line">mkdir cmake-repo-temp &amp; cd cmake-repo-temp</span><br><span class="line">wget https://cmake.org/files/v$version/cmake-$version.$build.tar.gz</span><br><span class="line">tar -xzvf cmake-$version.$build.tar.gz</span><br><span class="line">cd cmake-$version.$build/</span><br></pre></td></tr></table></figure>

<h4 id="编译并安装cmake"><a href="#编译并安装cmake" class="headerlink" title="编译并安装cmake"></a>编译并安装cmake</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap</span><br><span class="line">make -j$(nproc)</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h4 id="测试cmake"><a href="#测试cmake" class="headerlink" title="测试cmake"></a>测试cmake</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>
<p>如果看到输出版本为3.31.3，则说明安装成功！</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="docker-pull走自己的代理"><a href="#docker-pull走自己的代理" class="headerlink" title="docker pull走自己的代理"></a>docker pull走自己的代理</h3><h4 id="确保-创建目录"><a href="#确保-创建目录" class="headerlink" title="确保&#x2F;创建目录"></a>确保&#x2F;创建目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure>
<h4 id="创建代理配置文件"><a href="#创建代理配置文件" class="headerlink" title="创建代理配置文件"></a>创建代理配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/docker.service.d/proxy.conf</span><br></pre></td></tr></table></figure>
<p>将以下内容添加到<code>proxy.conf</code>文件中</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Environment</span>=<span class="string">&quot;HTTP_PROXY=http://localhost:7890&quot;</span></span><br><span class="line"><span class="attr">Environment</span>=<span class="string">&quot;HTTPS_PROXY=http://localhost:7890&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="重启Docker服务"><a href="#重启Docker服务" class="headerlink" title="重启Docker服务"></a>重启Docker服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reexec</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="检测是否成功"><a href="#检测是否成功" class="headerlink" title="检测是否成功"></a>检测是否成功</h4><p>使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info | grep HTTP</span><br></pre></td></tr></table></figure>
<p>如果能看到设置的两条代理，说明成功。</p>
]]></content>
      <categories>
        <category>basic_cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>samba</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST-CS-编译原理整理</title>
    <url>/2025/06/24/HUST-CS-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="什么是编译程序"><a href="#什么是编译程序" class="headerlink" title="什么是编译程序"></a>什么是编译程序</h2><p>高级语言（源程序）-&gt; compiler -&gt; 目标程序（汇编语言）</p>
<p>java -&gt; translator -&gt; Intermediate Representation -&gt; jvm</p>
<ul>
<li>编译系统的作用：<ul>
<li>翻译：支持高层的抽象，支持底层的硬件体系结构</li>
<li>优化：更快的执行速度，更少的空间</li>
<li>分析：程序理解</li>
</ul>
</li>
</ul>
<h2 id="编译过程和编译程序结构"><a href="#编译过程和编译程序结构" class="headerlink" title="编译过程和编译程序结构"></a>编译过程和编译程序结构</h2><h4 id="c-c"><a href="#c-c" class="headerlink" title="c&#x2F;c++"></a>c&#x2F;c++</h4><p>源程序.c&#x2F;.cpp -&gt; preprocessor -&gt; .i -&gt; compiler(cc) -&gt; .s -&gt; assembler -&gt; .o -&gt; linker(ld) (+库代码.a) -&gt; 机器代码</p>
<h3 id="编译阶段的组合"><a href="#编译阶段的组合" class="headerlink" title="编译阶段的组合"></a>编译阶段的组合</h3><ul>
<li>前端<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
</ul>
</li>
<li>中端<ul>
<li>中间代码生成</li>
<li>代码优化</li>
</ul>
</li>
<li>后端<ul>
<li>代码优化</li>
<li>目标代码生成</li>
</ul>
</li>
</ul>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul>
<li>从左至右扫描字符流的源程序，分解构成源程序的字符串，识别出一个个单词token(种别码，值)</li>
<li>词法分析的结果是二元组:(token种别码，token值)</li>
<li>词法分析的过程，其实就是对一个字符串进行模式匹配的过程</li>
<li>词法规则文件.l -&gt; flex编译器 -&gt; 词法分析源程序lex.yy.c -&gt; gcc -&gt; 词法分析器</li>
</ul>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><ul>
<li>parsing，语法检查（规约或推导）</li>
<li>识别短语，并构造语法分析树，还可以进一步简化为抽象语法树AST</li>
</ul>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><ul>
<li>收集符号信息（种属&#x2F;类型&#x2F;长度&#x2F;位置&#x2F;值&#x2F;作用域）</li>
<li>语义检查（类型匹配，类型转换，引用消解）</li>
</ul>
<h3 id="中间-IR-代码生成"><a href="#中间-IR-代码生成" class="headerlink" title="中间(IR)代码生成"></a>中间(IR)代码生成</h3><h3 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h3><ul>
<li>选择合适的指令，生成性能最高的代码</li>
<li>优化寄存器的分配，让频繁访问的变量（如循环变量）放到寄存器里，因为访问寄存器比访问内存快100倍左右</li>
<li>在不改变运行结果的情况下，对指令做重新排序，从而充分运用CPU内部的多个功能部件的并行计算能力</li>
</ul>
<h3 id="符号表管理与错误处理"><a href="#符号表管理与错误处理" class="headerlink" title="符号表管理与错误处理"></a>符号表管理与错误处理</h3><ul>
<li>符号表管理<ul>
<li>记录源程序中使用的各种符号名称</li>
<li>收集符号的属性信息，类型，作用域，分配存储信息</li>
<li>登录：扫描到说明语句就将标识符等级在符号表中</li>
<li>查找：在执行语句查找标识符的属性，判断语义是否正确</li>
</ul>
</li>
<li>错误处理<ul>
<li>报告出错信息，排错</li>
<li>恢复编译工作</li>
</ul>
</li>
</ul>
<h2 id="解释程序和一些软件工具"><a href="#解释程序和一些软件工具" class="headerlink" title="解释程序和一些软件工具"></a>解释程序和一些软件工具</h2><ul>
<li>编译：先翻译后执行，保存目标程序，一次翻译，多次执行</li>
<li>解释：边翻译边执行，翻译一句就执行一句，翻译完毕也执行完毕。只保存源程序无需保证完成的目标程序。执行一次需要翻译一次。</li>
</ul>
<h2 id="PL-0编译系统"><a href="#PL-0编译系统" class="headerlink" title="PL&#x2F;0编译系统"></a>PL&#x2F;0编译系统</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>数据类型只有整数类型</li>
<li>数据结构只支持简单变量和常熟</li>
<li>所支持的数字为最长9位的十进制数</li>
<li>标识符的有效长度位10</li>
<li>标识符引用前要先声明</li>
<li>过程无参数</li>
<li>过程可嵌套，最多嵌套3层</li>
<li>过程可递归调用</li>
<li>内层过程可以引用包围它的外层过程的标识符</li>
</ul>
<h3 id="EBNF表示"><a href="#EBNF表示" class="headerlink" title="EBNF表示"></a>EBNF表示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;程序&gt; ：：= &lt;分程序&gt;</span><br><span class="line">&lt;分程序&gt; ::= [&lt;常量说明部分&gt;] [&lt;变量说明部分&gt;] [&lt;过程说明部分&gt;] &lt;语句&gt;</span><br><span class="line">&lt;常量说明部分&gt; ::= CONST &lt;常量定义&gt; &#123;, &lt;常量定义&gt;&#125;;</span><br><span class="line">&lt;常量定义&gt; ::= &lt;标识符&gt; = &lt;无符号整数&gt;</span><br><span class="line">&lt;无符号整数&gt; ::= &lt;数字&gt;&#123;&lt;数字&gt;&#125;</span><br><span class="line">&lt;变量说明部分&gt; ::= VAR &lt;标识符&gt;&#123;,&lt;标识符&gt;&#125;</span><br><span class="line">&lt;标识符&gt; ::= &lt;字母&gt; &#123;&lt;字母&gt;|&lt;数字&gt;&#125;</span><br><span class="line">&lt;过程说明部分&gt; ::= &lt;过程首部&gt;&lt;分程序&gt;&#123;;&lt;过程说明部分&gt;&#125;;</span><br><span class="line">&lt;过程首部&gt; ::= PROCEDURE &lt;标识符&gt; ;</span><br><span class="line">&lt;语句&gt; ::= &lt;赋值语句&gt;|&lt;条件语句&gt;|&lt;当型循环语句&gt;|&lt;过程调用语句&gt;|&lt;读语句&gt;|&lt;写语句&gt;|&lt;复合语句&gt;|&lt;空&gt;</span><br><span class="line">&lt;赋值语句&gt; ::= &lt;标识符&gt; := &lt;表达式&gt;</span><br><span class="line">&lt;复合语句&gt; ::= BEGIN &lt;语句&gt; &#123;;&lt;语句&gt;&#125; END</span><br><span class="line">&lt;条件&gt; ::= &lt;表达式&gt;&lt;关系运算符&gt;&lt;表达式&gt; | ODD &lt;表达式&gt;</span><br><span class="line">&lt;表达式&gt; ::= [+|-] &lt;项&gt; &#123;&lt;加法运算符&gt;&lt;项&gt;&#125;</span><br><span class="line">&lt;项&gt; ::= &lt;因子&gt; &#123;&lt;乘法运算符&gt;&lt;因子&gt;&#125;</span><br><span class="line">&lt;因子&gt; ::= &lt;标识符&gt;|&lt;无符号整数&gt;|&#x27;(&#x27;&lt;表达式&gt;&#x27;)&#x27;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><table>
<thead>
<tr>
<th align="left">gcc选项</th>
<th align="left">功能</th>
<th align="left">目标文件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-E</td>
<td align="left">预处理，不编译</td>
<td align="left">.i</td>
</tr>
<tr>
<td align="left">-S</td>
<td align="left">编译成汇编程序，不汇编</td>
<td align="left">.s</td>
</tr>
<tr>
<td align="left">-c</td>
<td align="left">编译并汇编生成目标文件，不连接</td>
<td align="left">.o</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">指定生成目标文件的文件名</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-m32</td>
<td align="left">按32位进行编译</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-m64</td>
<td align="left">按64位进行编译</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">宏定义</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-nostdinc</td>
<td align="left">排除标准C语言头文件搜索路径</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-I</td>
<td align="left">指定头文件搜索路径</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-nostdlib</td>
<td align="left">链接时排除系统相关的启动文件和库</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-Wl</td>
<td align="left">将后面的参数传给链接器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-lc</td>
<td align="left">链接libc库文件</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="文法与语言"><a href="#文法与语言" class="headerlink" title="文法与语言"></a>文法与语言</h1><h2 id="文法的概念"><a href="#文法的概念" class="headerlink" title="文法的概念"></a>文法的概念</h2><ul>
<li>语言的基本形式是句子，句子是由单词序列构成的，单词是由语言基本符号（字母或单字）组成</li>
<li>还包含将这些成分组织起来的语言规则，如此法规则、语法规则等</li>
<li>文法是阐述语法的一个工具，语句是语法的实例</li>
<li>程序语言-形式语言</li>
<li>形式语言是符号串集合</li>
<li>字母表上的符号按一定的规则组成的所有符号串集合，其中每个符号串称为一个句子</li>
</ul>
<h2 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h2><ul>
<li>字母表: $\Sigma$是非空有穷集合，其元素称为符号</li>
<li>符号串: $\Sigma$中的符号组成的有穷序列<ul>
<li>空串: $\epsilon$</li>
</ul>
</li>
<li>规则：符号串的组成规则</li>
<li>符号串长度: $\alpha$中含有符号的个数，记作$|\alpha|$,其中$|\epsilon| &#x3D; 0$</li>
<li>符号串集合: 如果集合A的元素都是字母表$\Sigma$上的符号串，则称集合A为$\Sigma$上的符号串集合，简称串集</li>
<li>符号串的运算<ul>
<li>连接: $\alpha \cdot \beta &#x3D; \alpha \beta$</li>
<li>或: $\alpha | \beta$，即$\alpha$或者$\beta$</li>
<li>方幂: $\alpha ^n &#x3D; \alpha \alpha … \alpha$<ul>
<li>$\alpha^0 &#x3D; \epsilon$空符号串，就是什么符号也没有的符号串</li>
</ul>
</li>
<li>闭包: $\alpha ^1 &#x3D; \alpha; \alpha ^2 &#x3D; \alpha \alpha$</li>
<li>正闭包: $\alpha ^+ &#x3D; \alpha^1 | \alpha^2| … | \alpha^n | …$</li>
<li>星闭包: $\alpha ^* &#x3D; \alpha^0|\alpha^1 | \alpha^2| … | \alpha^n | …$</li>
</ul>
</li>
<li>符号串的集合运算<ul>
<li>乘积: $AB &#x3D; {xy | x \in A且y \in B}$</li>
<li>和: $A \cup B &#x3D; A + B &#x3D; {x|x \in A 或 x \in B}$</li>
<li>方幂: $A^n &#x3D; AA..A $</li>
<li>闭包<ul>
<li>正闭包: $A^+ &#x3D; A^1 \cup A^2 \cup … \cup A^n \cup …$</li>
<li>星闭包: $A^* &#x3D; A^0 \cup A^1 \cup … \cup A^n \cup …$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文法和语言的形式化定义"><a href="#文法和语言的形式化定义" class="headerlink" title="文法和语言的形式化定义"></a>文法和语言的形式化定义</h2><ul>
<li>定义：文法G定义位一个四元组$(V_N, V_T, P, S)$，记为$G&#x3D;(V_N, V_T, P, S)$<ul>
<li>$V_N$是非空有穷集合，称为非终结符集，其元素称为非终结符</li>
<li>$V_T$是有穷集合，称为终结符集，其元素称为终结符</li>
<li>P是非空有穷集合，称为规则集，其元素是字母表$V_N \cup V_T$上的规则，$V_N \cup V_T$称为文法的字母表V，且$V_N \cap V_T &#x3D; \varnothing$</li>
<li>$S \in V_N$，称为开始符</li>
</ul>
</li>
<li>直接推导<ul>
<li>如果P中包含$\alpha \rightarrow \beta$，那么任意的串$\gamma \alpha \delta$可以推导出$\gamma \beta \delta$，把这种推导称为直接推导或一步推导，记作$\gamma \alpha \delta &#x3D;&gt; \gamma \beta \delta$</li>
</ul>
</li>
<li>直接归约<ul>
<li>如果$\gamma \alpha \delta &#x3D;&gt; \gamma \beta \delta$，也可以说$\gamma \beta \delta$规约到$\gamma \alpha \delta$。这种规约称为直接规约或一步归约</li>
</ul>
</li>
<li>多步推导<ul>
<li>$\alpha &#x3D;^+ &gt; \beta$</li>
</ul>
</li>
<li>多步归约<ul>
<li>$\alpha &#x3D;^+ &gt; \beta$，$\beta$规约到$\alpha$</li>
</ul>
</li>
<li>0步以上推导与归约<ul>
<li>$\alpha &#x3D;^* &gt; \beta$</li>
</ul>
</li>
<li>句型与句子<ul>
<li>G[S]，有$S &#x3D; ^* &gt; \beta$，则称$\beta$是文法G[S]的句型</li>
<li>若$\beta \in V_T^*$，则称$\beta$是文法G的句子</li>
</ul>
</li>
<li>语言: 文法G的产生语言定义为文法G的句子集合，记为L(G),即$L(G) &#x3D; {\beta | S &#x3D;^*&gt;\beta, \beta \in V_T^*}$</li>
<li>文法的等价: 对于$G_1, G_2$，如果$L(G_1) &#x3D; L(G_2)$，则称文法$G_1, G_2$等价</li>
</ul>
<h2 id="文法的类型"><a href="#文法的类型" class="headerlink" title="文法的类型"></a>文法的类型</h2><ul>
<li>0型文法（短语文法，图灵机）<ul>
<li>如果一个文法的所有规则，左侧至少含有一个非终结符，则称此文法为0型文法，也称为短语文法</li>
<li>产生式形如$\alpha \rightarrow \beta$，其中$\alpha \in (V_T \cup V_N)^+$且至少含有一个非终结符，$\beta \in (V_T \cup V_N)^*$</li>
</ul>
</li>
<li>1型文法（上下文有关文法，线性界限自动机）<ul>
<li>产生式形如$\alpha \rightarrow \beta$，其中$|\alpha| &lt;&#x3D; |\beta|$，仅$S\rightarrow\epsilon$例外</li>
</ul>
</li>
<li>2型文法（上下文无关文法）<ul>
<li>$\forall A \rightarrow \beta \in P, A \in V_N$，则文法是2型文法，$\beta \in (V_T \cup V_N)^*$</li>
<li>任意产生式左部均为一非终结符</li>
</ul>
</li>
<li>3型文法（正规文法，有限自动机）<ul>
<li>文法的产生式只能是两种形式之一</li>
<li>$A \rightarrow \epsilon | a | aB \qquad A,B \in V_N, a \in V_T$右线性文法</li>
<li>$A \rightarrow \epsilon | a | Ba \qquad A, B \in V_N, a \in V_T$左线性文法</li>
</ul>
</li>
</ul>
<h2 id="上下文无关文法及其语法树"><a href="#上下文无关文法及其语法树" class="headerlink" title="上下文无关文法及其语法树"></a>上下文无关文法及其语法树</h2><ul>
<li>从一个句型到另一个句型的推导往往不唯一</li>
<li>最左推导: 任何一步 $\alpha &#x3D;&gt; \beta$都是对$\alpha$中最左非终结符进行替换</li>
<li>最右推导: 任何一步 $\alpha &#x3D;&gt; \beta$都是对$\alpha$中最右非终结符进行替换</li>
<li>最右推导，也叫规范推导，由规范推导所得的句型，叫做规范句型（右句型）。规范推导的逆过程，叫做规范归约</li>
</ul>
<h3 id="语法树（推导树）"><a href="#语法树（推导树）" class="headerlink" title="语法树（推导树）"></a>语法树（推导树）</h3><ul>
<li>文法G的任何一个句型，根据其推导都能构造一个语法树，或推导树。它是一个满足下列条件的多叉树<ul>
<li>文法的开始符S为数的根节点</li>
<li>对任意产生式$A \rightarrow \alpha, \alpha \in (V_N \cup V_Y)^*$, $\alpha$的各符号严格依生产时的次序依次为A的子节点；文法符号为其节点标记（节点名）</li>
</ul>
</li>
<li>语法的二义性<ul>
<li>如果文法G的某个句子存在至少两棵不同的语法树，则称文法G是二义性的</li>
<li>如果文法是无二义性的，一个句子的语法树反映了该句子的全部推导过程</li>
<li>如果文法是无二义性的，一个句子的最左（最右）推导是唯一的</li>
</ul>
</li>
<li>语言的二义性<ul>
<li>文法的二义性，并不等同于语言的二义性</li>
<li>因为二义性文法G，可能存在与之等价的无二义性的文法G’,即L(G)&#x3D;L(G’)</li>
<li>如果一个语言不存在无二义性的文法，则称该语言是先天二义性的</li>
<li>二义性问题是不可判定问题，不存在一个算法，能在有限步骤内，确切判定一个文法是否是二义的</li>
</ul>
</li>
</ul>
<h2 id="句型的分析"><a href="#句型的分析" class="headerlink" title="句型的分析"></a>句型的分析</h2><ul>
<li>假设文法G[S]是语言L的文法，即L(G) &#x3D; L,则“符号串$\alpha$是否符合语言L的语法问题”被等价的转化称为“推导或归约问题”，即<br>$$ S \Rightarrow^* \alpha \alpha \in V_T ^\ast $$</li>
<li>推导法 vs 归约法</li>
<li>自顶向下 vs 自底向上</li>
</ul>
<h3 id="自顶向下分析法"><a href="#自顶向下分析法" class="headerlink" title="自顶向下分析法"></a>自顶向下分析法</h3><ul>
<li>从文法开始符号出发，反复使用规则，寻找匹配符号串（推导）的句型，直到推导出句子或穷尽规则也不能推导出。进行每步推导时，存在两个选择问题<ul>
<li>选择句型中哪一个非终结符进行推导</li>
<li>选择非终结符的哪一个规则进行推导</li>
</ul>
</li>
<li>最左推导，琼剧规则<ul>
<li>推导过程中一旦出现符号串$\alpha$: $\alpha$是合法的句子</li>
<li>穷尽规则，不存在$\alpha$的推导过程: $\alpha$是不合法的句子</li>
</ul>
</li>
</ul>
<h3 id="自底向上的分析法"><a href="#自底向上的分析法" class="headerlink" title="自底向上的分析法"></a>自底向上的分析法</h3><ul>
<li>从输入符号串$\alpha$开始，逐步进行“归约”，直至归约出文法的开始符号S，则输入串$\alpha$是文法G定义的语言的句子，否则不是<ul>
<li>归约是推导的逆过程</li>
<li>每步归约时，粗野你在如何选择句型$\alpha$的子串$\beta$进行归约的问题</li>
</ul>
</li>
<li>方案：按句柄归约-规范归约（移进-归约）<ul>
<li>简单优先分析法SLR(1)</li>
<li>LR分析法</li>
</ul>
</li>
<li>短语，直接短语和句柄<ul>
<li>文法G[S]有$S \Rightarrow^* \alpha A \delta \Rightarrow^* \alpha \beta \delta$，且$A &#x3D;+&gt; \beta$<ul>
<li>$\beta$是句型$\alpha \beta \delta$相对于非终结符A的短语<ul>
<li>任一子树的叶子节点符号串皆为短语</li>
<li>特别的，$S \Rightarrow^* \alpha A \delta &#x3D;&gt; \alpha \beta \delta$，即$A &#x3D;&gt; \beta$</li>
</ul>
</li>
<li>$\beta$是句型$\alpha \beta \delta$相对于规则$A \rightarrow \beta$的直接短语（简单短语）<ul>
<li>若子树的根是子树所有叶节点的父亲，则叶节点符号串为简单短语；</li>
<li>右句型的最左直接短语，称为该句型的句柄</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="补充说明-多余规则和expislon规则"><a href="#补充说明-多余规则和expislon规则" class="headerlink" title="补充说明-多余规则和expislon规则"></a>补充说明-多余规则和expislon规则</h2><ul>
<li>文法不得含有有害规则、多余规则<ul>
<li>有害规则: A -&gt; A</li>
<li>不可达（用）规则: 不再任何产生式右部出现的非终结符及其规则</li>
<li>不可终止规则: 从某非终结符开始，不可能推导出任意终结符来</li>
</ul>
</li>
<li>对文法G中的符号X是有用的，是指X至少出现在一个句子的推导过程中，即X必须同时满足以下两个条件<ul>
<li>X必须在某个句型中出现，即存在$\alpha, \beta \in V*$，有$S \Rightarrow^* \alpha X \beta$（可达）</li>
<li>必须能够从X推导出终结符号串，即存在$w \in V_T^*$，使$\alpha X \beta \Rightarrow^* w$ (可终结)，否则X就是无用的</li>
<li>含有无用符号的产生式称为无用产生式</li>
</ul>
</li>
<li>文法化简：消除有害规则，无用五号与无用规则<ul>
<li>构造能推导出中介符号串的非终结符集合$V_{N1}$<ul>
<li>对P中每一个产生式$A \rightarrow \alpha$，若$\alpha \in V_T^*$，则$V_{N1} \cup &#x3D; A$</li>
<li>对P中每一个产生式$B \rightarrow \beta$，若$\beta \in (V_T + V_{N1})*$，则$V_{N1} \cup &#x3D; B$</li>
<li>重复步骤2，直至$V_{N1}$不再扩大为止</li>
</ul>
</li>
<li>删除不再$V_{N1}$中的所有非终结符的相关产生式</li>
</ul>
</li>
</ul>
<h1 id="词法分析-1"><a href="#词法分析-1" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="词法分析程序的设计"><a href="#词法分析程序的设计" class="headerlink" title="词法分析程序的设计"></a>词法分析程序的设计</h2><ul>
<li>词法分析任务<ul>
<li>从左至右扫描文本格式的源程序，从基于字符理解的源程序中分离出符合源语言词法的但此符号</li>
</ul>
</li>
<li>词法分析器又称为扫描器scanner</li>
<li>Scanner的功能<ul>
<li>输入: 源程序</li>
<li>输出: (单词种别，单词自身的值)</li>
<li>种别: 关键字、标识符、字面量（常量）、运算符、界符</li>
</ul>
</li>
<li>输出的单词符号的表示形式<ul>
<li>(单词种别，单词自身的值)</li>
</ul>
</li>
<li>单词种别通常用整数编码表示<ul>
<li>多用enum</li>
<li>若一个种别只有一个单词符号，则种别编码就代表该单词符号。关键字、运算符和界符都是一符一种</li>
<li>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值<ul>
<li>标识符单列一种；标识符自身的值表示成按及其字节划分的内部码</li>
<li>常数按类型分种；常数的值则表示成标准的二进制形式</li>
</ul>
</li>
</ul>
</li>
<li>为什么把词法分析作为一个独立的阶段<ul>
<li>结构简介、清晰和条理化，有利于集中考虑词法分析的一些枝节问题</li>
<li>编译程序的效率会改进</li>
<li>增强编译程序的可移植性</li>
</ul>
</li>
</ul>
<h2 id="单词的形式化描述工具"><a href="#单词的形式化描述工具" class="headerlink" title="单词的形式化描述工具"></a>单词的形式化描述工具</h2><ul>
<li>基于生成观点、计算观点和识别观点，分别行程了正规文法、正规式和有穷自动机3种用于描述词法的工具</li>
<li>正规文法：对文法$G&#x3D;(V_N, V_T, P, S)$，如果任意$A \rightarrow \beta \in P, A \in V_N$，且$\beta$只能是aB或a或$\epsilon$，则称G属于右线性3型文法</li>
<li>正规式(正则表达式), 及其表达的语言(正规集)<ul>
<li>$\epsilon, \varnothing$都是正规式，其正规集分别是${\epsilon}$和$\varnothing$</li>
<li>$\forall a \in \Sigma$，a是$\Sigma$上的正规式，其正规集为{a}</li>
<li>如果r和s都是$\Sigma$上的正规式，则<ul>
<li>(r)是正规式，它表示的正规集为L(r)</li>
<li>r|s是正规式，它表示的正规集为$L(r) \cup L(s)$</li>
<li>$r \cdot s$是正规式，它表示的正规集为$L(r) \cdot L(s)$</li>
<li>$r*$是正规式，它表示的正规集为$L(r*) &#x3D; L(r)*$</li>
</ul>
</li>
<li>有限次使用上述步骤而定义的表达式仍是正规表达式，它们表示的符号串的集合是正规集</li>
</ul>
</li>
<li>所有此法结构一般都可以用正规式描述</li>
<li>若两个正规式所表示的正规集相同，则称这两个正规式等价</li>
</ul>
<table>
<thead>
<tr>
<th align="left">正规式</th>
<th align="left">正规集</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">{a}</td>
</tr>
<tr>
<td align="left">a&#x2F;b</td>
<td align="left">{a, b}</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="left">{ab}</td>
</tr>
<tr>
<td align="left">(alb)*</td>
<td align="left">{a,b}*</td>
</tr>
<tr>
<td align="left">a*</td>
<td align="left">{$\epsilon, a, aa, …$}</td>
</tr>
<tr>
<td align="left">(a&#x2F;b)*a</td>
<td align="left">{a,b}*{a}</td>
</tr>
<tr>
<td align="left">(a&#x2F;b)(a&#x2F;b)</td>
<td align="left">{aa, ab, ba, bb}</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">定律</th>
<th align="left">公示</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">交换律</td>
<td align="left">r&#x2F;s &#x3D; s&#x2F;r</td>
<td align="left">l是可以交换的</td>
</tr>
<tr>
<td align="left">结合律</td>
<td align="left">r&#x2F;(s&#x2F;t) &#x3D; (r&#x2F;s)&#x2F;t</td>
<td align="left">l是可结合的</td>
</tr>
<tr>
<td align="left">结合律</td>
<td align="left">r(st)&#x3D;(rs)t</td>
<td align="left">连接是可结合的</td>
</tr>
<tr>
<td align="left">分配律</td>
<td align="left">r(s&#x2F;t)&#x3D;rs&#x2F;rt;(r&#x2F;t)r&#x3D;sr&#x2F;tr</td>
<td align="left">连接对l是可分配的</td>
</tr>
<tr>
<td align="left">恒等律</td>
<td align="left">$\epsilon r &#x3D; r \epsilon &#x3D; r$</td>
<td align="left">$\epsilon$是连接的恒等单位</td>
</tr>
<tr>
<td align="left">存在律</td>
<td align="left">r*&#x3D;(r&#x2F;$\epsilon$)*</td>
<td align="left">闭包种一定包含$\epsilon$</td>
</tr>
<tr>
<td align="left">幂等律</td>
<td align="left">r**&#x3D;r*</td>
<td align="left">闭包中一定包含$\epsilon$</td>
</tr>
<tr>
<td align="left">“或”的抽取律</td>
<td align="left">r&#x2F;r &#x3D; r</td>
<td align="left">l是可消重的</td>
</tr>
</tbody></table>
<ul>
<li>正规式和正规文法的等价<ul>
<li>如果正规式r和文法G，有L(r) &#x3D; L(G)，则称正规式r和文法G是等价的</li>
</ul>
</li>
<li>正规式r \rightarrow 文法G<ul>
<li>设$\Sigma$上正规式r，则等价文法$G&#x3D;(V_N, V_T, P, S)$，其中$V_T &#x3D; \Sigma$；从形如产生式$S\rightarrow r$开始，按照下表进行转换，直到全部符合正规文法之产生式为止。可得到$P, V_N$</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">正规式产生式</th>
<th align="left">文法产生式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">规则1</td>
<td align="left">A-&gt;xy</td>
<td align="left">A-&gt;xB, B-&gt;y</td>
</tr>
<tr>
<td align="left">规则2</td>
<td align="left">A-&gt;x*y</td>
<td align="left">A-&gt;xB,A-&gt;y,B-&gt;xB,B-&gt;y</td>
</tr>
<tr>
<td align="left">规则3</td>
<td align="left">A-&gt;x&#x2F;y</td>
<td align="left">A-&gt;x, A-&gt;y</td>
</tr>
</tbody></table>
<h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><ul>
<li>本质上和状态转换图相同，但有穷自动机只回答yes&#x2F;no</li>
<li>分为两类<ul>
<li>不确定的有穷自动机(NFA)<ul>
<li>输入符号包括$\epsilon$，一个符号可以标价在离开同一个状态的多条边上</li>
</ul>
</li>
<li>确定有穷自动机(DFA)<ul>
<li>输入符号不含$\epsilon$，每个状态以及每个符号，最多只有一条边</li>
</ul>
</li>
</ul>
</li>
<li>两种自动机都识别正则语言<ul>
<li>对于每个可以用于正则表达式描述的语言，均可用某个NFA或DFA来识别，反之亦然</li>
</ul>
</li>
</ul>
<h3 id="DFA形式化定义"><a href="#DFA形式化定义" class="headerlink" title="DFA形式化定义"></a>DFA形式化定义</h3><ul>
<li>确定有限自动机(DFA)，M是一个五元组，$M&#x3D;(K, \Sigma, f, S, Z)$<ul>
<li>K: 有穷状态集</li>
<li>$\Sigma$: 输入字母表(有穷), 输入符号集</li>
<li>f: 状态转换（移）函数，为$K \times \Sigma \rightarrow K$的单值部分映射，$f(k_i, a) &#x3D; k_j$表示：当现行状态为$k_i$，输入字符串为a时，将状态转换到下一个状态$k_j$，将$k_j$称为$k_i$的一个后继状态</li>
<li>$S \in K$: 初始状态</li>
<li>$Z \subseteq K$: 终态集，也称为可接受状态或结束状态</li>
</ul>
</li>
<li>DFA的扩展状态转移函数<ul>
<li>$f’: K \times \Sigma ^* \rightarrow K$映射，设$a \in \Sigma, \beta \in \Sigma^*, q \in K$，则</li>
<li>$f’(q, a\beta) &#x3D; f(q, a),\quad if \beta &#x3D; \epsilon$</li>
<li>$f’(q, a\beta) &#x3D; f’(f(q, a), \beta),\quad if \beta !&#x3D; \epsilon$</li>
</ul>
</li>
<li>DFA识别的语言<ul>
<li>设DFA $M&#x3D;(K, \Sigma, f, S, Z)$,如果$\alpha \in \Sigma ^*, f’(S, \alpha) \in Z$，则称符号串$\alpha$是DFA M所接受（或识别）的。DFA M所接受的符号串的集合记为L(M)</li>
<li>$$ L(M) &#x3D; {\alpha | \alpha \in \Sigma ^*}, f’(S, \alpha) \in Z $$</li>
<li>$\Sigma$上的一个符号串集$V \subseteq \Sigma ^*$是正规的，如果存在一个$\Sigma$上的DFA，使得V&#x3D;L(M)</li>
</ul>
</li>
</ul>
<h3 id="NFA的形式化定义"><a href="#NFA的形式化定义" class="headerlink" title="NFA的形式化定义"></a>NFA的形式化定义</h3><ul>
<li>一个非确定有限自动机(NFA) M是一个五元式$M&#x3D;(K, \Sigma, f, S, Z)$<ul>
<li>K: 有穷状态集</li>
<li>$\Sigma$: 输入字母表(有穷)</li>
<li>f: 状态转换（移）函数，为$K \times (\Sigma \cup {\epsilon}) \rightarrow P(K)$的部分映射，P(K)表示K的幂集</li>
<li>$S \in K$: 初始状态</li>
<li>$Z \subseteq K$: 终态集，也称为可接受状态或结束状态</li>
</ul>
</li>
<li>DFA与NFA的区别<ul>
<li>NFA弧上的标记可以是$\epsilon$</li>
<li>NFA同一个字母可能出现在同一状态射出的多条弧上</li>
<li>DFA是NFA的特例</li>
</ul>
</li>
<li>NFA扩展状态转移函数<ul>
<li>$f(q, a) \rightarrow Move(I, a) \rightarrow f’(I, s)$</li>
<li>$f’: P(K) \times \Sigma^* \rightarrow P(K)$映射。其中$a\in \Sigma, \quad s, \beta \in \Sigma^*, I \subset K$</li>
<li>$Move(I, a) &#x3D; \cup _{q \in I} f(q, a)$</li>
<li>$f’(I, a\beta) &#x3D; Move(I, a), \quad if \beta &#x3D;&#x3D; \epsilon$</li>
<li>$f’(I, a\beta) &#x3D; f’(Move(I, a), \beta), \quad if \beta !&#x3D; \epsilon$</li>
</ul>
</li>
<li>NFA识别的语言<ul>
<li>设NFA $M&#x3D;(K, \Sigma, f, S, Z)$,如果$\alpha \in \Sigma ^*, f’(S, \alpha) \cap Z !&#x3D; \varnothing$，则称符号串$\alpha$是DFA M所接受（或识别）的。DFA M所接受的符号串的集合记为L(M)</li>
<li>自动机的等价: 对于任何两个有限自动机M和M’,如果L(M)&#x3D;L(M’)，则称M与M’等价</li>
<li>对于每个NFA M存在一个DFA M’,使得L(M)&#x3D;L(M’)，反之亦然</li>
<li>DFA与NFA描述能力相同</li>
</ul>
</li>
<li>状态集I的转换运算<ul>
<li>设NFA $M&#x3D;(K, \Sigma, f, S, Z)$, $I \subseteq K$, $a \in \Sigma \cup {\epsilon}$，则Move(I, a)定义为$Move(I, a) &#x3D; \cup _{q \in I} f(q, a)$</li>
</ul>
</li>
<li>状态集I的$\epsilon$闭包<ul>
<li>$\epsilon - Closure(I) &#x3D; I$</li>
<li>$\epsilon- Closure(I) \cup &#x3D; Move(\epsilon - Closure(I), \epsilon)$</li>
<li>重复上一个步骤，直到$\epsilon-Closure(I)$不再扩大为止</li>
</ul>
</li>
</ul>
<h4 id="NFA-DFA的转换算法（子集构造法）"><a href="#NFA-DFA的转换算法（子集构造法）" class="headerlink" title="NFA-&gt;DFA的转换算法（子集构造法）"></a>NFA-&gt;DFA的转换算法（子集构造法）</h4><ul>
<li>输入: NFA $N&#x3D;(K, \Sigma, f, S_0, Z)$</li>
<li>输出: 等价的DFA $D&#x3D;(K, \Sigma, g, S&#x3D;\epsilon-closure({s_0}), F)$, $g(T, a) &#x3D; \epsilon-closure(move(T, a)) &#x3D; U$</li>
<li>方法：<ul>
<li>一开始，$\epsilon-closure({s_0})$是D中唯一的状态，且它未加标记<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (在D中存在未标记的状态T)&#123;</span><br><span class="line">    标记T;</span><br><span class="line">    for (a \in \Sigma) &#123;</span><br><span class="line">        U = \epsilon-closure(move(T, a));</span><br><span class="line">        Dtran[T, a] = U;</span><br><span class="line">        if (U不在D中) &#123;</span><br><span class="line">            将U加入到D中，且不加标记</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h4><ul>
<li>消除无用状态（不可达，没有通路到达状态）</li>
<li>合并等价状态<ul>
<li>一致性条件：p和q同时是可接受状态或不可接受状态</li>
<li>蔓延性条件：对所有输入符号，p和q必须转换到等价的状态中</li>
<li>方法：分割法-状态被分成不同子集，不同的子集不等价，同一子集等价</li>
</ul>
</li>
</ul>
<h2 id="正规式和有穷自动机的等价性"><a href="#正规式和有穷自动机的等价性" class="headerlink" title="正规式和有穷自动机的等价性"></a>正规式和有穷自动机的等价性</h2><ul>
<li>对于$\Sigma$上的NFA M，可以构造一个$\Sigma$上的正规式r,使得L(r) &#x3D; L(M)</li>
<li>对于$\Sigma$上的每一个正规式r,可以构造一个$\Sigma$上的NFA M，使得L(M) &#x3D; L(r)</li>
<li>新增两个状态X和Y作为开始状态和接受状态，且将X经$\epsilon$指向M的所有开始状态，将M的所有接受状态经$\epsilon$指向Y，得到M’,显有L(M’) &#x3D; L(M)</li>
</ul>
<h2 id="正规文法和有穷自动机的转换"><a href="#正规文法和有穷自动机的转换" class="headerlink" title="正规文法和有穷自动机的转换"></a>正规文法和有穷自动机的转换</h2><ul>
<li>正规文法$G&#x3D;(V_N, V_T, P, S) \rightarrow NFA M$<ul>
<li>M的字母表 &#x3D; G的终结符$V_T$</li>
<li>G的每个非终结符是M的一个状态</li>
<li>G的开始符S是M的开始状态S</li>
<li>增加新状态Z，作为M的终态</li>
<li>M的状态转移函数f<ul>
<li>如果$A \rightarrow a \in P$, 则$f(A, a) &#x3D; Z$</li>
<li>如果$A \rightarrow \epsilon \in P$, 则$f(A, \epsilon ) &#x3D; Z$</li>
<li>如果$A \rightarrow aB \in P$, 则$f(A, a) &#x3D; B$</li>
</ul>
</li>
</ul>
</li>
<li>有穷自动机$M&#x3D;(K, \Sigma, f, S, Z)$ \rightarrow 正则文法$G&#x3D;(K, \Sigma, P, S)$<ul>
<li>必要时确定化M（如果M含$\epsilon$转移）</li>
<li>G的产生式P由下列方法构造<ul>
<li>如$f(B, a) &#x3D; C$, 则$B \rightarrow aC$</li>
<li>对可接受态Z，增加产生式$Z \rightarrow \epsilon$</li>
<li>如$f(B, a) &#x3D; C$, C为终态，且非始态，又无出边，可直接$B\rightarrow a$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="词法分析程序的自动构造工具"><a href="#词法分析程序的自动构造工具" class="headerlink" title="词法分析程序的自动构造工具"></a>词法分析程序的自动构造工具</h2><ul>
<li>构造词法分析程序的技术线路<ul>
<li>一句给定的源语言之单词集，设计其正规文法或正规式</li>
<li>等价的转换成非确定有穷自动机NFA</li>
<li>再通过子集法将其确定话，最终将确定有穷自动机最小化(DFA)</li>
<li>最后依据最小化的DFA，设计词法分析程序</li>
</ul>
</li>
</ul>
<h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><ul>
<li>确定的自顶向下分析方法LL(1)<ul>
<li>LL(1)文法的判定与构造</li>
<li>LL(1)方法的分析技术<ul>
<li>递归下降子程序法</li>
<li>预测分析表: 每个产生式-&gt;首符号集</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="确定的自顶向下语法分析思想"><a href="#确定的自顶向下语法分析思想" class="headerlink" title="确定的自顶向下语法分析思想"></a>确定的自顶向下语法分析思想</h2><ul>
<li>从文法开始符号S推导出词串w的过程</li>
<li>从S为根节点，从顶部向底部（叶节点）构造语法分析树</li>
<li>每一步推导中，都需要左两个选择<ul>
<li>替换当前句型中那个非终结符</li>
<li>用该非终结符的哪个候选式进行替换</li>
</ul>
</li>
<li>非终结符的选择：最左推导<ul>
<li>总是选择每个句型的最左非终结符进行替换</li>
</ul>
</li>
<li>候选产生式的选择<ul>
<li>根据输入流中的下一个终结符，选择最左非终结符的一个候选式</li>
<li>确定的自顶向下：选择唯一可能推导出输入串w的规则进行推导</li>
<li>不确定的自顶向下：穷举产生式（回溯：尝试-&gt;返回-&gt;再尝试）</li>
</ul>
</li>
</ul>
<h3 id="FIRST集——串首（终结）符号集"><a href="#FIRST集——串首（终结）符号集" class="headerlink" title="FIRST集——串首（终结）符号集"></a>FIRST集——串首（终结）符号集</h3><ul>
<li>设文法$G &#x3D; (V_N, V_T, P, S)$，则$FIRST(\alpha) &#x3D; {a | \alpha \Rightarrow^* a \beta, a \in V_T, \alpha, \beta \in V*}$<ul>
<li>特别地，$\alpha \Rightarrow^* \epsilon$,约定$\epsilon \in FIRST(\alpha)$</li>
</ul>
</li>
<li>同一非终结符的多个产生式，若右部的FIRST集无交集，则推导式确定的</li>
</ul>
<h3 id="FOLLOW-A-——非终结符的后继（终结）符号集"><a href="#FOLLOW-A-——非终结符的后继（终结）符号集" class="headerlink" title="FOLLOW(A)——非终结符的后继（终结）符号集"></a>FOLLOW(A)——非终结符的后继（终结）符号集</h3><ul>
<li>设文法$G &#x3D; (V_N, V_T, P, S)$, $A \in V_N$, 则$FOLLOW(A) &#x3D; {a | S \Rightarrow^* \alpha A \beta, a \in V_T, a \in FIRST(\beta), \alpha, \beta \in V*}$</li>
<li>或者说，$FOLLOW(A) &#x3D; {a | S \Rightarrow^* …Aa…, a \in V_T}$</li>
<li>若$S\Rightarrow^*…A$，或者上述模式中的$\beta \Rightarrow^* \epsilon$,则句末符$$ \in FOLLOW(A)$</li>
<li>FOLLOW(A)是由任意句型中紧邻非终结符A之后出现的终结符a组成的集合</li>
<li>如果对非终结符A，有一条空规则，则A的FOLLOW集合和A的非空右部的FIRST集合两两相交为空，可以使用确定的最左推导</li>
<li>#什么时候也要添加到FOLLOW集中<ul>
<li>$$ \in FOLLOW(S)$,S为文法的开始符号</li>
<li>$S \Rightarrow^* … A$,则$$ \in FOLLOW(A)$,#为输入串的结束符</li>
<li>$S \Rightarrow^* … A\beta$,且$\beta \Rightarrow^* \epsilon$,亦有$$ \in FOLLOW(A)$</li>
<li>$A \Rightarrow^* … B$，或$A \Rightarrow^* … B \beta, \beta \Rightarrow^* \epsilon$,则$FOLLOW(A) \subseteq FOLLOW(B)$</li>
</ul>
</li>
</ul>
<h3 id="SELECT-A-rightarrow-alpha-产生式的可选集"><a href="#SELECT-A-rightarrow-alpha-产生式的可选集" class="headerlink" title="SELECT(A$\rightarrow\alpha$)-产生式的可选集"></a>SELECT(A$\rightarrow\alpha$)-产生式的可选集</h3><p>设文法$G &#x3D; (V_N, V_T, P, S), A \in V_N, A \rightarrow \alpha \in P$，则<br>$$ SELECT(A \rightarrow \alpha) &#x3D; FIRST(\alpha), if \alpha !\Rightarrow^* \epsilon, else (First(\alpha) - {\epsilon}) \cup FOLLOW(A) $$<br>$$ SELECT(A \rightarrow \epsilon) &#x3D; FOLLOW(A) $$</p>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><ul>
<li>文法G是LL(1)的，当且仅当对每个$V_N$, A的两个不同产生式$A \rightarrow \alpha, A \rightarrow \beta$，满足$SELECT(A\rightarrow\alpha) \cap SELECT(A \rightarrow \beta) &#x3D; \varnothing$, 其中$\alpha, \beta$不能同时推导出$\epsilon$</li>
<li>LL(1)代表<ul>
<li>Left to right parsing 从左到右分析token</li>
<li>Left most derivation 最左推导</li>
<li>1: 只需向右看1个符号便可以决定选择哪个产生式进行推导</li>
</ul>
</li>
<li>确定的，无二义性的</li>
</ul>
<h2 id="LL-1-文法的判别"><a href="#LL-1-文法的判别" class="headerlink" title="LL(1)文法的判别"></a>LL(1)文法的判别</h2><ul>
<li>判别依据：根据上面的定义，文法G是LL(1)的，当且仅当任意两个左部相同的产生式其SELECT集的交集为空</li>
<li>若存在非终结符的多个产生式，你必须计算SELECT()集<ul>
<li>判别$\alpha \Rightarrow^* \epsilon$，仅当$\alpha$中所有非终结符全部可推导出空，且$\alpha$无非空的终结符</li>
<li>求产生式右部FIRST集，如产生式右部可推导出$\epsilon$，则还需计算产生式左部FOLLOW集</li>
</ul>
</li>
</ul>
<h4 id="判断非终结符是否能推出空串"><a href="#判断非终结符是否能推出空串" class="headerlink" title="判断非终结符是否能推出空串"></a>判断非终结符是否能推出空串</h4><ul>
<li>$\rightarrow \epsilon$的非终结符，直接标记Yes，并划掉其所有产生式</li>
<li>如果一个非终结符的所有产生式右侧至少有一个非$\epsilon$的终结符，它就不可能推导出$\epsilon$。直接标记No，并花掉其所有产生式。剩下的产生式中，但凡右侧有一个非$\epsilon$的终结符，也不可能推到出$\epsilon$。这样的产生式也划掉</li>
<li>在剩下的产生式中，把所有能$&#x3D;&gt;\epsilon$的非终结符，替换成$\epsilon$，化简，结果$&#x3D;\epsilon$，标yes，否则no</li>
</ul>
<h4 id="FIRST-X-的算法"><a href="#FIRST-X-的算法" class="headerlink" title="FIRST(X)的算法"></a>FIRST(X)的算法</h4><p>$X \in V$</p>
<ul>
<li>若$X \in V_T$, FIRST(X) &#x3D; {X};</li>
<li>若$X \rightarrow \epsilon$, $FIRST(X) \cup &#x3D; {\epsilon}$</li>
<li>对于所有形如$X \rightarrow a…$规则，且$a \in V_T, FIRST(X) \cup &#x3D; {a}$</li>
<li>对于所有形如$X \rightarrow Y_1Y_2…Y_n$规则，$Y_i \in V_N$<ul>
<li>如果$Y_1 \Rightarrow^* \epsilon, Y_2 \Rightarrow^* \epsilon, …, Y_{i-1} \Rightarrow^* \epsilon ,(i &lt;&#x3D; n)$，则$FIRST(X) \cup &#x3D; (FIRST(Y_1)\cup FIRST(Y_2)…\cup FIRST(Y_i)) - {\epsilon}$</li>
<li>如果$Y_1 \Rightarrow^* \epsilon, Y_2 \Rightarrow^* \epsilon, …, Y_n \Rightarrow^* \epsilon$，则$FIRST(X) \cup &#x3D; (FIRST(Y_1) \cup FIRST(Y_2) … \cup FIRST(Y_i)) \cup {\epsilon}$</li>
</ul>
</li>
<li>重复上一个步骤，直到FIRST()不再扩大为止</li>
</ul>
<h4 id="求FIRST-alpha-的算法"><a href="#求FIRST-alpha-的算法" class="headerlink" title="求FIRST($\alpha$)的算法"></a>求FIRST($\alpha$)的算法</h4><p>$\alpha \in V^*, |\alpha| &#x3D; n, \alpha &#x3D; Y_1Y_2…Y_n \in (V_N \cup V_T)*$，先置$FIRST(\alpha) &#x3D; \varnothing$</p>
<ul>
<li>如果$Y_1 \in V_T$，则$FIRST(\alpha) &#x3D; {Y_1}$</li>
<li>如果$Y_1 \Rightarrow^* \epsilon, Y_2 \Rightarrow^* \epsilon, …, Y_{i-1}\Rightarrow^* \epsilon, (1 &lt; i &lt;&#x3D; n)$, 则$FIRST(\alpha) &#x3D; (FIRST(Y_1)\cup FIRST(Y_2)… \cup FIRST(Y_i)) - {\epsilon}$</li>
<li>如果$Y_1 \Rightarrow^* \epsilon, …, Y_n \Rightarrow^* \epsilon$, 则$FIRST(\alpha) &#x3D; (FIRST(Y_1)\cup … \cup FIRST(Y_n)) \cup {\epsilon}$</li>
</ul>
<h4 id="求FOLLOW-A-的算法"><a href="#求FOLLOW-A-的算法" class="headerlink" title="求FOLLOW(A)的算法"></a>求FOLLOW(A)的算法</h4><p>$A \in V_N$</p>
<ul>
<li>置$FOLLOW(A) &#x3D; \varnothing$,置$FOLLOW(S) &#x3D; { $ }$</li>
<li>若有产生式$B \rightarrow \alpha A \beta, B \in V_N$, 则$FOLLOW(A) \cup &#x3D; (FIRST(\beta) - {\epsilon})$</li>
<li>若有产生式$B \rightarrow \alpha A$或$B \rightarrow \alpha A \beta$,且$\beta \Rightarrow^* \epsilon$，则$FOLLOW(A) \cup &#x3D; FOLLOW(B)$</li>
<li>重复上面两个步骤，直到FOLLOW(A)不再扩大为止</li>
</ul>
<h2 id="某些非LL-1-文法到LL-1-文法的等价变换"><a href="#某些非LL-1-文法到LL-1-文法的等价变换" class="headerlink" title="某些非LL(1)文法到LL(1)文法的等价变换"></a>某些非LL(1)文法到LL(1)文法的等价变换</h2><ul>
<li>非LL(1)文法<ul>
<li>若文法含有左公共因子，一定不是LL(1)文法</li>
<li>若文法含有直接或间接左递归，一定不是LL(1)文法</li>
</ul>
</li>
<li>非LL(1)文法\rightarrowLL(1)文法的等价变换<ul>
<li>提取左公共因子</li>
<li>消除左递归<ul>
<li>消除直接左递归法</li>
<li>消除简介左递归法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="提取左公共因子"><a href="#提取左公共因子" class="headerlink" title="提取左公共因子"></a>提取左公共因子</h4><ul>
<li>对形如$A \rightarrow \alpha \beta | \alpha \gamma$进行等价变换为$A \rightarrow \alpha ( \beta | \gamma)$<ul>
<li>进一步变换为$A \rightarrow \alpha A’; A’ \rightarrow \beta | \gamma$</li>
</ul>
</li>
<li>对形如$A \rightarrow \alpha \beta_1 | \alpha \beta_2 | … | \alpha \beta_n$进行等价变换<ul>
<li>$A \rightarrow \alpha A’; A’ \rightarrow \beta_1 |… | \beta_n$</li>
</ul>
</li>
<li>若$A’ \rightarrow \beta_1 | \beta_2 | … | \beta_n$中仍含左公共因子，再次提取，直至所有的产生式不再有左公共因子</li>
<li>文法中不含左公共因子只是LL(1)文法的必要条件</li>
</ul>
<h3 id="递归文法"><a href="#递归文法" class="headerlink" title="递归文法"></a>递归文法</h3><ul>
<li>对于文法G，形如$A \rightarrow \alpha A \beta$的规则称为文法G的直接递归规则。特别的，如果$\alpha &#x3D; \epsilon$时候，则称为文法G的直接左递归规则。如果$\beta &#x3D; \epsilon$时，则称文法G的直接右递归规则</li>
<li>设文法G，如果存在推导$A \rightarrow \alpha \Rightarrow^* \lambda A \mu$，则称规则$A \rightarrow \alpha$为文法G的间接递归规则。特别的，如果$\lambda &#x3D; \epsilon$时，称为文法G的间接左递归规则。如果$\mu &#x3D; \epsilon$时，则称文法G的间接右递归规则</li>
</ul>
<h3 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h3><p>消除文法中一切左递归的算法（无有害规则，无空产生式）</p>
<p>将$V_N$中的非终结符按任意顺序线性排列,$A_1, …, A_n$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">    若Aj的产生式为 A_j -&gt; \dleta_1 | ... | \delta_k</span><br><span class="line">    则形如A_i -&gt; A_j \gamma的产生式变为A_i -&gt; \delta_1 \gamma | \delta_2 \gamma | ... | delta_k \gamma</span><br><span class="line">  &#125;</span><br><span class="line">  消除A_i的直接左递归</span><br><span class="line">&#125;</span><br><span class="line">删除无用产生式</span><br></pre></td></tr></table></figure>

<h2 id="LL-1-分析的实现-递归下降分析法"><a href="#LL-1-分析的实现-递归下降分析法" class="headerlink" title="LL(1)分析的实现-递归下降分析法"></a>LL(1)分析的实现-递归下降分析法</h2><ul>
<li>LL(1)文法的（确定的自顶向下）分析方法<ul>
<li>递归下降的LL(1)分析法（递归的预测分析法）</li>
<li>（预测分析）表驱动的LL(1)分析法（非递归的预测分析法）</li>
</ul>
</li>
</ul>
<h3 id="递归下降子程序法的基本思想"><a href="#递归下降子程序法的基本思想" class="headerlink" title="递归下降子程序法的基本思想"></a>递归下降子程序法的基本思想</h3><ul>
<li>将每个非终结符编写称一个递归子程序，完成选择规则、推导和匹配的功能</li>
<li>若非终结符A有多个产生式，则根据产生式的SELECT集选择相应的规则推导</li>
<li>对规则$A\rightarrow Y_1…Y_n$，依次调用右部非终结符的子程序或匹配终结符，$Y_i$为非终结符则调用$Y_i$对应的子程序，若$Y_i$为终结符，则与当前token匹配。匹配成功则调用词法分析程序取下一个token，匹配失败或当前token不属于任何SELECT集时，报告语法错误</li>
<li>按照递归子程序法构造的语法分析程序是由一个总控子程序和一组非终结符对应的递归子程序组成的</li>
</ul>
<h2 id="LL-1-分析的实现-表驱动分析法"><a href="#LL-1-分析的实现-表驱动分析法" class="headerlink" title="LL(1)分析的实现-表驱动分析法"></a>LL(1)分析的实现-表驱动分析法</h2><ul>
<li>输入栈I: 以串末端为底，栈内为未匹配部分；初始状态为w#,w为要识别的串</li>
<li>分析栈S: 推导过程产生的句型未匹配部分；初始状态为#S</li>
<li>分析表M: 若$a \in SELECT(A \rightarrow \alpha)$，则$M[A, a] &#x3D; (A\rightarrow \alpha)$</li>
<li>输出: w的最左推导，或报告语法错误</li>
</ul>
<h2 id="LL-1-中的出错处理"><a href="#LL-1-中的出错处理" class="headerlink" title="LL(1)中的出错处理"></a>LL(1)中的出错处理</h2><ul>
<li>错误处理的两个任务<ul>
<li>报错<ul>
<li>栈顶的终结符与输入符号不匹配</li>
<li>非终结符A位于栈顶，面临的输入符号位a，但分析表的表项M[A, a]位空</li>
</ul>
</li>
<li>错误恢复<ul>
<li>应急恢复</li>
<li>短语层恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应急恢复"><a href="#应急恢复" class="headerlink" title="应急恢复"></a>应急恢复</h3><ul>
<li>栈顶终结符与输入符号不匹配</li>
<li>在空的M[A, a]指定同步符号，一旦遇到这种错误，就跳过输入符号，直到遇到同步符号位置</li>
<li>当分析栈顶位A，一旦错误发生<ul>
<li>跳过输入串中的一些符号，直到遇到FOLLOW(A)中的符号，然后A退栈。相当于跳过A能推导出的所有符号，A的推导完成。</li>
<li>跳过输入串中的一些符号，直到遇到FIRST(A)中的符号。相当于从A开始推导。</li>
</ul>
</li>
</ul>
<h3 id="短语层恢复"><a href="#短语层恢复" class="headerlink" title="短语层恢复"></a>短语层恢复</h3><ul>
<li>每个非终结符，开始分析时，使用一个符号集合BeginSym;分析结束时，使用一个符号集合EndSym</li>
</ul>
<h1 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h1><h2 id="LR分析概述"><a href="#LR分析概述" class="headerlink" title="LR分析概述"></a>LR分析概述</h2><ul>
<li>LR(K)<ul>
<li>L - left to right parsing</li>
<li>R - right most derivation in Reverse</li>
<li>K - look ahead K token(s)</li>
</ul>
</li>
</ul>
<h2 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0)分析"></a>LR(0)分析</h2><ul>
<li>将符号出啊的任意含有头符号的子串称为前缀。特别的，空串$\epsilon$为任意串的前缀</li>
<li>设文法G[S]，如果$S \Rightarrow^* _R \alpha A \omega &#x3D;R&gt; \alpha \beta \omega$是句型$\alpha \beta \omega$的规范推导，则$\alpha \beta$称为可归前缀，$\alpha \beta$的前缀称为活前缀</li>
<li>可归前缀的后缀是句柄，句型的活前缀的右端不超过句柄末端</li>
<li>增广文法<ul>
<li>$G[S] &#x3D; (V_N, V_T, P, S)$</li>
<li>$G[S’] &#x3D; (V_N \cup {S’}, V_T, P \cup {S’ \rightarrow S}, S’)$</li>
<li>$V_N \cap {S’} &#x3D; \varnothing$</li>
<li>则称G[S’]是G[S]的增广文法</li>
</ul>
</li>
</ul>
<h3 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h3><ul>
<li>移进项目: $A \rightarrow \alpha \cdot a \beta$</li>
<li>待约项目: $A \rightarrow \alpha \cdot X \beta$</li>
<li>归约项目: $A \rightarrow \cdot$</li>
<li>接受项目: $S’ \rightarrow \alpha \cdot, S’ \rightarrow S \cdot$</li>
</ul>
<h4 id="LR-0-项目的MOVE运算定义"><a href="#LR-0-项目的MOVE运算定义" class="headerlink" title="LR(0)项目的MOVE运算定义"></a>LR(0)项目的MOVE运算定义</h4><p>设I是文法G的LR(0)项目子集，则MOVE(I, X)定义如下<br>$$ MOVE(I, X) &#x3D; {A \rightarrow \alpha X \cdot \beta | A \rightarrow \alpha \cdot X \beta \in I } $$</p>
<h4 id="LR-0-项目的CLOSURE运算定义"><a href="#LR-0-项目的CLOSURE运算定义" class="headerlink" title="LR(0)项目的CLOSURE运算定义"></a>LR(0)项目的CLOSURE运算定义</h4><ul>
<li>设I是文法G的LR(0)项目子集，则closure(I)定义如下<ul>
<li>$I \subset closure(I)$</li>
<li>${B \rightarrow \cdot \gamma | A \rightarrow \alpha \cdot B \beta \in closure(I)} \subset closure(I)$</li>
<li>重复上一个步骤，直到closure(I)不再扩大为止</li>
</ul>
</li>
</ul>
<h4 id="LR-0-识别或前缀DFA-M构造方法"><a href="#LR-0-识别或前缀DFA-M构造方法" class="headerlink" title="LR(0)识别或前缀DFA M构造方法"></a>LR(0)识别或前缀DFA M构造方法</h4><ul>
<li>设文法$G&#x3D;(V_N, V_T, P, S)$，且已等价改写成文法G’的增广文法，则识别或前缀DFA $M &#x3D; (K, \Sigma, f, S, Z)$<ul>
<li>$K \subseteq \rho$(LR(0)项目集)</li>
<li>$\Sigma &#x3D; V_N \cup V_T$</li>
<li>$f(I, X) &#x3D; closure(Move(I, X)), I \in K, X \in \Sigma$</li>
<li>$S &#x3D; closure(S’ \rightarrow \cdot S)$</li>
<li>$Z &#x3D; {q | q \in K, q含有归约项目}$</li>
</ul>
</li>
<li>文法G的识别或前缀DFA M的状态集称为文法G的LR(0)项目集规范族</li>
</ul>
<h4 id="LR-0-分析表的构造"><a href="#LR-0-分析表的构造" class="headerlink" title="LR(0)分析表的构造"></a>LR(0)分析表的构造</h4><ul>
<li>对每一个LR(0)项目，依据下列情况分别填分析表<ul>
<li>移进项目$A \rightarrow \alpha \cdot a \beta \in I_K, f(I_K, a) &#x3D; I_j$，置ACTION[k, a]为$S_j$</li>
<li>归约项目$A \rightarrow \alpha \cdot \in I_K, A \rightarrow \alpha$标号为i，置ACTION[k, a]为$r_i$, $a \in (V_T \cup { $ })$</li>
<li>接受项目$S’ \rightarrow S \cdot \in I_K$，则置ACTION[k, #]为acc</li>
<li>待约项目$A \rightarrow \alpha \cdot X \beta \in I_K$，如果$f(I_k, X) &#x3D; I_j, X \in V_N$，置GOTO[k, X]为j</li>
</ul>
</li>
<li>凡以上后没能填入分析表元素ACTION和GOTO的，置为$e_t$(t为错误编号)</li>
<li>移进-归约冲突：项目集中同时出现移进和归约项目<ul>
<li>$A \rightarrow \alpha \cdot a \beta$</li>
<li>$B \rightarrow \gamma \cdot$</li>
</ul>
</li>
<li>归约-归约冲突：项目集中同时出现多个归约项目<ul>
<li>$A \rightarrow \alpha \cdot$</li>
<li>$B \rightarrow \beta \cdot$</li>
</ul>
</li>
</ul>
<h3 id="LR-0-文法"><a href="#LR-0-文法" class="headerlink" title="LR(0)文法"></a>LR(0)文法</h3><ul>
<li>如果文法G的LR(0)项目集规范族不存在移进-归约冲突或归约-归约冲突的项目集，则文法G为LR(0)文法<ul>
<li>如果文法G是LR(0)文法，则G可采用LR(0)分析法</li>
<li>如果文法G是LR(0)文法，则G是无二义性的</li>
</ul>
</li>
<li>LR(0)分析表ACTION表中每格仅会是移进、归约和报错三种动作之一</li>
</ul>
<h2 id="SLR-1-分析"><a href="#SLR-1-分析" class="headerlink" title="SLR(1)分析"></a>SLR(1)分析</h2><ul>
<li>不是LR(0)文法时，可以采用简单地向后看1个输入符号的方法，解决移进-归约冲突或归约-归约冲突</li>
<li>假设文法LR(0)项目集规范族有一个并存移进-归约冲突和归约-归约冲突的项目集$I_K &#x3D; { A \rightarrow \alpha \cdot a \beta, A \rightarrow \gamma \cdot, B \rightarrow \delta \cdot, …}$<ul>
<li>若${a} \cap FOLLOW(A) \cap FOLLOW(B) &#x3D; \varnothing$，则冲突可解决<ul>
<li>如果下一符号$a_i \in 移入符号集$，则<strong>移入</strong></li>
<li>如果下一符号$a_i \in FOLLOW(A)$，则用$A \rightarrow \gamma$归约</li>
<li>如果下一符号$a_i \in FOLLOW(B)$，则用$B \rightarrow \delta$归约</li>
</ul>
</li>
</ul>
</li>
<li>SLR(1)分析表的构造<ul>
<li>移进项目$A \rightarrow \alpha \cdot a \beta \in I_K, f(I_K, a) &#x3D; I_j$，置ACTION[k, a]为$S_j$</li>
<li>归约项目$A \rightarrow \alpha \cdot \in I_K, A \rightarrow \alpha$标号为i，置ACTION[k, a]为$r_i$, $a \in FOLLOW(A)$</li>
<li>接受项目$S’ \rightarrow S \cdot \in I_K$, 则置ACTION[k, #]为acc</li>
<li>待约项目$A \rightarrow \alpha \cdot X \beta \in I_K$，如果$f(I_K, X)&#x3D;I_j, X \in V_N$,置GOTO[k, x]为j</li>
</ul>
</li>
</ul>
<h3 id="SLR-1-文法"><a href="#SLR-1-文法" class="headerlink" title="SLR(1)文法"></a>SLR(1)文法</h3><ul>
<li>设文法G的LR(0)项目集规范族C中任意含有m个移进项目和n个归约项目的冲突项目集$I_K$的一般形式为</li>
<li>$I_K &#x3D; {A_1 \rightarrow \alpha_1 \cdot a_1 \beta_1, A_2 \rightarrow \alpha_2 \cdot a_2 \beta_2, …, A_m \rightarrow \alpha_m \cdot a_m \beta_m, B_1 \rightarrow \gamma_1 \cdot, B_2 \rightarrow \gamma_2 \cdot, …, B_n \rightarrow \gamma_n \cdot, … }$</li>
<li>如果移进符号集${a_1, …, a_m}$和$FOLLOW(B_1), …, FOLLOW(B_n)$两两相交均为空集，则文法G称为SLR(1)文法</li>
<li>SLR(1)文法无二义性</li>
<li>LR(0)文法，一定也是SLR(1)文法</li>
</ul>
<h2 id="LR-1-分析"><a href="#LR-1-分析" class="headerlink" title="LR(1)分析"></a>LR(1)分析</h2><ul>
<li>SLR(1)分析法存在的问题<ul>
<li>SLR只是简单地考察下一个输入符号b是否属于与归约项目$A \rightarrow \alpha$相关联的FOLLOW(A)，但$b \in FOLLOW(a)$只是归约$\alpha$的一个必要条件，而非充分条件</li>
<li>对于产生式$A \rightarrow \alpha$的归约，在不同的使用位置，A会要求不同的后继符号</li>
<li>在特定位置，A的后继符集合是FOLLOW(A)的子集</li>
</ul>
</li>
<li>LR(1)的基本思想<ul>
<li>若$A \rightarrow \alpha \cdot B \beta \in I_i$，则$B \rightarrow \cdot \gamma \in I_i$</li>
<li>在状态$I_j$：下个符号属于FOLLOW(B)而不属于FIRST($\beta$)，即便归约到B，此路也不通</li>
<li>把$FIRST(\beta)$作为产生式$B \rightarrow \gamma$归约时向前查看的符号集合（向前搜索符号集，前瞻符号集），代替SLR(1)分析法中的FOLLOW(B)，并将向前搜索符号集也放在LR(0)项目的后面</li>
<li>$[A \rightarrow \alpha \cdot \beta, a]$，a称为向前搜索夫（展望符&#x2F;前瞻符）——LR(1)项目</li>
</ul>
</li>
</ul>
<h3 id="LR-1-项目"><a href="#LR-1-项目" class="headerlink" title="LR(1)项目"></a>LR(1)项目</h3><ul>
<li>附加搜索符$(\in V_T \cup { $ })$的LR(0)项目称为LR(1)项目<ul>
<li>[LR(0)项目，搜索符]</li>
<li>LR(0)项目-LR(1)项目的心</li>
<li>对于同心的LR(1)项目简记：[LR(0)项目，搜索符1|搜索符2|…|搜索符m]</li>
<li>“搜索符1|…|搜索符m”称为搜索集</li>
</ul>
</li>
<li>形如$[A \rightarrow \alpha \cdot, a]$的项表示仅在下一个输入符号等于a时才可以按照$A \rightarrow \alpha$进行归约</li>
<li>这样的a的集合总是FOLLOW(A)的子集，通常是真子集</li>
<li>搜索符的继承与传播<ul>
<li>$[A \rightarrow \alpha \cdot B \beta, a], 又有B \rightarrow \gamma \in P, \Rightarrow [B \rightarrow \cdot \gamma, b], b \in FIRST(\beta \alpha)$</li>
<li>当$\beta \Rightarrow^+ \epsilon$时，此时b&#x3D;a叫继承的搜索符，否则叫自生的搜索符</li>
</ul>
</li>
</ul>
<h3 id="LR-1-项目集族的构造"><a href="#LR-1-项目集族的构造" class="headerlink" title="LR(1)项目集族的构造"></a>LR(1)项目集族的构造</h3><ul>
<li>设I是文法G的LR(1)项目子集，则MOVE1(I, X)定义如下<ul>
<li>$Move1(I, X) &#x3D; {[A \rightarrow \alpha X \cdot \beta, a] | [A \rightarrow \alpha \cdot X \beta, a] \in I}$</li>
</ul>
</li>
<li>设I是文法G的LR(1)项目子集，closure1(I)定义如下<ul>
<li>$I \subset closure1(I)$</li>
<li>${[B \rightarrow \cdot \gamma, b] | [A \rightarrow \alpha \cdot B \beta, a] \in closure1(I), b \in FIRST(\beta a)} \subset closure1(I)$</li>
<li>重复上一个步骤，直到closure1(I)不再扩大为止</li>
</ul>
</li>
</ul>
<h3 id="LR-1-分析表的构造"><a href="#LR-1-分析表的构造" class="headerlink" title="LR(1)分析表的构造"></a>LR(1)分析表的构造</h3><h4 id="LR-1-识别活前缀的DFA-M构造"><a href="#LR-1-识别活前缀的DFA-M构造" class="headerlink" title="LR(1)识别活前缀的DFA M构造"></a>LR(1)识别活前缀的DFA M构造</h4><ul>
<li>文法$G &#x3D; (V_N, V_T, P, S)$，等价改写成文法$G’&#x3D;(V_N \cup {S’}, V_T, P \cup {S’ \rightarrow S}, S’)$，其中$V_n \cup {S’} &#x3D; \varnothing$，则识别或前缀DFA $M&#x3D;(K, \Sigma, f, S, Z)$，其中<ul>
<li>$K \subseteq \rho$(LR(1)项目集)</li>
<li>$\Sigma &#x3D; V_N \cup V_T$</li>
<li>$f(I, X) &#x3D; closure(Move1(I, X)), I \in K, X \in \Sigma$</li>
<li>$S &#x3D; closure1([S’ \rightarrow \cdot S, $ ])$</li>
<li>$Z &#x3D; {q | q \in K, q含有归约项目}$</li>
</ul>
</li>
<li>文法G的LR(1)识别或前缀DFA M的状态集称为文法G的LR(1)项目集规范族</li>
</ul>
<h4 id="LR-1-分析表的构造-1"><a href="#LR-1-分析表的构造-1" class="headerlink" title="LR(1)分析表的构造"></a>LR(1)分析表的构造</h4><ul>
<li>文法G的LR(1)项目集规范族$C&#x3D;{I_0, …, I_n}$</li>
<li>对C中每个$I_i$构造得到状态i。状态i的语法分析动作按照下面的方法决定<ul>
<li>$if [A \rightarrow \alpha \cdot a \beta, b] \in I_i \quad \And \And \quad f(I_i, a) &#x3D; I_j \quad then\quad ACTION[i, a] &#x3D; S_j$</li>
<li>$if [A \rightarrow \alpha \cdot B \beta, b] \in I_i \quad \And \And \quad f(I_i, B) &#x3D; I_j \quad then\quad GOTO[i, B] &#x3D; j$</li>
<li>$if [A \rightarrow \alpha \cdot, a] \in I_i \quad \And \And \quad A !&#x3D; S’ \quad then\quad ACTION[i, a] &#x3D; r_j$(j是产生式$A \rightarrow \alpha$的编号)</li>
<li>$if [S’ \rightarrow S \cdot, $ ] \in I_i \quad then\quad ACTION[i, $ ] &#x3D; acc$</li>
</ul>
</li>
<li>所有没有定义的条目都设置为$e_t$，t是错误编号</li>
</ul>
<h3 id="LR-1-的冲突"><a href="#LR-1-的冲突" class="headerlink" title="LR(1)的冲突"></a>LR(1)的冲突</h3><ul>
<li>设文法G的LR(1)项目集规范族C中任意含有m个移进项目和n个归约项目的冲突项目集$I_K$的一般形式为$I_K&#x3D;{[A_1 \rightarrow \alpha_1 \cdot a_! \beta_1, S_1 ‘], …, [A_m \rightarrow \alpha_m \cdot a_m \beta_m, S_m’],[B_1 \rightarrow \gamma_2 \cdot , S_1], …, [B_m \rightarrow \gamma_n \cdot, S_n], …}, A_i, B_j \in V_n, a_i \in V_T, \alpha_i, \beta_j, \gamma_j \in (V_N \cup V_T)*, S_i’, S_j$为搜索集</li>
<li>如果移进符号集${a_1, a_2, …, \alpha_m}$和搜索集$S_1, …, S_n$两两相交均为空集，则文法G称为LR(1)文法</li>
<li>结论<ul>
<li>如果文法G是LR(1)文法，则G可采用LR(1)分析法</li>
<li>如果文法G是LR(1)文法，则G是无二义性的</li>
<li>如果文法G是SLR(1)文法，则G一定是LR(1)</li>
</ul>
</li>
</ul>
<h2 id="LALR-1-分析"><a href="#LALR-1-分析" class="headerlink" title="LALR(1)分析"></a>LALR(1)分析</h2><ul>
<li>如果采用同心项目集合并方法，进行合并后的文法G的LR(1)项目集规范组，没有LR(1)项目冲突，则称文法G为LALR(1)文法</li>
<li>结论<ul>
<li>如果文法G是LALR(1)文法，则G可采用LALR(1)分析法</li>
<li>如果文法G是LALR(1)文法，则G是无二义性的</li>
<li>如果文法G是LALR(1)文法，则G一定是LR(1)</li>
</ul>
</li>
<li>特点<ul>
<li>形式上与LR(1)相同</li>
<li>大小上与LR(0)&#x2F;SLR相当</li>
<li>分析能力介于SLR和LR(1)二者之间$LR(0) &lt; SLR(1) &lt; LALR(1) &lt; LR(1)$</li>
<li>合并后的向前搜索符集合仍为FOLLOW集的子集</li>
</ul>
</li>
</ul>
<h2 id="二义性文法的应用"><a href="#二义性文法的应用" class="headerlink" title="二义性文法的应用"></a>二义性文法的应用</h2><ul>
<li>特点<ul>
<li>任何一个二义性文法都不是LR的</li>
<li>某些类型的二义性文法在语言的描述和实现中很有用</li>
</ul>
</li>
</ul>
<h1 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h1><h2 id="基于属性文法的语义计算"><a href="#基于属性文法的语义计算" class="headerlink" title="基于属性文法的语义计算"></a>基于属性文法的语义计算</h2><h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><ul>
<li>在基础文法的基础上<ul>
<li>为每个文法符号（终结符或非终结符）配备若干相关属性，代表与文法符号相关信息，如类型、值、代码片段、符号表内容等</li>
<li>对于文法的每个产生式都配备了一组属性的语义规则（动作），对属性进行计算和传递</li>
</ul>
</li>
<li>翻译模式(SDT): 明确语义计算的时机<ul>
<li>把{语义动作}插入到产生式右部恰当位置，按照分析的进程执行相应的语义计算</li>
</ul>
</li>
</ul>
<h4 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h4><ul>
<li>计算规则: 通过自身属性和产生式右部属性值进行计算</li>
<li>语法规则: 产生式左部符号的综合属性由自身的产生式右部符号的属性计算得出</li>
<li>语法树: 父节点的综合属性由子节点的属性和父节点自身的属性计算得出</li>
<li>自下而上传递信息</li>
</ul>
<h5 id="非终结符的综合属性"><a href="#非终结符的综合属性" class="headerlink" title="非终结符的综合属性"></a>非终结符的综合属性</h5><ul>
<li>产生式的左部</li>
<li>产生式的右部</li>
</ul>
<h5 id="终结符的综合属性"><a href="#终结符的综合属性" class="headerlink" title="终结符的综合属性"></a>终结符的综合属性</h5><ul>
<li>终结符可以具有综合属性</li>
<li>由词法分析器提供</li>
<li>固有属性</li>
<li>没有计算规则</li>
</ul>
<h4 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h4><ul>
<li>计算规则: 根据自身属性和产生式自身左边符号的属性计算</li>
<li>语法规则: 通过产生式左部符号的属性和右部符号的属性计算更右部符号的继承属性</li>
<li>语法树: 根据父节点和兄长节点的属性计算子节点的继承属性</li>
<li>自上而下传递信息</li>
</ul>
<h4 id="语义规则"><a href="#语义规则" class="headerlink" title="语义规则"></a>语义规则</h4><ul>
<li>右部符号的继承属性和左部符号的综合属性<ul>
<li>由本产生式提供计算规则。且规则中只能使用本产生式中文法符号的属性</li>
</ul>
</li>
<li>左部符号的继承属性和右部符号的综合属性<ul>
<li>由其它产生式提供语义规则来计算</li>
</ul>
</li>
<li>内容<ul>
<li>属性计算</li>
<li>静态语义检查<ul>
<li>类型检查、控制流检查、唯一性检查、关联名检查</li>
</ul>
</li>
<li>符号表操作</li>
<li>代码生成</li>
<li>给出错误信息</li>
<li>执行其它动作</li>
</ul>
</li>
</ul>
<h4 id="属性的计算及注释分析树（含继承属性）"><a href="#属性的计算及注释分析树（含继承属性）" class="headerlink" title="属性的计算及注释分析树（含继承属性）"></a>属性的计算及注释分析树（含继承属性）</h4><ul>
<li>在语法树中，一个节点的继承属性由其父节点、其兄弟节点和其本身的某些属性确定</li>
<li>不能在LR分析的同时构造带注释的语法树：先构造语法树，再计算属性</li>
</ul>
<h3 id="语义计算顺序"><a href="#语义计算顺序" class="headerlink" title="语义计算顺序"></a>语义计算顺序</h3><ul>
<li>属性依赖<ul>
<li>对应于每个产生式$A \rightarrow \alpha$都有一套与之相关联的语义规则，每条规则的形式位$b :&#x3D; f(c_1, …, c_K)$</li>
<li>属性b依赖于属性$c_1, …, c_k$<ul>
<li>b是A的一个综合属性并且$c_1, …, c_k$是产生式右部文法符号的属性</li>
<li>b是产生式右边某个文法符号的一个继承属性并且$c_1, …, c_k$是A或产生式右边文法符号的属性</li>
</ul>
</li>
<li>过程调用也当属性</li>
</ul>
</li>
<li>语义规则建立了属性之间的依赖关系，再堆语法分析树节点的一个属性求值之前，必须首先计算出这个属性值所依赖的所有属性值</li>
</ul>
<h4 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h4><ul>
<li>依赖图是一个描述了分析树中节点属性间依赖关系的有向图</li>
<li>分析树中每个标号为X的节点的每个属性a都对应着依赖图中的一个节点</li>
<li>如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的节点指向X.a的节点的有向边<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 依赖图的构造算法</span><br><span class="line">for 语法树中每一节点n do</span><br><span class="line">  for 节点n的文法符号的每一个属性a do</span><br><span class="line">    为a再依赖图中建立一个节点；</span><br><span class="line">for 语法树中每一个节点n do</span><br><span class="line">  for 节点n所用产生式对应的每一个语义规则</span><br><span class="line">    b := f(c1, ..., ck) do</span><br><span class="line">      for i:= 1 to k do</span><br><span class="line">        从ci节点到b节点构造一条有向边</span><br></pre></td></tr></table></figure></li>
<li>一个依赖图的任何拓扑排序都给出一个语法树中节点的语义规则计算的有效顺序</li>
<li>仅有综合属性的SDD，可以按照任何自底向上的顺序计算它们的值</li>
<li>同时具有继承属性和综合属性的SDD，不能保证存在一个顺序来对各个节点上的属性进行求值</li>
<li>给定一个SDD，很难判定是否存在一个其属性依赖图不含回路的分析树</li>
<li>实践中，只使用能够保证对每棵语法分析树都存在一个属性求值顺序的SDD，因为它们不允许产生带有环的依赖图</li>
<li>可以在自顶向下或自底向上语法分析的同时实现语义计算</li>
</ul>
<h3 id="S-属性文法与L-属性文法"><a href="#S-属性文法与L-属性文法" class="headerlink" title="S-属性文法与L-属性文法"></a>S-属性文法与L-属性文法</h3><ul>
<li>S-属性文法<ul>
<li>仅含有综合属性的属性文法</li>
<li>S属性文法可以在自底向上的语法分析过程中实现</li>
</ul>
</li>
<li>L-属性文法<ul>
<li>当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性</li>
<li>假设存在一个产生式$A \rightarrow X_1…X_n$，其右部符号$X_i(1&lt;&#x3D;i&lt;&#x3D;n)$的继承属性仅依赖于下列属性<ul>
<li>A的继承属性</li>
<li>产生式中$X_i$左边的符号$X_1,…,X_{i-1}$的属性</li>
<li>$X_i$自身的属性，且$X_i$的全部属性不能再依赖图中形成环路</li>
</ul>
</li>
<li>S-属性文法是L-属性文法的一个特例</li>
</ul>
</li>
</ul>
<h3 id="基于S-属性文法的语义计算"><a href="#基于S-属性文法的语义计算" class="headerlink" title="基于S-属性文法的语义计算"></a>基于S-属性文法的语义计算</h3><ul>
<li>采用LR分析，每当归约时，执行语义计算</li>
<li>e.g.<ul>
<li>抽象语法AST的构造</li>
<li>类型检查</li>
</ul>
</li>
</ul>
<h3 id="基于L-属性文法的语义计算"><a href="#基于L-属性文法的语义计算" class="headerlink" title="基于L-属性文法的语义计算"></a>基于L-属性文法的语义计算</h3><h4 id="树遍历法"><a href="#树遍历法" class="headerlink" title="树遍历法"></a>树遍历法</h4><p>语法分析构建语法树，再深度优先，遍历语法树完成语义计算</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 还有未被计算的属性 <span class="keyword">do</span></span><br><span class="line">  <span class="title function_ invoke__">VisitNode</span>(S) <span class="comment">/*S是开始符号*/</span></span><br><span class="line"></span><br><span class="line">procedure <span class="title function_ invoke__">VisidNode</span>(N: Node);</span><br><span class="line">begin</span><br><span class="line">  <span class="keyword">if</span> N是一个非终结符 then <span class="comment">/*假设其产生式为N-&gt;X1...Xm*/</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">i</span>:=<span class="number">1</span> to m <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> xi <span class="keyword">in</span> Vn then <span class="comment">/*Xi是非终结符*/</span></span><br><span class="line">        begin</span><br><span class="line">          计算Xi的所有能够计算的继承属性</span><br><span class="line">          <span class="title function_ invoke__">VisitNode</span>(Xi)</span><br><span class="line">        end;</span><br><span class="line">  计算N的所有能够计算的综合属性</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="基于翻译模式的语义计算"><a href="#基于翻译模式的语义计算" class="headerlink" title="基于翻译模式的语义计算"></a>基于翻译模式的语义计算</h2><h3 id="翻译模式"><a href="#翻译模式" class="headerlink" title="翻译模式"></a>翻译模式</h3><ul>
<li>把语义规则（也称语义动作），用花括号{}扩起来，插入到产生式右部的合适位置上。进一步细化了语义计算的时机。</li>
<li>S-翻译模式：仅含综合属性，语义动作集只有产生式u右端的末尾。常采用LR的自底向上的分析法，和S属性文法类似</li>
<li>L-翻译模式：包含综合属性，还可以包含继承属性</li>
<li>满足下列条件<ul>
<li>产生式右部符号的继承属性，其语义计算必须位于该符号前，且其语义动作不访问右边符号的属性</li>
<li>产生式左部符号的综合属性只有在它所引用的所有属性都计算出来后才能计算。属性计算通常放在产生式右端的末尾</li>
<li>继承属性只能依赖于兄长的属性、父亲的继承属性、自身的属性</li>
<li>属性间依赖图不能形成环路</li>
</ul>
</li>
</ul>
<h3 id="基于S-翻译模式的语义计算"><a href="#基于S-翻译模式的语义计算" class="headerlink" title="基于S-翻译模式的语义计算"></a>基于S-翻译模式的语义计算</h3><ul>
<li>与S-属性文法类似<ul>
<li>基础文法是LR的：自底向上计算</li>
<li>基础文法是LL的：自顶向下计算</li>
</ul>
</li>
<li>在LR分析的同时计算综合属性</li>
<li>在分析栈中保存语法符号、状态和有关的综合属性值</li>
<li>每当进行归约时，计算属性</li>
<li>在LR分析框架的基础上，在分析栈增加附加域：语义栈（属性栈）</li>
<li>将语义规则（动作）改写称具体可执行的栈操作</li>
</ul>
<h3 id="基于L-翻译模式的自顶向下计算"><a href="#基于L-翻译模式的自顶向下计算" class="headerlink" title="基于L-翻译模式的自顶向下计算"></a>基于L-翻译模式的自顶向下计算</h3><ul>
<li>递归下降翻译器（语义计算分析）程序<ul>
<li>分析成语由一组递归子程序（函数）组成，每个非终结符对应一个子程序</li>
<li>如果非终结符有多个产生式，根据当前符号和SELECT集决定用哪个产生式</li>
<li>从左到右分析符号串，遇到终结符就匹配，遇到非终结符就调用相应的分析子程序</li>
<li>要求基础文法是LL(1)的</li>
</ul>
</li>
<li>递归版<ul>
<li>检查基础文法是否是LL(1)文法</li>
<li>构造LL(1)分析子程序</li>
<li>对LL(1)递归下降分析器进行改造<ul>
<li>非终结符A的递归子程序 -&gt; 函数 <code>A.v = parseA(A.i)</code></li>
<li>A的每个继承属性对应该函数的一个形参，函数的返回值是A的综合属性值</li>
<li>对出现在A产生式右部中的每个文法符号的每个属性都设置一个局部变量</li>
<li>对应每个语义动作，将其代码赋值到语法分析器，并把对属性的引用改为对相应变量的引用</li>
</ul>
</li>
</ul>
</li>
<li>非递归的自顶向下计算<ul>
<li>在LL(1)分析法基础上，增加属性列表栈</li>
<li>从文法其实符号最左推导，根据下一符号和SELECT集选择产生式</li>
<li>产生式右部和语义动作逆序进展</li>
<li>综合属性计算得出结果后退栈</li>
</ul>
</li>
</ul>
<h3 id="基于L-翻译模式的自底向上计算"><a href="#基于L-翻译模式的自底向上计算" class="headerlink" title="基于L-翻译模式的自底向上计算"></a>基于L-翻译模式的自底向上计算</h3><ul>
<li>从翻译模式中删除嵌入在产生式中间的语义动作<ul>
<li>把嵌入在产生式中的每个语义动作用不同的非终结符（如M，N，…代替）</li>
<li>加入新的产生式$M \rightarrow \epsilon, …$</li>
<li>在把原来的语义动作放在产生式$M \rightarrow \epsilon,…$的末尾</li>
<li>这样就不再有继承属性，相当于S-属性文法，可在自底向上的语法分析过程中完成语义计算</li>
</ul>
</li>
<li>继承属性的求值结果以综合属性值存放在语义栈中，对继承属性的访问变成对语义栈中某个综合属性的访问</li>
<li>模拟继承属性的计算</li>
<li>适用于所有的LL(1)文法和大部分LR文法</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>改造翻译模式（使继承属性仅包含复写规则）</li>
<li>将语义规则转换为栈操作</li>
<li>根据基础文法，构造LR自动机</li>
<li>根据LR自动机，构造LR分析表</li>
<li>根据LR分析表，以及栈操作指令，分析<ul>
<li><strong>S操作的时候不做任何动作</strong></li>
<li><strong>归约操作的时候，首先执行语义动作，然后再做弹栈操作</strong></li>
</ul>
</li>
</ul>
<h3 id="分析和翻译的自动生成工具-bison"><a href="#分析和翻译的自动生成工具-bison" class="headerlink" title="分析和翻译的自动生成工具-bison"></a>分析和翻译的自动生成工具-bison</h3><h1 id="静态语义分析和中间代码生成"><a href="#静态语义分析和中间代码生成" class="headerlink" title="静态语义分析和中间代码生成"></a>静态语义分析和中间代码生成</h1><ul>
<li>语义分析的任务<ul>
<li>语法上正确的程序，语义不一定正确</li>
<li>有些错误只能在运行时才能发现，称为动态语义错误</li>
<li>编译阶段只能对结构上正确的源程序进行静态语义检查<ul>
<li>类型检查</li>
<li>唯一性检查</li>
<li>控制流检查</li>
<li>名字的上下文相关性检查</li>
</ul>
</li>
<li>静态语义是上下文有关的</li>
<li>收集源程序中的符号信息，建立符号表</li>
</ul>
</li>
</ul>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><ul>
<li>符号表的作用<ul>
<li>用来存放有关标识符（符号）的属性（语义）信息</li>
<li>在编译的不同阶段都会用到</li>
<li>作为目标代码生成阶段地址分配的依据</li>
<li>用来体现作用域与可见性信息</li>
<li>静态语义检查（名字检查&#x2F;类型&#x2F;控制流&#x2F;唯一性）的依据</li>
</ul>
</li>
<li>符号的常见属性<ul>
<li>符号名</li>
<li>类别：常量、变量、过程&#x2F;函数、类的名称</li>
<li>类型（种别）: int, float, void, 过程&#x2F;函数的返回类型等，决定存储格式和操作</li>
<li>存储类别和存储分配信息，静态&#x2F;动态，堆区&#x2F;栈区，存储单元的代销，偏移量</li>
<li>符号的作用域信息</li>
<li>其它属性<ul>
<li>数组内情向量</li>
<li>记录结构的成员信息</li>
<li>函数及过程的形参</li>
</ul>
</li>
</ul>
</li>
<li>符号表的操作<ul>
<li>创建符号表：进入一个作用域</li>
<li>查询表项（名字&#x2F;信息）：引用标识符<ul>
<li>引用性出现 <code>if (index &lt; 100)</code></li>
</ul>
</li>
<li>插入表项：遇到新的标识符声明时<ul>
<li>定义行出现 <code>int index;</code></li>
</ul>
</li>
<li>修改表项：获得新的语义值信息时</li>
<li>删除表项：不可见或不再需要</li>
<li>释放符号表空间：结束前或退出一个作用域</li>
</ul>
</li>
<li>符号表的数据结构<ul>
<li>一般的线性表<ul>
<li>数组，链表等</li>
<li>有序表（红黑树等）</li>
<li>二叉搜索树</li>
<li>哈希表</li>
</ul>
</li>
</ul>
</li>
<li>作用域与可见性<ul>
<li>嵌套的作用域(nested scopes)</li>
<li>开作用域与闭作用域（相应于程序中特殊点）<ul>
<li>该点所在的作用域为当前作用域</li>
<li>当前作用域与包含它的程序单元所构成的作用域称为开作用域(open scopes)，及嵌套重叠的作用域</li>
<li>不属于开作用域的作用域称为闭作用域(close scopes)</li>
</ul>
</li>
<li>常用的可见性规则(visibility rules)<ul>
<li>在程序的任何一点，只有在该点的开作用域中声明的名字才是可访问的</li>
<li>若一个名字在多个开作用域中被声明，则引用该名字最近的声明作为该引用的解释</li>
<li>新的声明只能出现在当前作用域</li>
</ul>
</li>
</ul>
</li>
<li>作用域与符号表组织<ul>
<li>单符号表：所有作用域共用一个全局符号表<ul>
<li>所有嵌套的作用域公用一个全局符号表</li>
<li>每个作用域有一个作用域号</li>
<li>仅记录开作用域中的符号</li>
<li>当某个作用域称为闭作用域时，从符号表中删除该作用域中所声明的名字</li>
</ul>
</li>
<li>多符号表：每个作用域都有各自的符号表<ul>
<li>每个作用域都有各自的符号表</li>
<li>维护一个符号表的作用域栈，每个开作用域对应栈中的一个入口，当前的开作用域出现在该栈的栈顶</li>
<li>当一个新的作用域开放时，新符号表将被创建，并将其入栈</li>
<li>在当前作用域称为闭作用域时，从栈顶弹出相应的符号表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="静态语义分析"><a href="#静态语义分析" class="headerlink" title="静态语义分析"></a>静态语义分析</h2><ul>
<li>静态语义：刻画程序在静态一致性或完整性方面的特征；仅当程序通过了静态语义检查，才能完成后续的中间代码生成和目标代码优化</li>
<li>动态语义：刻画程序执行时的行为。比如除数为0，数组越界等错误，需要生成相应代码</li>
<li>静态语义分析的主要任务<ul>
<li>类型检查(type check): 检查每个操作是否遵守语言类型系统的定义</li>
<li>名字的作用域(scope)分析: 建立名字的定义和使用之间的联系</li>
<li>控制流检查(control flow check): 控制流语句必须使控制转移到合法的地方</li>
<li>唯一性检查(uniqueness check): 很多场合要求对象只能被定义一次</li>
<li>名字的上下文相关性检查(name-related check)</li>
</ul>
</li>
<li>方法与技术: 基于语法制导的翻译模式<ul>
<li>语法制导——简单的类型检查系统(cheker)<ul>
<li>实现类型系统</li>
<li>程序的结构是否匹配上下文所期望的类型</li>
<li>为IR生成收集&#x2F;建立必要的类型信息</li>
</ul>
</li>
</ul>
</li>
<li>类型表达式<ul>
<li>基本类型是类型表达式</li>
<li>将类型构造夫(type constructor)作用于类型表达式可以构建新的类型表达式<ul>
<li>数组构造<code>array(I, T)</code><ul>
<li>若T是类型表达式，I是整数域，则<code>array(I, T)</code>也是类型表达式</li>
</ul>
</li>
<li>指针构造符<code>pointer(T)</code><ul>
<li>若T是类型表达式，则<code>pointer(T)</code>是类型表达式，它表示指向类型为T的对象的指针</li>
</ul>
</li>
<li>积类型构造符<code>T1 * T2 = &lt;T1, T2&gt;, &lt;T1, ..., Tn&gt;</code><ul>
<li>若T1,T2是类型表达式，则<code>T1 * T2 = &lt;T1, T2&gt;</code>为类型表达式</li>
<li><code>&lt;T1, ..., Tn&gt;, n&gt; = 0;</code>积类型表达式</li>
<li><code>&lt;&gt;, n=0</code></li>
</ul>
</li>
<li>过程类型构造符<code>fun(T)</code><ul>
<li><code>foo(int a; float b)</code>，则<code>fun(T), T=&lt;int, float&gt;</code></li>
<li>函数类型表达式，LLVM: <code>i32(i32); &#123;i32, i32&#125; (i32)</code></li>
</ul>
</li>
<li>定义新的类型构造符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><ul>
<li>IR: 源程序的不同表示形式，也称为中间表示<ul>
<li>源程序和目标语言之间的桥梁（前端和后端），避开二者之间较大的语义跨度，使编译程序的逻辑结构更加简单明确。</li>
<li>有利于进行于目标机器无关的优化</li>
<li>有利于编译程序的重定向（移植）</li>
</ul>
</li>
<li>常见的中间表示的形式<ul>
<li>TAC(Tree-Address code, 三地址码，四元式)</li>
<li>AST(Abstract Syntax Tree, 抽象语法树), DAG(有向无环图)</li>
<li>SSA(Static Single Assignment forn, 静态单赋值形式)</li>
<li>LLVM IR</li>
<li>P-code(特别用于Pasal语言实现)</li>
<li>Bytecode(java编译器的输出，java虚拟机的输入)</li>
</ul>
</li>
<li>LLVM IR<ul>
<li>LLVM IR是一种低级语言</li>
<li>提供关于程序的高级信息，支持复杂分析与变换</li>
<li>低级low level: 足以表示任意程序，允许被广泛优化</li>
<li>RISC风格的三地址码</li>
<li>SSA形式+无限的虚拟寄存器</li>
<li>简单、低级的控制流结构: 指令: branch, return, unwind, invoke</li>
<li>load&#x2F;store指令带类型化指针</li>
</ul>
</li>
<li>三地址码<ul>
<li>比较接近汇编语言的表示</li>
<li>AST&#x2F;DAG的线性表达，更低级别上</li>
<li>TAC与四元式</li>
<li>TAC与SSA</li>
<li>TAC与LLVM IR</li>
</ul>
</li>
<li>常用的三地址码<ul>
<li>赋值语句<code>x := y op z</code> (op代表二元算数&#x2F;逻辑运算) (op, y, z, x)</li>
<li>赋值语句 <code>x := op y</code> (op代表一元运算) (op, y, -, x)</li>
<li>复写语句 <code>x := y</code> (y的值赋值给x) (&#x3D;, y, -, x)</li>
<li>标号语句L: (定义标号L)</li>
<li>无条件跳转语句 <code>goto L</code> (无条件跳转至标号L) (jmp, -, -, L)</li>
<li>条件转移指令 <code>if x goto L</code> (条件为true时跳转值标号L) (jnz, x, -, L)</li>
<li>条件跳转语句 <code>if x rop y goto L</code> (rop代表关系运算) (jrop, x, y, L) e.g. je&#x2F;jne&#x2F;jg&#x2F;jge&#x2F;jl&#x2F;jle</li>
<li>过程调用语句序列: <code>p(x1, ..., xn)</code>, <code>param x1</code>, …, <code>param xn</code>, <code>call p, n</code></li>
<li>过程返回语句 <code>return [y]</code> (y可选，存放返回值) (return, y, -, -)</li>
<li>下标赋值语句 <code>x := y[i]</code>和<code>x[i] := y</code> (&#x3D;[], y, i, x)和([]&#x3D;, i, y, x)</li>
<li>指针赋值语句 <code>x := &amp;y, x := *y, *x := y</code> (&#x3D;&amp;, y, -, x), (&#x3D;<em>, y, -, x), (</em>&#x3D;, y, -, x)</li>
</ul>
</li>
</ul>
<h3 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h3><p>$$ S \rightarrow id :&#x3D; A $$</p>
<ul>
<li>语义属性<ul>
<li><code>id.place</code>: id对应的存储为止</li>
<li><code>A.place</code>: 用来存放的A的值的存储单元的地址</li>
<li><code>A.code</code>: 对A求值的TAC语句序列</li>
<li><code>S.code</code>: S的TAC语句序列</li>
</ul>
</li>
<li>语义函数&#x2F;过程<ul>
<li><code>gen()</code>: 生成一条TAC语句</li>
<li><code>newtemp()</code>: 在符号表中新建一个从未使用过的名字，并返回地址</li>
<li><code>||</code>: TAC语句的连接运算</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; id := A &#123; S.code := A.code || gen(id.place &#x27;:=&#x27; A.place) &#125;</span><br><span class="line">A -&gt; id &#123; A.place := id.place; A.code := &quot;&quot; &#125;</span><br><span class="line">A -&gt; int &#123; A.place := newtemp; A.code := gen(A.place &#x27;:=&#x27; int.val) &#125;</span><br><span class="line">A -&gt; real &#123; A.place := newtemp; A.cpde := gen(A.place &#x27;:=&#x27; real.val) &#125;</span><br><span class="line">A -&gt; A1 + A2 &#123; A.place := newtemp; A.code := A1.code || A2.code || gen(A.place &#x27;:=&#x27; A1.place &#x27;+&#x27; A2.place) &#125;</span><br><span class="line">A -&gt; A1 * A2 &#123; A.place = newtemp; A.code := A1.code || A2.code || gen(A.place &#x27;:=&#x27; A1.place &#x27;*&#x27; A2.place) &#125;</span><br><span class="line">A -&gt; -A1 &#123; A.place := newtemp; A.code = A1.code || gen(A.place &#x27;:=&#x27; &#x27;uminus&#x27; A1.place) &#125;</span><br><span class="line">A -&gt; (A1) &#123; A.place := A.place; A.code =:= A1.code &#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明语句的翻译-L-翻译模式"><a href="#说明语句的翻译-L-翻译模式" class="headerlink" title="说明语句的翻译: L-翻译模式"></a>说明语句的翻译: L-翻译模式</h3><ul>
<li>语义属性<ul>
<li><code>id.name</code>: id的词法名字（符号表中的名字）</li>
<li><code>T.type</code>: 类型属性</li>
<li><code>T.width</code>,<code>V.width</code>: 数据宽度（字节数）</li>
<li><code>V.offset</code>,<code>L.offset</code>: 列表中第一个变量的偏移地址</li>
<li><code>L.type</code>: 变量列表呗申明的类型</li>
<li><code>L.width</code>: 变量列表呗申明类型所栈的字节数</li>
<li><code>L.num</code>: 变量列表中变量的个数</li>
</ul>
</li>
<li>语义函数&#x2F;过程<ul>
<li><code>enter(id.name, t, o)</code>: id.name 表项的type域置为t，offset域置为o</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V -&gt; T &#123; L.type := T.type; L.offset := V.offset; L.width := T.width; &#125; L; &#123;V1.offset := V.offset + L.num * T.width; &#125; V1 &#123; V.type := make_product_3(T.type, L.num, V1.type); V.width := V1.width + L.num * T.width &#125;</span><br><span class="line">V -&gt; \epsilon &#123; V.type := &lt;&gt;; V.width := 0 &#125;</span><br><span class="line">T -&gt; boolean &#123; T.type := bool; T.width := 1 &#125;</span><br><span class="line">T -&gt; int &#123; T.type := int; T.width := 4 &#125;</span><br><span class="line">T -&gt; real &#123; T.type := real; T.width := 8 &#125;</span><br><span class="line">T -&gt; array[num] of T1 &#123; T.type := array(num.lexval, T1.type); T.width := num.val * T1.width &#125;</span><br><span class="line">T -&gt; ^ T1 &#123; T.type := pointer(T1.type); T.width := 4 &#125;</span><br><span class="line">L -&gt; &#123; L1.type := L.type; L1.offset := L.offset; L1.width := L.width; &#125; L1, id &#123; enter(id.name, L.type, L.offset + L1.num * L.width); L.num := L1.num + 1 &#125;</span><br><span class="line">L -&gt; id &#123; enter(id.name, L.type, L.offset); L.num := 1 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>设A为n维数组，按行存放，每个元素宽度为w<ul>
<li>$I_i$为第i维的下界</li>
<li>$u_i$为第i维的上界</li>
<li>$n_i$为第i维可取值的个数$n_i &#x3D; u_i - I_i + 1$</li>
<li>base为A的第一个元素的相对地址</li>
</ul>
</li>
<li>元素<code>A[i1,...,in]</code>相对地址公式$base + ((((i_1 \times n_2 + i_2) \times n_3 + i_3) … ) \times n_n + i_n) * w - ((((I_1 \times n_2 + I_2) \times n_3 + I_3)…+I_{n-1}) \times n_n + I_n) \times w$</li>
<li><code>.arr</code>: 数组名</li>
<li><code>.type</code>: 类型</li>
<li><code>.addr</code>: 元素的偏移地址</li>
<li><code>.code</code>: TAC代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; id := A &#123;S.code := A.code || gen(id.place &#x27;:=&#x27; A.place) &#125; </span><br><span class="line">    | L := A &#123; S.code := A.code || gen(L.arr &#x27;[&#x27; addr &#x27;]&#x27; &#x27;:=&#x27; A.place) &#125;</span><br><span class="line">A -&gt; L &#123; A.place := newtemp; A.code := L.code || gen(A.place &#x27;:=&#x27; L.arr &#x27;[&#x27; L.addr &#x27;]&#x27;) &#125;</span><br><span class="line">L -&gt; id[A] &#123; L.arr := id.name; L.type :=get_type(id).elem; L.addr := newtemp; L.code := A.code || gen(L.addr &#x27;:=&#x27; A.place &#x27;*&#x27; L.type.width) &#125;</span><br><span class="line">    | L1[A] &#123; L.arr := L1.arr; L.type := L1.type.elem; t := newtemp; L.addr := newtemp; L.code := L1.code || A.code || gen(t &#x27;:=&#x27; A.place &#x27;*&#x27; L.type.width) || gen(L.addr &#x27;:=&#x27; L1.addr &#x27;+&#x27; t) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><ul>
<li>用途<ul>
<li>用于逻辑盐酸，计算逻辑值</li>
<li>if&#x2F;while&#x2F;for语句的控制条件</li>
</ul>
</li>
<li>计算<ul>
<li>根据真值表直接计算；短路法</li>
</ul>
</li>
<li>带优化的翻译法（短路，避免不必要的求值）<ul>
<li>把<code>E1 or E2</code>解释成<code>if E1 then true else E2</code></li>
<li>把<code>E1 and E2</code>解释成<code>if E1 then E2 else false</code></li>
<li>把<code>note E</code>解释成<code>if E then false else true</code></li>
<li>被很多高级语言采用，用于条件表达式中布尔表达式的计算</li>
</ul>
</li>
<li>属性与语义计算的涉及<ul>
<li><code>E.code</code>, <code>E.place</code></li>
<li><code>newtemp</code>, <code>gen()</code></li>
</ul>
</li>
<li>语义函数<code>newlabel</code>，返回一个新的符号标号</li>
<li>对布尔表达式E，设置两个继承属性<ul>
<li><code>E.true</code>是E为‘真’时控制流转向的标号</li>
<li><code>E.false</code>是E为‘假’时控制流转向的标号</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E -&gt; &#123; E1.true := E.true; E1.false := newlabel &#125; E1 or &#123; E2.true := E.true; E2.false := E.false &#125; E2 &#123; E.code := E1.code || gen(E1.false &#x27;:&#x27;) || E2.code &#125;</span><br><span class="line">E -&gt; &#123; E1.treue := newlabel; E1.false := E.false &#125; E1 and &#123; E2.true := E.true; E2.false := E.false &#125; E2 &#123; E.code := E1.code || gen(E1.true &#x27;:&#x27;) || E2.code &#125;</span><br><span class="line">E -&gt; not &#123; E1.true := E.false; E1.false := E.true &#125; E1 &#123; E.code := E1.code &#125;</span><br><span class="line">E -&gt; (&#123; E1.true := E.true; E1.false := E.false &#125; E1) &#123; E.code := E1.code &#125;</span><br><span class="line">E -&gt; id1 rop id2 &#123; E.code := gen (&#x27;if&#x27; id1.place rop.op id2.place &#x27;goto&#x27; E.true) || gen(&#x27;goto&#x27; E.false) &#125;</span><br><span class="line">E -&gt; true &#123; E.code := gen(&#x27;goto&#x27; E.true) &#125;</span><br><span class="line">E -&gt; false &#123; E.code := gen(&#x27;goto&#x27; E.false) &#125;</span><br></pre></td></tr></table></figure>
<p><strong>and的时候修改E1.true,or的时候修改E1.false</strong></p>
<h3 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><ul>
<li>继承属性: <code>S.next</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; if &#123; E.true := newlabel; E.false := S.next &#125; E then &#123; S1.next := S.next &#125; S1 &#123; S.code := E.code || gen(E.true &#x27;:&#x27;) || S1.code &#125;</span><br><span class="line">S -&gt; if &#123; E.true := newlabel; E.false := newlabel&#125; E then &#123; S1.next := E.next &#125; S1 else &#123; S2.next := S.next &#125; S2 &#123; S.code := E.code || gen(E.true &#x27;:&#x27;) || S1.code || gen(&#x27;goto&#x27; S.next) || gen(E.flase &#x27;:&#x27;) || S2.code&#125;</span><br><span class="line">S -&gt; while &#123; E.true := newlabel; E.false := S.next &#125; E do &#123; S1.next := newlabel &#125; S1 &#123; S.code := tgen(S1.next &#x27;:&#x27;) || E.code || gen(E.true &#x27;:&#x27;) || S1.code || gen(&#x27;goto&#x27; S1.next) &#125;</span><br><span class="line">S -&gt; &#123; S1.next := newlabel &#125; S1; &#123; S2.next := S.next &#125; S2 &#123; S.code := S1.code || gen(S1.next) &#x27;:&#x27; || S2.code &#125;</span><br><span class="line">P -&gt; D; &#123; S.next := newlabel &#125; S &#123; gen(S.next &#x27;:&#x27;) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="含有break语句的翻译模式"><a href="#含有break语句的翻译模式" class="headerlink" title="含有break语句的翻译模式"></a>含有break语句的翻译模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P -&gt; D; &#123; S.next := newlabel; S.break := newlabel &#125; S &#123; gen(S.next &#x27;:&#x27;) &#125;</span><br><span class="line">S -&gt; if &#123; E.true := newlabel; E.false := S.next &#125; E then &#123; S1.next := S.next; S1.break := S.break &#125; S1 &#123; S.code := e.code || gen(E.true &#x27;:&#x27;) || S1.code &#125;</span><br><span class="line">S -&gt; if &#123; E.true := newlabel; E.false := newlabel &#125; E then &#123; S1.next := S.next; S1.break := S.break &#125; S1 else &#123; S2.next := S.next; S2.break := s.break &#125; S2 &#123; S.code := e.code || gen(E.true &#x27;:&#x27;) || S1.code || gen(&#x27;goto&#x27; S.next)  gen(E.false &#x27;:&#x27;) || S2.code &#125;</span><br><span class="line">S -&gt; while &#123; E.true := newlabel; E.false := S.next &#125; E do &#123; S1.next := newlabel; S1.break := S.next &#125; S1 &#123; S.code := gen(S1.next &#x27;:&#x27;) || E.code || gen(E.true &#x27;:&#x27;) || S1.code || gen(&#x27;goto&#x27; S1.next) &#125;</span><br><span class="line">S -&gt; &#123; S1.next := newlabel; S1.break := S.break &#125; S1; &#123; S2.next := S.next; S2.break := S.break &#125; S2 &#123; S.code := S1.code || gen(S1.next &#x27;:&#x27;) || S2.code &#125;</span><br><span class="line">S -&gt; break; &#123; S.code := gen(&#x27;goto&#x27; S.break) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="拉链与代码回填"><a href="#拉链与代码回填" class="headerlink" title="拉链与代码回填"></a>拉链与代码回填</h3><p>生成一个跳转指令时，暂时不指定改跳转指令的目标标号。这样的指令都被放入由跳转指令组成的列表中。同一个列表中的所有跳转指令具有相同的目标标号。等到能够确定正确的目标标号时，才去填充这些指令的目标标号</p>
<ul>
<li>属性设计</li>
<li><code>E.truelist</code>: “真链”，链表中的元素表示一系列跳转语句的地址，这些跳转语句的目标标号是体现布尔表达式E为“真”的标号</li>
<li><code>E.falselist</code>: “假链”，链表中的元素表示一系列跳转语句的地址，这些跳转语句的目标标号是体现布尔表达式E为假的标号</li>
<li><code>S.nextlist</code>: “next链”，链表中的元素表示一系列跳转语句的地址，这些跳转语句的目标是S之后的下条TAC语句的标号</li>
<li><code>S.breaklist</code>: “break链”， 跳出直接包围S的while语句的下条TAC语句标号</li>
<li><code>M.gotostm</code>: 处理到M时下一条待生成语句的标号</li>
<li>语义计算<ul>
<li><code>makelist(i)</code>: 创建一个只有节点i的列表，i是一条目标TAC语句的标号</li>
<li><code>merge(p1, p2)</code>: 连接两个链表p1和p2，将p2链接到p1后面，返回合并后的链首</li>
<li><code>backpatch(p, i)</code>: 将链表p中每个元素所指向的跳转语句的标号置为i</li>
<li><code>nextstm</code>: 下一条TAC语句的地址</li>
<li><code>emit(...)</code>: 输出一条TAC语句，并使<code>nextstm</code>加1</li>
</ul>
</li>
</ul>
<h4 id="采用拉链与回填技术的布尔表达式的翻译"><a href="#采用拉链与回填技术的布尔表达式的翻译" class="headerlink" title="采用拉链与回填技术的布尔表达式的翻译"></a>采用拉链与回填技术的布尔表达式的翻译</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E -&gt; E1 or M E2 &#123; backpatch(E1.falselist, M.gotostm); E.truelist := merge(E1.truelist, E2.truelist); E.falselist := E2.falselist &#125;</span><br><span class="line">E -&gt; E1 and M E2 &#123; backpatch(E1.truelist, M.gotostm); E.falselist := merge(E1.falselist, E2.falselist); E.truelist := E2.truelist &#125;</span><br><span class="line">E -&gt; not E1 &#123; E.truelist := E1.falselist; E.falselist := E1.truelist &#125;</span><br><span class="line">M -&gt; \epsilon &#123; M.gotostm := nextstm &#125;</span><br><span class="line">E -&gt; (E1) &#123; E.truelist := E1.truelist; E.falselist := E1.falselist &#125;</span><br><span class="line">E -&gt; id1 rop id2 &#123; E.truelist := makelist(nextstm); E.falselist := makelist(nextstm+1); emit(&#x27;if&#x27; id1.place rop.op id2.place &#x27;goto&#x27;); emit(&#x27;goto&#x27;) &#125;</span><br><span class="line">E -&gt; true &#123; E.truelist := makelist(nextstm); emit(&#x27;goto&#x27;) &#125;</span><br><span class="line">E -&gt; false &#123; E.falselist := makelist(nextstm); emit(&#x27;goto&#x27;) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="分支语句的翻译"><a href="#分支语句的翻译" class="headerlink" title="分支语句的翻译"></a>分支语句的翻译</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; if E then M S1 &#123; backpatch(E.truelist, M.gotostm); S.nextlist := merge(E.falselist, S1.nextlist) &#125;</span><br><span class="line">S -&gt; if E then M1 S1 N else M2 S2 &#123; backpatch(E.truelist, M1.gotostm); backpatch(E.falselist, M2.gotostm); S.nextlist := merge(S1.nextlist, merge(n.nextlist, S2.nextlist)) &#125;</span><br><span class="line">M -&gt; \epsilon &#123; M.gotostm := nextstm &#125;</span><br><span class="line">N -&gt; \epsilon &#123; N.nextlist := makelist(nextstm); emit(&#x27;goto&#x27;) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环、符合语句的翻译"><a href="#循环、符合语句的翻译" class="headerlink" title="循环、符合语句的翻译"></a>循环、符合语句的翻译</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; while M1 E do M2 S1 &#123; backpatch(S1.nextlist, M1.gotostm); backpatch(E.truelist, M2.gotostm); S.nextlist := E.falselist; emit(&#x27;goto&#x27;, M1.gotostm) &#125;</span><br><span class="line">S -&gt; S1; M S2 &#123; backpatch(S1.nextlist, M.gotostm); S.nextlist := S2.nextlist &#125;</span><br><span class="line">M -&gt; \epsilon &#123; M.gotostm := nextstm &#125;</span><br></pre></td></tr></table></figure>

<h4 id="赋值、算数表达式的翻译"><a href="#赋值、算数表达式的翻译" class="headerlink" title="赋值、算数表达式的翻译"></a>赋值、算数表达式的翻译</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; id := A &#123; emit(id.place &#x27;:=&#x27; A.place); S.nextlist := &#x27;&#x27; &#125;</span><br><span class="line">A -&gt; id &#123; A.place := id.place &#125;</span><br><span class="line">A -&gt; int &#123; A.place := newtemp; emit(A.place &#x27;:=&#x27; int.val) &#125;</span><br><span class="line">A -&gt; real &#123; A.place := newtemp; emit(A.place &#x27;:=&#x27; real.val) &#125;</span><br><span class="line">A -&gt; A1 + A2 &#123; A.place := newtemp; emit(A.place &#x27;:=&#x27; A1.place &#x27;+&#x27; A2.place) &#125;</span><br><span class="line">A -&gt; A1 * A2 &#123; A.place := newtemp; emit(A.place &#x27;:=&#x27; A1.place &#x27;*&#x27; A2.place) &#125;</span><br><span class="line">A -&gt; -A1 &#123; A.place := newtemp; emit(A.place &#x27;:= uminus&#x27; A1.place) &#125;</span><br><span class="line">A -&gt; (A1) &#123; A.place := A1.place &#125;</span><br></pre></td></tr></table></figure>

<h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P -&gt; D; S M &#123;backpatch(S.nextlist, M.gotostm); backpatch(S.breaklist, M.gotostm) &#125;</span><br><span class="line">S -&gt; if E then M S1 &#123; backpatch(E.truelist, M.gotostm); S.nextlist := merge(E.falselist, S1.nextlist); S.breaklist := S1.breaklist &#125;</span><br><span class="line">S -&gt; if E then M1 S1 N else M2 S2 &#123; backpatch(E.truelist, M1.gotostm); backpatch(E.falselist, M2.gotostm); S.nextlist := merge(S1.nextlist, merge(N.nextlist, S2.nextlist)); S.breaklist := merge(S1.breaklist, S2.breaklist) &#125;</span><br><span class="line">S -&gt; while M1 E then M2 S1 &#123; backpatch(S1.nextlist, M1.gotostm); backpatch(E.truelist, M2.gotostm); S.nextlist := merge(E.falselist, S1.breaklist); S.breaklist := &#x27;&#x27;; emit(&#x27;goto&#x27;, M1.gotostm) &#125;</span><br><span class="line">S -&gt; S1; M S2 &#123; backpatch(S1.nextlist, M.gotostm); S.nextlist := S2.nextlist; S.breaklist := merge(S1.breaklist, S2.breaklist) &#125;</span><br><span class="line">S -&gt; break; &#123; S.breaklist := makelist(nextstm); S.nextlist := &#x27;&#x27;; emit(&#x27;goto&#x27;); &#125;</span><br><span class="line">M -&gt; \epsilon &#123; M.gotostm := nextstm &#125;</span><br><span class="line">N -&gt; \epsilon &#123; N.nextlist := makelist(nextstm); emit(&#x27;goto&#x27;) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><ul>
<li>简单过程调用的翻译<ul>
<li><code>call p (a+b, a*b)</code></li>
<li>计算<code>a+b</code>置于t中的代码 <code>t := a + b</code></li>
<li>计算<code>a*b</code>置于z中的代码 <code>z := a * b</code></li>
<li><code>param t</code>  &#x2F;&#x2F; 第一个实参地址</li>
<li><code>param z</code>  &#x2F;&#x2F; 第二个实参地址</li>
<li><code>call p, 2</code></li>
</ul>
</li>
<li>属性<ul>
<li><code>A.n</code>: 参数个数</li>
<li><code>A.arglist</code>: 实参地址的列表</li>
</ul>
</li>
<li>函数<ul>
<li><code>makelist</code>: 创建实参地址节点</li>
<li><code>append</code>: 在实参表中添加节点</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; call id ( A ) &#123; S.code := A.code; </span><br><span class="line">                    for A.arglist中的每一项p do </span><br><span class="line">                      S.code := S.code || gen(&#x27;param&#x27; p);</span><br><span class="line">                    S.code := S.code || gen(&#x27;call&#x27; id.place, A.n) &#125;</span><br><span class="line">A -&gt; A1, E &#123; A.n := A1.n + 1; A.arglist := append(A1.arglist, makelist(E.place)); A.code := A1.code || E.code &#125;</span><br><span class="line">A -&gt; \epsilon &#123; A.n := 0; A.arglist := &#x27;&#x27;; A.code := &#x27;&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行时存储组织"><a href="#运行时存储组织" class="headerlink" title="运行时存储组织"></a>运行时存储组织</h1><h2 id="运行时存储组织概述"><a href="#运行时存储组织概述" class="headerlink" title="运行时存储组织概述"></a>运行时存储组织概述</h2><ul>
<li>任务：编译程序在生成代码时，负责明确各类对象（代码&#x2F;数据）在逻辑地址空间式如何存放的，以及目标代码运行时，如何使用逻辑地址空间</li>
<li>问题<ul>
<li>数据对象的表示。明确各种数据对象在目标机的表现形式</li>
<li>表达式计算。明确如何正确有效的组织表达式的计算过程</li>
<li>存储分配策略。如何存储不同作用域、不同生命周期的数据对象</li>
<li>过程实现。如何实现过程&#x2F;函数调用及参数传递</li>
</ul>
</li>
<li>数据对象的表示<ul>
<li>char, bool: 1 byte, int: 4bytes</li>
<li>float: 4bytes(IEEE 754: 1符号位+7指数位+23尾数位)</li>
<li>数组: 一块连续的存储区(按行&#x2F;列存放)</li>
<li>结构: 所有域(field)存放在一块连续的存储区</li>
<li>对象: 实例对象参照结构，方法和成员函数放在其所属的代码区里</li>
<li>pointer: 1个字长。32位上4bytes,64位上8bytes</li>
<li>大端 VS 小端</li>
<li>对齐align</li>
</ul>
</li>
<li>表达式计算<ul>
<li>在栈区计算<ul>
<li>运算数&#x2F;中间结果存放于当前活动记录(栈区)或通用寄存器中</li>
</ul>
</li>
<li>在运算数栈计算&#x2F;协处理器<ul>
<li>某些目标机采用专门的运算数栈用于表达式计算</li>
</ul>
</li>
<li>使用了递归函数的表达式的计算通常在栈区</li>
</ul>
</li>
<li>存储分配<ul>
<li>静态存储分配<ul>
<li>全局变量和static的变量被分配在静态数据区</li>
</ul>
</li>
<li>堆式存储分配<ul>
<li>递归、可变数组、运行期间自由申请与释放空间</li>
</ul>
</li>
<li>栈式动态存储分配<ul>
<li>调用函数时，在栈顶为函数分配数据区</li>
<li>返回时，从栈顶收回数据区</li>
</ul>
</li>
</ul>
</li>
<li>函数调用与参数传递<ul>
<li>管理运行栈，分配&#x2F;回收Active Record，保存&#x2F;恢复机器状态，信息传递</li>
<li>调用序列，返回序列</li>
<li>caller的责任，callee的责任</li>
</ul>
</li>
</ul>
<h2 id="活动记录（栈帧）"><a href="#活动记录（栈帧）" class="headerlink" title="活动记录（栈帧）"></a>活动记录（栈帧）</h2><p>活动记录：存放函数一次执行所需要的信息的一段连续的存储区</p>
<table>
<thead>
<tr>
<th align="left">sp</th>
<th align="left">临时变量</th>
<th align="left">低地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">动态数据区</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">局部变量</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">保存的机器状态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">访问链</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">控制链</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">返回地址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">fp</td>
<td align="left">实参</td>
<td align="left">高地址</td>
</tr>
</tbody></table>
<ul>
<li>栈式存储分配策略<ul>
<li>当调用子程序时，在数据空间栈顶，给子程序分配所需的子程序过程活动记录</li>
<li>当子程序返回时，从数据空间栈顶，收回分配给子程序所占用过程活动记录</li>
<li>在允许递归调用时，一个子程序可能在数据空间中同时拥有多个过程活动记录</li>
</ul>
</li>
</ul>
<h2 id="函数调用与参数传递"><a href="#函数调用与参数传递" class="headerlink" title="函数调用与参数传递"></a>函数调用与参数传递</h2><ul>
<li>调用序列: 分配AR，填入信息</li>
<li>返回序列: 回收AR，恢复机器状态</li>
<li>参数传递: k&lt;&#x3D;4个参数用寄存器，余下放栈上</li>
<li>返回值: 寄存器</li>
<li>返回地址: call指令压入栈&#x2F;通过寄存器传递更高效</li>
</ul>
<h1 id="代码优化和目标代码生成"><a href="#代码优化和目标代码生成" class="headerlink" title="代码优化和目标代码生成"></a>代码优化和目标代码生成</h1><h2 id="优化技术介绍"><a href="#优化技术介绍" class="headerlink" title="优化技术介绍"></a>优化技术介绍</h2><ul>
<li>所谓代码优化，是指堆中间代码或目标代码进行等价变换，使得变换后的代码运行速度加快和存储空间减少</li>
<li>优化分类</li>
<li>优化的思路</li>
<li>分析方法</li>
<li>优化的顺序与重复</li>
</ul>
<h3 id="优化的分类"><a href="#优化的分类" class="headerlink" title="优化的分类"></a>优化的分类</h3><ul>
<li>是否与机器有关<ul>
<li>机器无关（中间代码优化）<ul>
<li>机器无关的优化与硬件特征无关，比如把常数值在编译期间计算出来（常数折叠）</li>
</ul>
</li>
<li>机器有关（目标代码优化）<ul>
<li>机器相关的优化需要利用硬件特有的特征，比如SIMD指令可以在一条指令里完成多个数据的计算</li>
</ul>
</li>
</ul>
</li>
<li>优化的范围<ul>
<li>窥孔优化（基本块内窗口范围内的优化）</li>
<li>局部优化（基本块内优化）</li>
<li>循环优化（可能涉及多个基本快，但在同一函数内）</li>
<li>全局优化（函数内优化）</li>
<li>过程间优化（跨函数优化）</li>
</ul>
</li>
</ul>
<h3 id="优化的思路"><a href="#优化的思路" class="headerlink" title="优化的思路"></a>优化的思路</h3><ul>
<li>提前计算常量<ul>
<li>常量折叠（合并）</li>
<li>常量传播<ul>
<li>常量传播可能会导致更多的常量折叠（合并）</li>
<li>如果一个被折叠的常量后续不再合并，也可能直接导致该常量的定义语句直接被删除——死代码删除</li>
<li>常量传播可能导致分支判断条件是常量，从而导致分支的代码不需要执行，这种优化叫做稀疏有条件的常数传播(Sparse Conditional Constant Propagation)</li>
</ul>
</li>
</ul>
</li>
<li>用更低的代价完成相同的计算<ul>
<li>代数化简（没有意义的操作删除，如<code>x = x + 0</code>）</li>
<li>强度削弱（乘除法转换成移位操作）</li>
</ul>
</li>
<li>消除重复的计算<ul>
<li>复写传播(Copy Propagation)<ul>
<li><code>x = a + b; y = x; z = 2 * y</code> -&gt; <code>z = 2 * x</code></li>
</ul>
</li>
<li>值编号(Value Numbering)<ul>
<li>相同的值用同一个变量</li>
</ul>
</li>
<li>公共子表达式删除(Common Subexpression Elimination)</li>
<li>部分冗余消除</li>
<li>化零为整，向量计算（如利用SIMD指令）<ul>
<li>循环向量化</li>
<li>聚合体的标量替换</li>
</ul>
</li>
</ul>
</li>
<li>针对循环，重点优化<ul>
<li>循环不变代码外提(Loop Invariant Code Motion)</li>
<li>归纳变量强度削弱<ul>
<li><code>for (int i = 1; i &lt; 100; i++) j = i * 2; // 2*i可以替换称j+2,计算强度削弱</code></li>
</ul>
</li>
<li>归纳变量删除</li>
<li>边界检查消除<ul>
<li>当引用一个数组成员的时候，同工厂要检查下标是否越界。在循环里面，如果每次都要检查的话，代价就会相当高（如左多个数组的向量运算的时候）。如果编译器能够确定，在循环中使用的数组下标（通常是循环变量或者基于循环变量的归纳变量）不会越界，那么就可以消除边界检查的代码，从而大大提高性能。</li>
</ul>
</li>
<li>循环展开</li>
<li>循环向量化</li>
<li>代码提升<ul>
<li>在某点之后总是被计算的表达式，将其移至总能被计算的最晚点</li>
</ul>
</li>
<li>循环重组<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">    a[i][j] = b + a[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a[i][j]的地址在前半部分不需要每次都在循环内计算，可以提到循环外</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>减少过程调用的开销<ul>
<li>内联&#x2F;内联扩展<ul>
<li>内联又被称为过程集成，就是把被调用函数的代码拷贝到调用者中，从而避免函数调用。内联扩展是更低级别的代码替代过程调用的机制</li>
</ul>
</li>
<li>叶例程优化<ul>
<li>叶子历程——不调用其它函数（过程）的函数（过程），可以对栈的使用做一些优化</li>
</ul>
</li>
<li>尾调用优化&#x2F;尾递归删除</li>
</ul>
</li>
<li>对控制流的优化<ul>
<li>不可达代码消除(Unreacheable code elimination)<ul>
<li>通过控制流分析发现不可到达的代码，如return后的代码，可直接消除；if语句中的永久false分支</li>
</ul>
</li>
<li>死代码删除<ul>
<li>通过对数据流的分析，发现某个变量赋值了以后，后面根本没有再用到这个变量。这样的代码就是四变量，就可以删除。对计算解雇哦不起作用的指令</li>
</ul>
</li>
<li>if简化<ul>
<li>删除if的无用分支或整个if结构</li>
</ul>
</li>
<li>循环简化<ul>
<li>化简循环，变成直线代码，从而增加了其它优化的机会，比如指令的流水线化</li>
</ul>
</li>
<li>循环反转</li>
<li>拉直</li>
<li>反分支</li>
</ul>
</li>
</ul>
<h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><ul>
<li>控制流分析(CFA)</li>
<li>数据流分析(DFA)</li>
<li>依赖分析(DA)</li>
<li>别名分析(AA)</li>
</ul>
<h3 id="优化的顺序与重复"><a href="#优化的顺序与重复" class="headerlink" title="优化的顺序与重复"></a>优化的顺序与重复</h3><ul>
<li>重要性<ul>
<li>对所有语言都重要：循环优化</li>
<li>面向对象语言：内联优化</li>
<li>函数式语言：尾递归优化</li>
</ul>
</li>
<li>顺序：<ul>
<li>机器无关：早期</li>
<li>机器有关：后期</li>
<li>一个优化导致另一个优化</li>
<li>同一个优化多遍运行</li>
</ul>
</li>
</ul>
<h2 id="优化块、流图和循环"><a href="#优化块、流图和循环" class="headerlink" title="优化块、流图和循环"></a>优化块、流图和循环</h2><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><ul>
<li>基本块：一个顺序执行的语句序列，只有一个入口语句和一个出口语句。执行时只能从入口语句进入，从出口语句退出</li>
<li>基本块是一个最大的不可分割的、连续的三地址指令序列，这个块中的指令要么全部执行，要么全部不执行</li>
<li>基本块的入口<ul>
<li>程序的第一条语句</li>
<li>（条件&#x2F;无条件）跳转语句的跳转目标语句</li>
<li>条件跳转语句的下一条语句</li>
</ul>
</li>
<li>划分基本块的方法<ul>
<li>确定入口语句</li>
<li>每一个入口语句对应一个基本块。从入口语句向后直到<ul>
<li>转移语句（是基本块的最后一条语句）</li>
<li>停止语句</li>
<li>下一个入口语句（不包括该句）之间的代码段</li>
</ul>
</li>
<li>凡不属于任何一个基本块的语句都是无用语句，将其全部删除</li>
</ul>
</li>
</ul>
<h3 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h3><ul>
<li>流图的节点是一些基本块</li>
<li>从基本块B到基本块C之间有一条边当且仅当基本块C的第一个指令可能紧跟在B的最后一条指令之后执行。  <ul>
<li>此时称B是C的前去，C是B的后继</li>
<li>确认这样的边的方式<ul>
<li>有一个从B的结尾跳转到C的开头的条件或无条件跳转语句</li>
<li>按照原来的三地址语句序列中的顺序，C紧跟在B后，且B的结尾不是无条件跳转语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常用的优化方法"><a href="#常用的优化方法" class="headerlink" title="常用的优化方法"></a>常用的优化方法</h3><ul>
<li>删除公共子表达式</li>
<li>复制传播</li>
<li>常量合并&#x2F;常量传播</li>
<li>删除无用代码</li>
<li>代码移动（外提）</li>
<li>强度削弱</li>
<li>删除归纳变量</li>
</ul>
<h4 id="删除公共子表达式-CSE"><a href="#删除公共子表达式-CSE" class="headerlink" title="删除公共子表达式(CSE)"></a>删除公共子表达式(CSE)</h4><ul>
<li>如果表达式<code>x op y</code>先前已被计算过，并且从先前的计算到现在，<code>x op y</code>中的变量的值没有改变，那么<code>x op y</code>的这次出现就称为公共子表达式</li>
</ul>
<h4 id="删除无用代码"><a href="#删除无用代码" class="headerlink" title="删除无用代码"></a>删除无用代码</h4><ul>
<li>复制传播</li>
<li>常用的公共子表达式消除算法和其它一些优化算法会引入一些复制语句（形如<code>x=y</code>的赋值语句）</li>
<li>复制传播：在复制语句<code>x=y</code>之后尽可能用y代替x</li>
<li>复制传播给删除无用代码带来机会</li>
<li>无用代码（死代码）：计算结果永远不会被使用的语句</li>
</ul>
<h4 id="基本归纳变量与归纳变量"><a href="#基本归纳变量与归纳变量" class="headerlink" title="基本归纳变量与归纳变量"></a>基本归纳变量与归纳变量</h4><ul>
<li>对于一个变量i，如果存在一个正的或负的常数c使得每次x被赋值时它的值总增加c，那么i就称为基本归纳变量<ul>
<li><code>i=i+c</code>(c可为负数、常数、不变量)</li>
<li><code>j=k*i+c</code>(k为不变量，可为负数)</li>
<li>j为归纳变量，并且与i同族</li>
</ul>
</li>
<li>删除归纳变量：基本归纳变量可由同族的某一归纳变量替换它</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>在流程图G中，对于任意一个节点序列$\alpha$，如果在节点序列之外存在一个节点指向节点序列中的节点V，或者节点序列中的节点V是程序首节点，则称节点V为节点序列$\alpha$的入口节点</li>
<li>自然循环是在程序流图中，具有下列性质的节点序列L<ul>
<li>是强连通子图（任意两节点之间必有通路，且通路上的节点都属于L）</li>
<li>有且仅有一个入口节点</li>
</ul>
</li>
<li>在程序流图中，查找循环方法是基于流图中回边的</li>
<li>回边的基础：必经节点（支配节点），毕经节点集（支配节点集）<ul>
<li>在流图中，对任意两个节点m和n，如果从首节点出发到达节点n的任一通路，都要经过节点m，则称节点m是节点n的毕竟节点或支配节点，记为<code>m DOM n</code></li>
<li>流图中节点n的所有必经节点集合，称为节点n的必经节点集，记为D(n)</li>
</ul>
</li>
</ul>
<h5 id="计算所有节点n的必经节点集D-n-的算法"><a href="#计算所有节点n的必经节点集D-n-的算法" class="headerlink" title="计算所有节点n的必经节点集D(n)的算法"></a>计算所有节点n的必经节点集D(n)的算法</h5><ul>
<li>流图G&#x3D;(N, E, n0), P(n)为节点n的所有前驱节点集<ul>
<li>置初值: $D(n_0) \leftarrow {n_0}$，对于$n \in (N - {n_0}), D(n) \leftarrow N$</li>
<li>对于$n \in (N - {n_0})$，做下列计算<ul>
<li>$NEW_D \leftarrow {n} \cup ( \cap D(p) | p \in P(n))$</li>
<li>如果$NEW_D !&#x3D; D(n)$，则$D(n) \leftarrow NEW_D$</li>
<li>重复上一个步骤，直到所有D(n)不再变化为止</li>
</ul>
</li>
<li>d DOM n的充分必要条件是对于任意$p_i \in P(n)$，有$d DOM p_i, 1 &lt;&#x3D; i &lt;&#x3D; k$</li>
</ul>
</li>
</ul>
<h4 id="自然循环：一种适合优化的循环"><a href="#自然循环：一种适合优化的循环" class="headerlink" title="自然循环：一种适合优化的循环"></a>自然循环：一种适合优化的循环</h4><ul>
<li>自然循环是满足以下性质的循环<ul>
<li>有唯一的入口节点，称为首节点。首节点支配循环中的所有节点，否则，它就不会成为循环的唯一入口</li>
<li>循环中至少有一条返回首节点的路径，否则，控制就不可能从“循环”中直接回到循环头，也就无法构成循环</li>
</ul>
</li>
<li>自然循环的识别<ul>
<li>给定一个回边$n \rightarrow d$，该回边的自然循环为:d,以及所有可以不经过d而到达n的节点。d为该循环的首节点</li>
</ul>
</li>
<li>求回边vian$n \rightarrow d$的自然循环(P(n)为节点n的所有前驱节点集)</li>
<li>令流图G的一条回边$n \rightarrow d$，求d入口和n为出口的循环loop<ul>
<li>$loop \leftarrow {d, n}, S \leftarrow {n}$</li>
<li>$S \leftarrow (P(q)|q \in S) - loop$</li>
<li>$loop \leftarrow loop \cup S$</li>
<li>重复(2)(3),直到所有loop不再变化为止</li>
</ul>
</li>
</ul>
<h2 id="数据流分析基础"><a href="#数据流分析基础" class="headerlink" title="数据流分析基础"></a>数据流分析基础</h2><ul>
<li>一组用来收集程序执行路径上的数据流信息的技术</li>
<li>数据流分析应用<ul>
<li>到达-定值分析</li>
<li>活跃变量分析</li>
<li>可用该表达式分析</li>
</ul>
</li>
<li>在每一种数据流分析应用中，都会把每个程序点和一个数据流值关联起来</li>
<li>每条IR语句s将一个input state转换成一个新的output state</li>
<li>input&#x2F;output数据流信息分别于s的前&#x2F;后节点相关联</li>
<li>语句s的转移函数<ul>
<li>正向分析: $OUT[s] &#x3D; f_x (IN[s])$</li>
<li>反向分析: $IN[s] &#x3D; f_s(OUT[s])$</li>
</ul>
</li>
<li>基本块内的数据流<ul>
<li>设基本块B由语句s1, …, sn顺序组成，则必有<ul>
<li>$IN[s_{i+1}] &#x3D; OUT[s_i]$，对于所有的i从0到n-1</li>
</ul>
</li>
<li>且$IN[B] &#x3D; IN[s_1], OUT[B]&#x3D;OUT[s_n]$</li>
<li>$f_B$: 基本块B的转移函数<ul>
<li>正向分析: $OUT[B] &#x3D; f_B(IN[B])$,$f_B &#x3D; f_{sn} \cdot … \cdot f_{s1}$ </li>
<li>反向分析: $IN[B] &#x3D; f_B(OUT[B])$, $f_B &#x3D; f_{s1} \cdot … \cdot f_{sn}$</li>
</ul>
</li>
</ul>
</li>
<li>基本块间的数据流<ul>
<li>正向分析: $IN[B] &#x3D; \cup _{P \in pred(B)} OUT[P]$</li>
<li>反向分析: $OUT[B] &#x3D; \cup _{S \in succ(B)} IN[S]$</li>
</ul>
</li>
</ul>
<h3 id="到达-定值分析"><a href="#到达-定值分析" class="headerlink" title="到达-定值分析"></a>到达-定值分析</h3><ul>
<li>定值：变量v的定值（可能）将一个值赋给v的语句(<code>v=...</code>)</li>
<li>到达定值<ul>
<li>存在一条从定值d到程序点p的路径，且在此路径上d没有被“杀死”，则称定值d到达程序点p</li>
<li>即在此路径上没有其它定值d’对变量v重新定值</li>
</ul>
</li>
<li>转移函数$f_d$<ul>
<li>定值d: <code>u = v + w</code></li>
<li>它“产生”一个u的定值，并杀死其它对u的定值</li>
<li>$f_d(x) &#x3D; gen_d \cup ( x - kill_d)$</li>
<li>$gen_d$: 语句d生成的定值集合{d}</li>
<li>$kill_d$: 语句d杀死的定值集合</li>
</ul>
</li>
<li>基本块的转移函数$f_B$<ul>
<li>$f_B(x) &#x3D; gen_B \cup ( x - kill_B)$</li>
<li>$out[B] &#x3D; f_B(in[B]) &#x3D; gen_B \cup (in[B]-kill_B)$</li>
<li>$in[B] &#x3D; \cup _{p \in pred(B)} out[p]$</li>
</ul>
</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>循环不变计算的检测<ul>
<li><code>x = y + z</code>: y,z是常量，或y和z所有可能的定值都在循环外面</li>
</ul>
</li>
<li>常量传播&#x2F;折叠<ul>
<li><code>x = y + z</code>: y|z只有一个定值可到达，并且该定值把一个常量赋值给y|z，那么可以简单地把y|z替换为该常量</li>
</ul>
</li>
<li>判定变量x在p点上是否未经定值就被引用</li>
</ul>
<h4 id="迭代算法"><a href="#迭代算法" class="headerlink" title="迭代算法"></a>迭代算法</h4><p>输入: 流图G，并且已经计算了所有的$gen_B, kill_B$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out[ENTRTY] = \emptyset</span><br><span class="line">for (除ENTRY之外的每个基本块B) out[B] = \emptyset</span><br><span class="line">while (某个out值发生了改变)</span><br><span class="line">  for (除ENTRY之外的每个基本块) &#123;</span><br><span class="line">    in[B] = \cup _&#123;p \in pred(B)&#125; out[P]</span><br><span class="line">    out[B] = gen_B \cup (in[B] - kill_B)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="UD链-Use-Definition-Chain-引用的定值链"><a href="#UD链-Use-Definition-Chain-引用的定值链" class="headerlink" title="UD链(Use-Definition Chain)-引用的定值链"></a>UD链(Use-Definition Chain)-引用的定值链</h3><ul>
<li>点u引用(use) a，能到达点u的a的所有定值点的全体称为a在点u的引用-定值链</li>
<li>基本块B中a的引用点u之前有a的定值，那么a的最后一次定值点是该ud链的唯一定值点: {d}</li>
<li>基本块B中a的引用点之前没有a的定值，那么in[B]中a的所有定值点都能到达u，它们即A在点u的ud链</li>
</ul>
<h3 id="活跃变量数据流分析"><a href="#活跃变量数据流分析" class="headerlink" title="活跃变量数据流分析"></a>活跃变量数据流分析</h3><ul>
<li>活跃变量：对于程序中的变量v和某点p: 流图中存在一条从p开始的通路引用v在点p的值，则称v在点p是活跃的，否则是不活跃的</li>
<li>用途<ul>
<li>删除无用赋值<ul>
<li>无用赋值：如果v在点p的定值在基本块内所有后继点都不被引用，且v在基本块出口之后又是不活跃的，那么v在点p的定值就是无用的</li>
</ul>
</li>
<li>为基本快分配寄存器<ul>
<li>如果所有寄存器都被占用，并且还需要申请一个寄存器，则应该考虑使用已经存放了死亡值的寄存器，因为这个值不需要保存到内存</li>
<li>如果一个值在基本块结尾处就是死的就不必再结尾处保存这个值</li>
</ul>
</li>
</ul>
</li>
<li>活跃变量数据流方程<ul>
<li>$out[B] &#x3D; \cup _{S \in succ(B)} in[S]$</li>
<li>$in[B] &#x3D; use_B \cup (out[B] - def_B)$</li>
<li>初始条件: $in[EXIT] &#x3D; \varnothing$</li>
<li>$use_B$: B中引用前未定值的变量集合</li>
<li>$def_B$: B中定值前未引用的变量集合</li>
</ul>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>输入：流图G，所有的$use_B, def_B$都已计算出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in[EXIT] = \emptyset</span><br><span class="line">for (除EXIT之外的每个基本块B) in[B] = \emptyset</span><br><span class="line">while (某个in值发生了改变)</span><br><span class="line">  for (除了EXIT之外的每个基本块) &#123;</span><br><span class="line">    out[B] = \cup _&#123;S \in succ(B)&#125; in[S];</span><br><span class="line">    in[B] = use_B \cup (out[B] - def_B);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="定值-引用链"><a href="#定值-引用链" class="headerlink" title="定值-引用链"></a>定值-引用链</h3><ul>
<li>设变量x有一个定值d，该定值所有能够到达的引用u的集合称为x在d处的定值-引用链，简称du链</li>
<li>如果在求解活跃变量数据流方程中的out[B]时，将out[B]表示称从B的末尾处能够到达的引用的集合，那么，可以直接利用这些信息计算基本块B中每个变量x在其定值处的DU链<ul>
<li>如果B中x的定值之后有x的第一个定值d’,则d和d’之间x的所有引用构成d的DU链</li>
<li>如果B中x的定值d之后没有x的新的定值，则B中d之后x的所有引用以及out[B]中x的所有引用构成d的DU链</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>acme-nginx-configure</title>
    <url>/2025/03/18/acme-nginx-configure/</url>
    <content><![CDATA[<h1 id="在vps上通过acme-sh自动申请证书，并用nginx作反向代理"><a href="#在vps上通过acme-sh自动申请证书，并用nginx作反向代理" class="headerlink" title="在vps上通过acme.sh自动申请证书，并用nginx作反向代理"></a>在vps上通过acme.sh自动申请证书，并用nginx作反向代理</h1><p>本篇博客记录一下个人在自己的vps服务器上通过acme.sh获取证书，并配置nginx反向代理的过程。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="安装acme-sh"><a href="#安装acme-sh" class="headerlink" title="安装acme.sh"></a>安装acme.sh</h3><p>安装acme.sh非常简单，只要照着github上面的说明走就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh -s email=my@example.com</span><br></pre></td></tr></table></figure>
<p>一般来说，都是把acme.sh直接安装到当前用户的用户根目录下。</p>
<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><p>在Ubuntu上安装nginx直接通过apt就可以安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>需要购买一个自己的域名，只要有了根域名后就可以在cloudflare上创建多个子域名，干各种事情了。</p>
<h2 id="为自己的域名申请证书"><a href="#为自己的域名申请证书" class="headerlink" title="为自己的域名申请证书"></a>为自己的域名申请证书</h2><p>假设在cloudflare上，为自己的域名解析添加了一个子域名test.example.com到自己的服务器xx.xx.xx.xx，类型为<code>A</code>，开启cloudflare代理。</p>
<h3 id="创建一个随便的nginx配置文件"><a href="#创建一个随便的nginx配置文件" class="headerlink" title="创建一个随便的nginx配置文件"></a>创建一个随便的nginx配置文件</h3><p>首先在<code>/etc/nginx/sites-available</code>中随便创建一个nginx的配置文件（真的随便创建一个就好，不影响后面的）</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/sites-available/test</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> test.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/certbot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个软链接，把这个文件链接到<code>/etc/nginx/sites-enabled</code>下面去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/test /etc/nginx/sites-enabled/test</span><br></pre></td></tr></table></figure>
<p>接下来，最好检查一下创建的这个test配置文件是否有什么语法问题，使用以下命令来检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">check <span class="keyword">if</span> any syntax error <span class="keyword">in</span> nginx configuration files</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reload nginx process</span></span><br><span class="line">service reload nginx</span><br></pre></td></tr></table></figure>

<h3 id="使用acme-sh针对自己的域名和配置文件申请证书"><a href="#使用acme-sh针对自己的域名和配置文件申请证书" class="headerlink" title="使用acme.sh针对自己的域名和配置文件申请证书"></a>使用acme.sh针对自己的域名和配置文件申请证书</h3><p>使用以下命令来为域名test.example.com申请一个方便nginx使用的证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --issue --nginx -d test.example.com</span><br></pre></td></tr></table></figure>
<p>如果输出中没有error，就说明申请成功。</p>
<h2 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h2><p>目前只碰到过两种类型的网页。一种是诸如hexo博客这种的静态网页，直接会生成好文件。另一种就是像frps dashboard或者galene这样的直接在某一端口号上的进程。<br>两种网页的nginx配置稍微有点不同。</p>
<h3 id="静态网页"><a href="#静态网页" class="headerlink" title="静态网页"></a>静态网页</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HTTP 配置 - 监听 80 端口并重定向所有流量到 HTTPS</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> blog.cassiusblack.top;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/html;  <span class="comment"># 默认生成的静态网页放在/var/www/html下</span></span><br><span class="line">    <span class="attribute">index</span> index.html;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重定向 HTTP 到 HTTPS</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTPS 配置 - 监听 443 端口并启用 SSL</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> test.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/tls/test_fullchain.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/tls/test.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">&#x27;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384&#x27;</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">1h</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    <span class="attribute">index</span> index.html;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，把<code>server_name</code>修改为自己的对应的域名，然后需要注意<code>ssl_certificate</code>和<code>ssl_certificate_key</code>后面的这两个路径，在之后的acme.sh的install命令中会要用到。一般也就顺便放在<code>/etc/nginx</code>中</p>
<h3 id="进程类网页"><a href="#进程类网页" class="headerlink" title="进程类网页"></a>进程类网页</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> test.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTP 到 HTTPS 的重定向</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> meeting.cassiusblack.top;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SSL 证书配置</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/tls/test_fullchain.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/tls/test.key;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">&#x27;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384&#x27;</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">1h</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向代理 Galene Web 服务器</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8443;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># WebSocket 代理配置（用于实时视频和音频）</span></span><br><span class="line">    <span class="section">location</span> /ws &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8443;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安装证书到指定位置"><a href="#安装证书到指定位置" class="headerlink" title="安装证书到指定位置"></a>安装证书到指定位置</h2><p>需要记住之前使用到的<code>ssl_certificate</code>和<code>ssl_certificate_key</code>中的路径，接下来就是要把cert和key安装到这个目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --install-cert -d test.example.com --key-file /etc/nginx/tls/test.key --fullchain-file /etc/nginx/tls/test_fullchain.crt --cert-file /etc/nginx/tls/test.crt --reloadcmd &quot;service nginx reload&quot;</span><br></pre></td></tr></table></figure>
<p>其中，<code>cert-file</code>其实是只有Apache才需要的，nginx并不需要，所以也可以选择不生成cert-file，只要确保有fullchain-file和key-file就可以了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>重载nginx服务一遍，同时确保ping自己的域名的时候能够解析出服务器的IP。然后就可以通过浏览器登录了。</p>
]]></content>
      <categories>
        <category>basic_cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>acme</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>HUST-CS-计算机网络</title>
    <url>/2024/12/12/HUST-CS-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h4 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h4><ul>
<li>因特网是世界范围的计算机网络</li>
<li>因特网向是应用程序提供服务的基础设置，提供统一的套接字编程接口</li>
</ul>
<h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h4><p>协议是指计算机之间通讯的语言，定义了网络实体之间鹰遵守的原则</p>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><h4 id="网络划分"><a href="#网络划分" class="headerlink" title="网络划分"></a>网络划分</h4><ul>
<li>网络核心：<ul>
<li>路由器&#x2F;交换机</li>
<li>网络的网络</li>
</ul>
</li>
<li>网络边缘：<ul>
<li>主机：客户机&#x2F;服务器</li>
<li>位于数据中心的服务器</li>
</ul>
</li>
</ul>
<h4 id="网络边缘的组成"><a href="#网络边缘的组成" class="headerlink" title="网络边缘的组成"></a>网络边缘的组成</h4><p>主机（端系统）：客户机 + 服务器</p>
<h4 id="网络边缘的作用"><a href="#网络边缘的作用" class="headerlink" title="网络边缘的作用"></a>网络边缘的作用</h4><ul>
<li>让用户在端系统上运行各自的应用程序</li>
<li>用户享受到因特网的各种服务</li>
</ul>
<h3 id="网络接入"><a href="#网络接入" class="headerlink" title="网络接入"></a>网络接入</h3><h4 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h4><p>将网络边缘的端系统（主机）与网络连接起来的链路。</p>
<p>连接到哪里：将端系统连接到边缘路由器上</p>
<blockquote>
<p>边缘路由器：端系统到任何其它远程端系统的路径上的第一台路由器</p>
</blockquote>
<h5 id="端系统接入网络的方式"><a href="#端系统接入网络的方式" class="headerlink" title="端系统接入网络的方式"></a>端系统接入网络的方式</h5><ul>
<li>点对点方式接入<ul>
<li>通过电话线<ul>
<li>Modem拨号：通过本地电话线路点对点连接ISP拨号池（通常是路由器），理论最高56kbps，无法实现上网同时拨打电话</li>
<li>ADSL：不对称数字用户线。用调制解调器将数据调制成高音频信号。</li>
</ul>
</li>
<li>通过光纤到户<ul>
<li>光纤通过光调制解调器（光猫）将光电信号互相转换。电脑通过双绞线连接到光猫。</li>
</ul>
</li>
<li>通过卫星</li>
</ul>
</li>
<li>以太网&#x2F;WiFi方式接入</li>
<li>广域无线接入</li>
</ul>
<h2 id="分组交换与电路交换"><a href="#分组交换与电路交换" class="headerlink" title="分组交换与电路交换"></a>分组交换与电路交换</h2><ul>
<li>第一代计算机网络：电路交换网络</li>
<li>第二代计算机网络：分组交换网络</li>
</ul>
<h3 id="电路交换网络"><a href="#电路交换网络" class="headerlink" title="电路交换网络"></a>电路交换网络</h3><ol>
<li>数据交换过程<ol>
<li>建立连接</li>
<li>交换数据</li>
<li>释放连接</li>
</ol>
</li>
<li>电路交换中的复用<ol>
<li>时分复用TDM</li>
<li>频分复用FDM</li>
</ol>
</li>
<li>电路交换网络特性<ol>
<li>数据交换前需建立起一条从发端到收端的物理通路</li>
<li>在数据交换的全部时间内用户始终占用端到端的固定传输信道</li>
<li>交换双方可实时进行数据交换而不会存在任何延迟</li>
</ol>
</li>
<li>问题<ol>
<li>计算机之间的数据交换往往具有突发性和间歇性特征，而对电路交换而言，用户支付的费用是按用户占用线路的时间收费的</li>
<li>不够灵活。只要在童话双方建立的通路中的任何一点出了故障，就必须重新拨号建立新的连接，这对紧急和重要通信是很不利的</li>
</ol>
</li>
</ol>
<h3 id="分组交换网络"><a href="#分组交换网络" class="headerlink" title="分组交换网络"></a>分组交换网络</h3><ol>
<li>引入动机<ol>
<li>专门用于计算机之间的数据传送</li>
<li>能够连接不同类型的计算机</li>
<li>所有的网络节点同等重要，不能有特别重要的节点</li>
<li>必须有冗余路由</li>
<li>网络结构尽可能简单，能够可靠传送数据</li>
</ol>
</li>
<li>工作流程<ol>
<li>长数据切分成小段：在发送端，先把较长的报文划分成较短的、固定长度的数据段</li>
<li>生成分组：每一个数据段前面添加上首部构成分组</li>
<li>接收数据：接收端收到分组后剥去首部还原成报文</li>
<li>恢复报文</li>
</ol>
</li>
<li>分组首部的重要性<ol>
<li>每一个分组的首部都包含有地址等控制信息</li>
<li>节点交换机必须根据首部中的地址信息，选则路由，把分组转发到下一个节点交换机</li>
<li>没有这些信息，就不知道该往哪里转发分组，也就到不了最终目的地</li>
</ol>
</li>
<li>特征<ol>
<li>被传送的数据分成若干分组分别传送</li>
<li>数据传输前不必预先确定分组的传输路径</li>
<li>网络核心中每个交换节点均为共享节点</li>
<li>数据传输采用存储&#x2F;转发模式</li>
<li>各节点具有选则合适路由的能力</li>
</ol>
<ul>
<li>网络核心断续（动态）分配传输带宽，使得通信线路的利用率得以大大提高</li>
<li>网络核心常采用网状拓扑结构，降低拥塞活故障时的影响</li>
</ul>
</li>
</ol>
<h4 id="分组交换网络的分类"><a href="#分组交换网络的分类" class="headerlink" title="分组交换网络的分类"></a>分组交换网络的分类</h4><ul>
<li>数据报网络<ul>
<li>完全按照分组交换网络的原理进行工作（纯分组交换）<ul>
<li>按照分组内的目的地址路由</li>
<li>在会话过程中路由可能改变</li>
</ul>
</li>
</ul>
</li>
<li>虚电路网络：为了获得一些电路交换的有点，在分组交换网上模拟一些电路交换的特点<ul>
<li>虚电路需要建立连接，即建立虚电路链路</li>
<li>在建立连接时决定链路的路由，在整个连接过程中保持不变</li>
<li>在链路通过的每个节点，预留一定的资源</li>
<li>每个分组携带一个标识（虚电路号），根据该标识知道该从哪个虚电路传输数据</li>
<li>虚电路如果不使用了，需要释放相关的资源</li>
</ul>
</li>
</ul>
<h3 id="分组交换VS电路交换"><a href="#分组交换VS电路交换" class="headerlink" title="分组交换VS电路交换"></a>分组交换VS电路交换</h3><ul>
<li><p>在相同条件下，分组交换能够比电路交换支持更多的用户</p>
</li>
<li><p>当用户数较少时，分组交换能够获得比电路交换更好的性能</p>
</li>
<li><p>在数据量大时，分组交换的传输时延比电路交换大（分组交换在节点之间传输数据的时候，每个节点都必须要完整收到数据报文才能够把数据报文重新切分而发出去）</p>
<ul>
<li>分组在各节点存储转发时因要排队，总会造成一定的时延。当网络通信量过大时，这种时延可能会很大</li>
<li>各分组必须携带一定的控制信息（说明信息），从而带来额外开销</li>
<li>&#x3D;&#x3D;&gt; 整个分组交换网的管理和控制比较复杂</li>
</ul>
</li>
<li><p>若要连续传送大量数据，且其传送时间远大于呼叫建立时间，则采用在数据通信之前预先分配传输带宽的电路交换比较合适</p>
</li>
<li><p>分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率</p>
</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心的主要任务：将数据从一个网络传输到远方的另一个网络</p>
<h2 id="时延、丢包和吞吐量"><a href="#时延、丢包和吞吐量" class="headerlink" title="时延、丢包和吞吐量"></a>时延、丢包和吞吐量</h2><h3 id="数据丢失和产生时延的原因"><a href="#数据丢失和产生时延的原因" class="headerlink" title="数据丢失和产生时延的原因"></a>数据丢失和产生时延的原因</h3><ul>
<li>数据不断从设备推送到网络上，需要花费一定的时间，推送的速度收到网络带宽的影响</li>
<li>数据不断从链路的一端传送到链路的另一端，需要花费一定的时间，传送速度收到电子传送速度影响</li>
<li>设备接收数据以及决定往哪里转发数据，需要花费一定的时间，处理时间受设备硬件的影响</li>
<li>路由器接收到的数据需要排队以便按顺序转发和调节接收与转发速度的不一致，排队需要花费一些时间，排队时间受设备硬件的影响</li>
<li>当数据队列已满时，再收到的数据只能丢掉</li>
<li>当报文网络中传输，路由形成了环路，无法传送到目标节点时，这个报文也只能丢掉</li>
</ul>
<h3 id="四种分组时延"><a href="#四种分组时延" class="headerlink" title="四种分组时延"></a>四种分组时延</h3><ul>
<li><p>总时延：</p>
<ul>
<li>处理时延</li>
<li>排队时延</li>
<li>传输时延</li>
<li>传播时延</li>
</ul>
</li>
<li><p>排队时延分析：</p>
<ul>
<li>R&#x3D;链路带宽(bps), L&#x3D;分组长度(bites), a&#x3D;平均分组到达速率</li>
<li>流量强度: $\frac{La}{R}$<ul>
<li>$\frac{La}{R}$ ~ 0: 平均排队时延很小，甚至为0</li>
<li>$\frac{La}{R} &lt; 1$: 时延较小，且会随时间推延而变小</li>
<li>$\frac{La}{R} &#x3D; 1$: 时延不会变化，具体数值取决于当时队列长度</li>
<li>$\frac{La}{R} &gt; 1$: 平均时延较大，且随时间推延而趋于无穷</li>
</ul>
</li>
</ul>
</li>
<li><p>吞吐量</p>
<ul>
<li>在发送方与接收方之间传输比特的速率</li>
<li>瓶颈链路：在端到端路径上限制了端到端平均吞吐量的一段链路</li>
</ul>
</li>
</ul>
<h2 id="层次化的网络体系结构"><a href="#层次化的网络体系结构" class="headerlink" title="层次化的网络体系结构"></a>层次化的网络体系结构</h2><ul>
<li><p>协议层次结构的好处</p>
<ul>
<li>协议之间的调用关系明确</li>
<li>模块化简化了系统的维护和升级<ul>
<li>某个层次服务实现的改变对系统的其余部分是透明的</li>
</ul>
</li>
</ul>
</li>
<li><p>分层的做法的不完善处</p>
<ul>
<li>不是所有协议关系都能够归结为两层之间</li>
<li>偶尔会出现<ul>
<li>隔层调用服务的想想</li>
<li>或者下层调用上层的现象</li>
</ul>
</li>
</ul>
</li>
<li><p>基本概念</p>
<ul>
<li>实体(entity): 实体是任何可以发送和接收信息的硬件和软件进程。通常是一个特定的软件模块</li>
<li>对等体(peer): 不同机器上包含对应层的实体成为对等体</li>
<li>服务(service): 为保证上层对等体之间能互相通信，下层向上层提供的功能</li>
<li>接口(interface): 接口位于每对相邻层之间，定义了下层向上层提供的原语操作和服务</li>
<li>协议数据单元(PDU): 协议数据单元是对等层次上传送数据的单位</li>
<li>服务数据单元(SDU): 服务数据单元是层与层之间交换数据的单位</li>
<li>网络体系结构(network architecture): 网络体系结构就是层和协议的集合</li>
<li>协议栈(protocol stack): 一个特定的系统所使用的一系列协议（每层一组协议）</li>
</ul>
</li>
</ul>
<h3 id="网络体系结构模型介绍"><a href="#网络体系结构模型介绍" class="headerlink" title="网络体系结构模型介绍"></a>网络体系结构模型介绍</h3><ul>
<li><p>因特网5层模型（协议栈）</p>
<ul>
<li>应用层<ul>
<li>支持网络应用</li>
</ul>
</li>
<li>运输层<ul>
<li>不同主机上进程间的数据传输</li>
</ul>
</li>
<li>网络层<ul>
<li>主机间的数据通信</li>
</ul>
</li>
<li>链路层<ul>
<li>数据在网络相邻节点之间传输</li>
</ul>
</li>
<li>物理层<ul>
<li>在线路上传输比特流</li>
</ul>
</li>
</ul>
</li>
<li><p>ISO的7层模型（OSI）</p>
<ul>
<li>应用层</li>
<li>表示层<ul>
<li>数据的含义、描述等统一的表示</li>
</ul>
</li>
<li>会话层<ul>
<li>数据交换的同步、定界、建立检查点和恢复的能力</li>
</ul>
</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
</li>
<li><p>报文封装</p>
<ul>
<li>应用层：报文 </li>
<li>运输层：报文段</li>
<li>网络层：数据报</li>
<li>链路层：帧</li>
</ul>
</li>
</ul>
<h3 id="因特网中复用和分解"><a href="#因特网中复用和分解" class="headerlink" title="因特网中复用和分解"></a>因特网中复用和分解</h3><ul>
<li>常用的集中复用技术<ul>
<li>针对应用进程<ul>
<li>套接字</li>
</ul>
</li>
<li>针对电路层<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>码分多址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据差错的检查方法"><a href="#数据差错的检查方法" class="headerlink" title="数据差错的检查方法"></a>数据差错的检查方法</h3><ul>
<li>常用检查报文出错的方法：<ul>
<li>奇偶校验</li>
<li>检查和</li>
<li>循环冗余校验码</li>
</ul>
</li>
</ul>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><ul>
<li>网络应用之间通信所采用的体系架构<ul>
<li>客户机&#x2F;服务器体系架构(C&#x2F;S)<ul>
<li>存在一个能够向客户机提供服务的服务器</li>
<li>存在一个或多个主动连接服务器，试图从服务器那里获得所需服务的客户机</li>
<li>注意：<ul>
<li>客户机之间不能互相通信</li>
<li>为提高服务器的处理能力，通常采用服务器集群</li>
</ul>
</li>
</ul>
</li>
<li>P2P体系架构<ul>
<li>任何一方既提供服务又享受服务</li>
<li>节点之间可以直接通信</li>
<li>节点的地址以及他们之间的连接可能随时发生变化</li>
<li>特点：容易扩展，但是特别难以管理</li>
</ul>
</li>
<li>混合体系架构</li>
</ul>
</li>
</ul>
<p>应用层协议不等于网络应用</p>
<ul>
<li><p>应用层协议定义了</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>进程何时、如何发送报文及对应报文进行相应</li>
</ul>
</li>
<li><p>TCP</p>
<ul>
<li>面向连接：在客户端和服务器进程之间需要建立连接</li>
<li>可靠传输：在发送和接收进程之间</li>
<li>流量控制：发送数据的速度绝对不超过接收的速度</li>
<li>拥塞控制：当网络超负荷时，束紧发送端口，减缓发送速度</li>
<li>不提供：实时性，最小带宽承诺</li>
</ul>
</li>
<li><p>UDP</p>
<ul>
<li>在客户端和服务器进程之间实现“不可靠”数据传输</li>
<li>不提供：连接建立，可靠性保证，流量控制，拥塞控制，实时性，最小带宽承诺</li>
</ul>
</li>
<li><p>安全性</p>
<ul>
<li>TCP&#x2F;UDP天生不具备安全性</li>
<li>安全套接字层SSL<ul>
<li>提供加密的TCP连接</li>
<li>数据的完整性检查</li>
<li>端点身份鉴别</li>
<li>SSL位于应用层与TCP之间</li>
</ul>
</li>
</ul>
</li>
<li><p>套接字</p>
<ul>
<li>每个网络应用进程都有一个属于自己的套接字，该套接字在整个因特网上独一无二</li>
<li>主机地址：表示该网络应用进程运行在因特网上哪一台主机上，通常使用32位的IP地址进行标识</li>
<li>端口地址：在该主机上标识该网络应用进程，通常使用16位的端口号进行标识</li>
<li>所以套接字的长度为48位</li>
<li>进程通过套接字来接收和发送报文</li>
<li>套接字相当于一个通道<ul>
<li>发送进程将报文交给套接字</li>
<li>套接字将这些报文传输到接收进程的套接字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="web和HTTP"><a href="#web和HTTP" class="headerlink" title="web和HTTP"></a>web和HTTP</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul>
<li>WEB的内容表达<ul>
<li>web页面由一些对象组成</li>
<li>对象可以是HTML, JPEG, 音频文件, JAVA APPLET</li>
<li>HTML文件是web页面的基础，它可以包括各种各样的对象，是一个容器对下个</li>
<li>任何一个对象都可以用URL来定位</li>
</ul>
</li>
<li>WEB的内容传输<ul>
<li>客户端&#x2F;服务器模式<ul>
<li>客户端：浏览器请求、接收、展示web对象</li>
<li>服务器：web服务器发送对象，对请求进行响应</li>
</ul>
</li>
<li>http: TCP传输服务<ul>
<li>客户端启动TCP连接（创建套接字）到服务器，端口80</li>
<li>服务器接受来自客户端的TCP连接</li>
<li>http报文（应用层协议报文）在浏览器(http client)和web服务器(http server)之间进行性交换</li>
<li>关闭TCP连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li><p>HTTP1.0 非持久性连接</p>
<ul>
<li>每传输一个文件都需要建立连接-请求文件-收到文件</li>
</ul>
</li>
<li><p>HTTP1.1 持久连接</p>
<ul>
<li>服务器在发送响应后，不再断开TCP连接，而是保持该连接，用于后续对象的传送，直至该连接“休息”了一个较长的时间后，方断开连接</li>
<li>减少了对服务器端连接数的要求，从而减少了对服务器端套架子资源的占用，提高了服务器的负载能力</li>
<li>分类：<ul>
<li>非流水线方式：一个对象传输完方能传输下一个</li>
<li>流水线方式：可以一次性发送所有请求，慢慢接收</li>
</ul>
</li>
<li>存在的问题：<ul>
<li>存在多个对象时，晓对象会被排在前面的大对象阻塞——队首(HOL)阻塞——用户体验极差</li>
<li>多TCP连接并发可以规避这个问题——回到了HTTP&#x2F;1.0</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP&#x2F;2</p>
<ul>
<li>目标：减少多对象访问时的感知延迟<ul>
<li>方案：<ul>
<li>方法、状态短码和大多数首部字段与HTTP1.1相同</li>
<li>根据客户指定的对象优先级（不一定是FCFS）确定请求对象的传输顺序</li>
<li>将未请求的对象推送给客户端——服务器推</li>
<li>将对象划分为帧，对帧的传输进行规划以减少HOL阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP&#x2F;3</p>
<ul>
<li>TCP+TLS换成UDP+QUIC,准确来说是通过 (HTTP over QUIC)+QUIC+UDP</li>
<li>相比之下，HTTP&#x2F;2的实现方式是HTTP&#x2F;2+TLS+TCP</li>
</ul>
</li>
<li><p>HTTP报文类型：请求报文&amp;响应报文</p>
</li>
<li><p>请求行支持的方法</p>
<ul>
<li>GET: 向服务器请求指定URL对象</li>
<li>POST: 用于向服务器提交表单数据，也可以同时请求一个WEB页面</li>
<li>HEAD: 返回响应报文，不包含请求的对象</li>
<li>PUT: 山川的文件放在实体主题字段中，目标路径由URL字段标明</li>
<li>DELETE: 删除URL字段中指定的文件</li>
</ul>
</li>
<li><p>常见的响应状态码和短语</p>
<ul>
<li>200 OK: 请求成功，被请求的对象在报文中</li>
<li>301 Moved Permanently: 被请求的对象被移动过，新的位置在报文中有说明</li>
<li>400 Bad Request: 服务器不懂请求报文</li>
<li>404 Not Found: 服务器上找不到请求的对象</li>
<li>505 HTTP Version Not Supported: 服务器不支持请求报文使用的HTTP协议版本</li>
</ul>
</li>
<li><p>用户-服务器交互：cookie</p>
<ul>
<li>web站点使用cookie的目的<ul>
<li>限制用户的访问</li>
<li>把内容和用户身份关联起来</li>
</ul>
</li>
<li>cookie技术的组成部分<ul>
<li>在HTTP响应报文中有一个cookie首部行</li>
<li>在HTTP请求报文中也有一个cookie首部行</li>
<li>在用户的端系统中保留了一个cookie文件，由用户浏览器负责管理</li>
<li>在web站点有一个后端数据库</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><h3 id="电子邮件系统的构成"><a href="#电子邮件系统的构成" class="headerlink" title="电子邮件系统的构成"></a>电子邮件系统的构成</h3><ul>
<li>用户代理<ul>
<li>写作，编辑，阅读邮件报文</li>
</ul>
</li>
<li>邮件服务器<ul>
<li>邮箱：包含了收到的用户邮件（尚未被阅读）</li>
<li>报文：队列包含了外发的邮件报文</li>
</ul>
</li>
<li>简单邮件传输协议: SMTP<ul>
<li>SMTP协议用在邮件服务器之间发送邮件</li>
<li>客户端：将邮件发送到邮件服务器</li>
<li>服务器：接收和转发邮件</li>
</ul>
</li>
</ul>
<h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><ul>
<li><p>使用TCP可靠的传送邮件报文，端口25</p>
</li>
<li><p>直接传输：发送服务器到接收服务器</p>
<ul>
<li>传输三个阶段<ul>
<li>握手</li>
<li>报文传输</li>
<li>结束</li>
</ul>
</li>
<li>命令&#x2F;响应交互：<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和短语</li>
</ul>
</li>
</ul>
</li>
<li><p>邮件报文必须使用7-bit ASCII表示</p>
</li>
<li><p>SMTP使用持续连接</p>
</li>
<li><p>某些代码组合不允许出现在报文中(e.g., CRLF.CRLF),此类数据必须进行编码（通常使用base-64或quoted printable）</p>
</li>
<li><p>SMTP服务器用CRLF.CRLF表示邮件报文的结束</p>
</li>
<li><p>SMTP vs HTTP</p>
<ul>
<li>都使用ASCII命令&#x2F;响应交互，状态码</li>
<li>HTTP: pull; SMTP: push</li>
<li>HTTP协议不限制报文编码格式，SMTP协议要求报文必须使用7-bit ASCII码格式</li>
<li>HTTP: 每个对象分装在各自的响应报文中；SMTP: 多个对象在一个多分布的报文中传送</li>
</ul>
</li>
<li><p>客户机获取邮件的方法</p>
<ul>
<li>POP3协议<ul>
<li>命令行<ul>
<li>list: 列出报文号码</li>
<li>retr: 用报文号码取信</li>
<li>dele: 用报文号码删信</li>
<li>quit</li>
</ul>
</li>
<li>功能：<ul>
<li>“下载-删除”：用户如果更换客户机无法再次阅读原来的邮件</li>
<li>“下载-保存”：在不同的客户机上保存邮件的副本</li>
</ul>
</li>
<li>POP3会话是没有状态的</li>
<li>用户使用POP3协议无法在邮件服务器上对自己的邮件进行重组织，只能将邮件下载到本地计算机进行重组织</li>
</ul>
</li>
<li>IMAP协议<ul>
<li>将所有的邮件都保存在服务器上</li>
<li>允许用户在服务器上组织自己的邮件目录</li>
<li>IMAP维护了IMAP会话的用户信息<ul>
<li>目录名以及报文ID与目录名之间的映射关系</li>
</ul>
</li>
</ul>
</li>
<li>HTTP</li>
</ul>
</li>
</ul>
<h2 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS: 因特网的目录服务"></a>DNS: 因特网的目录服务</h2><ul>
<li>DNS简况<ul>
<li>DNS是一个分布式数据库，由很多DNS服务器按层次结构组织起来</li>
<li>DNS运行在一个端到端系统上，且使用UDP协议(53号端口)进行报文传输，因此DNS是应用层协议</li>
<li>DNS以C&#x2F;S模式工作</li>
<li>DNS不直接和用户打交道，是因特网的核心功能</li>
</ul>
</li>
<li>一次最简单的DNS解析过程<ul>
<li>浏览器输出<a href="http://www.hust.edu.cn/index.html%E9%93%BE%E6%8E%A5%EF%BC%8C%E4%BB%8E%E8%AF%A5%E9%93%BE%E6%8E%A5%E4%B8%AD%E5%8F%96%E5%87%BAwww.hust.edu.cn%E9%83%A8%E5%88%86%EF%BC%8C%E5%8F%91%E9%80%81%E7%BB%99DNS%E5%AE%A2%E6%88%B7%E6%9C%BA">www.hust.edu.cn/index.html链接，从该链接中取出www.hust.edu.cn部分，发送给DNS客户机</a></li>
<li>DNS客户机向DNS服务器发送包含域名<a href="http://www.hust.edu.cn的查询请求报文/">www.hust.edu.cn的查询请求报文</a></li>
<li>DNS服务器向DNS客户机返回一个包含对应IP地址的响应报文</li>
<li>DNS客户机将获得的IP地址传送给浏览器</li>
<li>浏览器向IP地址所在WEB服务器发起TCP链接</li>
</ul>
</li>
</ul>
<h3 id="域名系统名字空间和层次结构"><a href="#域名系统名字空间和层次结构" class="headerlink" title="域名系统名字空间和层次结构"></a>域名系统名字空间和层次结构</h3><ul>
<li><p>Internet的域名结构</p>
<ul>
<li>Internet的域名结构采用了层次树状结构的明明方法</li>
<li>域名的结构由若干分量组成，各分量之间用小数点隔开，总长不超过255个字符</li>
<li>各分量分别代表不同级别的域名（不超过63字符）</li>
<li>合法域名中，小数点的个数至少为一个</li>
</ul>
</li>
<li><p>顶级域名(TLD Top Level Domain)一般有三类</p>
<ul>
<li>国家或地区顶级域名nTLD,也记作ccTLD</li>
<li>基础设施域 .arpa(Address and Routing Parameter Area)<ul>
<li>专用于Internet基础设施目的</li>
</ul>
</li>
<li>通用顶级域名gTLD</li>
</ul>
</li>
<li><p>跟DNS服务器-权威DNS服务器-本地DNS服务器</p>
</li>
<li><p>严格来说，本地DNS服务器并不属于DNS层次结构中的一层</p>
</li>
</ul>
<h3 id="DNS解析的过程"><a href="#DNS解析的过程" class="headerlink" title="DNS解析的过程"></a>DNS解析的过程</h3><ul>
<li><p>DNS解析过程：递归+迭代 VS 纯递归</p>
</li>
<li><p>递归+迭代的对服务器的负载压力会比较小。</p>
</li>
<li><p>递归+迭代</p>
<ul>
<li>本地DNS服务器通过根DNS服务器获取需要解析的地址的顶级域名的相关信息</li>
<li>本地DNS服务器根据获取的顶级域名相关信息，去对应的顶级域名服务器获取权威DNS服务器的相关信息</li>
<li>本地DNS服务器根据获取的权威DNS服务器的相关信息，去对应的权威DNS服务器获取需要解析的地址的信息</li>
</ul>
</li>
<li><p>纯递归</p>
<ul>
<li>本地DNS服务器向根DNS服务器发送希望解析的地址</li>
<li>根DNS服务器直接向对应的顶级域名服务器发送希望解析的地址</li>
<li>顶级域名服务器向权威DNS服务器发送希望解析的地址</li>
<li>权威DNS服务器向顶级域名返回结果，再一路返回回去</li>
</ul>
</li>
<li><p>DNS缓存</p>
<ul>
<li>任何域名服务器一旦得知了某个映射，就将其缓存</li>
<li>在一定的时间间隔后缓存的条目将会过期自动消除</li>
<li>TLD DNS服务器通常被缓存在本地DNS服务器中，这样可以减少根DNS的负载</li>
</ul>
</li>
<li><p>DNS提供的服务</p>
<ul>
<li>域名到IP地址的转换</li>
<li>主机&#x2F;邮件服务器别名<ul>
<li>为不好记的规范主机&#x2F;邮件服务器名提供一个容易记忆的别名</li>
<li>e.g. <a href="http://www.hotmail.com/">www.hotmail.com</a> -&gt; <a href="http://www.hotmail.aate.nsatc.net/">www.hotmail.aate.nsatc.net</a></li>
</ul>
</li>
<li>负载均衡<ul>
<li>一个域名对应多个IP</li>
<li>DNS服务器在多个IP中进行轮转</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="攻击DNS服务器"><a href="#攻击DNS服务器" class="headerlink" title="攻击DNS服务器"></a>攻击DNS服务器</h3><ul>
<li>DDoS攻击<ul>
<li>通过ICMP Ping洪泛攻击根DNS服务器——难以成功<ul>
<li>根服务器通常配备分组过滤器</li>
<li>大多数本地DNS服务器缓存了TLD DNS服务器的地址</li>
</ul>
</li>
<li>通过DNS请求报文洪泛攻击TLD DNS服务器<ul>
<li>难以过滤</li>
</ul>
</li>
</ul>
</li>
<li>重定向攻击<ul>
<li>中间人攻击：攻击者截获来自主机的请求并返回伪造的回答</li>
<li>DNS毒害攻击：攻击者向一台DNS服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录</li>
</ul>
</li>
<li>利用DNS服务器对目标主机采用DDoS攻击：反射攻击</li>
</ul>
<h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><ul>
<li>速度对比<ul>
<li>C&#x2F;S模式<ul>
<li>$$ T_{CS} &gt;&#x3D; max { \frac{NF}{\mu _s}, \frac{F}{min{d_1, d_2, …, d_N}} } $$</li>
</ul>
</li>
<li>P2P模式<ul>
<li>$$ T_{P2P} &gt;&#x3D; max { \frac{F}{\mu <em>s}, \frac{F}{d</em>{min}}, \frac{NF}{\mu _s + \sum _1 ^N \mu _i} } $$</li>
</ul>
</li>
</ul>
</li>
<li>基本概念<ul>
<li>BitTorrent的基本概念<ul>
<li>洪流torrent: 参与一个特定文件分发的所有对等方的集合</li>
<li>追踪器tracker: 跟踪正参与在洪流中的对等方</li>
<li>文件快chunk</li>
</ul>
</li>
<li>BitTorrent的基本工作机制<ul>
<li>向邻居请求哪些块：最稀罕优先</li>
<li>优先响应哪些请求：兑换算法（4+1）<ul>
<li>每10秒重新选则4个最高速率对等放</li>
<li>每30秒随机选则一个新的邻居</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><ul>
<li>运输层的功能<ul>
<li>为不同主机上运行的应用进程提供逻辑通信信道(logical communication)</li>
</ul>
</li>
<li>运输层协议的工作内容<ul>
<li>发送方：把应用数据划分为报文段(segments)，交付给网络层</li>
<li>接收方：把报文段重组成应用数据，交付给应用层</li>
</ul>
</li>
<li>运输层和网络层的区别<ul>
<li>网络层：不同主机之间的逻辑通信</li>
<li>运输层：应用进程之间的逻辑通信</li>
<li>不同的运输层协议可能提供不一样的服务</li>
<li>运输层协议能够提供的服务受到底层网络协议的服务模型限制</li>
<li>在网络层不提供某些服务的情况下，运输层自己提供</li>
</ul>
</li>
<li>因特网上的运输层协议<ul>
<li>用户数据报协议UDP（数据报）</li>
<li>传输控制协议TCP（报文段）</li>
<li>提供的服务<ul>
<li>进程间的数据交付</li>
<li>差错检测</li>
<li>可靠的数据传输</li>
<li>拥塞控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><ul>
<li><p>端口</p>
<ul>
<li>端口的作用就是让应用层各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程（或线程）</li>
<li>端口是用来标志应用层的进程（或线程）</li>
<li>端口用一个16bit端口号进行标志</li>
</ul>
</li>
<li><p>套接字</p>
<ul>
<li>IP地址再互联网上唯一标识一台主机，端口号再一台主机唯一标识一个应用进程，将两者结合起来，可以在互联网上唯一的标识通信双方的一个断电，即应用进程，这两者的组合成为套接字。</li>
</ul>
</li>
<li><p>报文段（数据报）的投送</p>
<ul>
<li>主机收到IP包<ul>
<li>每个数据包都有源IP地址和目的IP地址</li>
<li>每个数据包都携带一个传输层的数据报文段</li>
<li>每个数据报文段都有源、目的端口号</li>
</ul>
</li>
<li>主机根据“IP地址+端口号”将报文段定向到相应的套接字</li>
</ul>
</li>
<li><p>面向连接的复用和分用</p>
<ul>
<li>TCP套接字由一个四元组来标识(源IP地址，源端口号，目的IP地址，目的端口号)</li>
<li>接收方主机根据这四个值将报文段定向到相应的套接字</li>
<li>服务器主机同时支持多个并发的TCP套接字</li>
<li>Web服务器为每一个客户连接都产生不同的套接字<ul>
<li>非持久HTTP对每一个请求都建立不同的套接字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><ul>
<li>最简单的运输层协议，必须提供<ul>
<li>多路复用&#x2F;多路分解</li>
<li>差错检查</li>
</ul>
</li>
<li>UDP处理数据的流程<ul>
<li>发送方<ul>
<li>从应用进程得到数据</li>
<li>附加上为多路复用&#x2F;多路分解所需的源和目的端口号及差错检测信息，形成报文段（数据报）</li>
<li>递交给网络层，尽力而为交付给接收主机</li>
</ul>
</li>
<li>接收方<ul>
<li>从网络层接收数据包</li>
<li>根据目的端口号，将数据交付给相应的应用进程</li>
</ul>
</li>
<li>UDP通信事先无需握手，是无连接的</li>
</ul>
</li>
<li>UDP的优势<ul>
<li>无需建立连接：建立连接会增加时延</li>
<li>简单：发送方和接收方无需维护连接状态</li>
<li>段首部开销小：TCP: 20Bytes VS UDP: 8Bytes</li>
<li>无拥塞控制：UDP可按需随时发送</li>
</ul>
</li>
<li>部分采用UDP协议的应用<ul>
<li>远程文件服务器(NFS)、因特网电话、域名解析、HTTP&#x2F;3、网络管理(SNMP)、流式多媒体</li>
</ul>
</li>
<li>UDP大量引用可能导致的严重后果<ul>
<li>路由器中大量的分组溢出</li>
<li>显著减小TCP通信的速率，甚至挤垮TCP会话</li>
</ul>
</li>
<li>使用UDP的可靠数据传输<ul>
<li>在应用层实现数据的可靠传输</li>
<li>增加了应用进程的实现难度</li>
</ul>
</li>
<li>UDP报文段（数据报）的结构<ul>
<li>首部：源端口、目的端口、长度、检查和 &amp; 应用数据（报文）</li>
<li>其中，长度是包括首部在内的UDP报文段长度，以字节为单位</li>
</ul>
</li>
<li>UDP的检查和<ul>
<li>目标：检测收到的报文段的“差错”</li>
<li>发送方<ul>
<li>把报文段看作是16比特字的段序列</li>
<li>检查和：对报文段的所有16比特字的和进行1的补运算</li>
<li>发送方将计算校验和的结果写入UDP校验的字段中</li>
</ul>
</li>
<li>接收方<ul>
<li>计算接收到的报文段和检验和</li>
<li>检查计算结果是否与收到报文段的校验和字段中的值相同<ul>
<li>不同-检测到错误</li>
<li>相同-没有检测到错误，单仍然可能存在错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><ul>
<li>发送方：<ul>
<li><code>rdt_send()</code>：由上层（如应用层）调用，将数据发发送给接收方上层</li>
<li><code>udt_send()</code>：由rdt调用，将分组通过不可靠通道传给接收方</li>
<li><code>rdt_rcv()</code>：当分组到达接收方时调用</li>
<li><code>deliver_data</code>由rdt调用，将数据交付给上层</li>
</ul>
</li>
</ul>
<h3 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h3><p>信道完全可靠，只要发送和接收数据就可以了</p>
<h3 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h3><ul>
<li>信道可能导致比特出现差错时<ul>
<li>分组比特可能受损</li>
<li>所有传输的分组都将按序被接收，不会丢失</li>
</ul>
</li>
<li>处理机制<ul>
<li>如何判断分组受损——差错检测</li>
<li>如何通知发送方分组是否受损——接收方反馈(ACK&amp;NAK)</li>
<li>在得知分组受损后，发送方的处理手段——出错重传</li>
<li>如何实现重传——使用缓冲区缓存已发送出但未收到反馈的报文——接收方和发送方各以ige报文段大小的缓冲区即可</li>
<li>ACK和NAK分组可能也受损——为分组添加编号——rdt2.1</li>
</ul>
</li>
</ul>
<h3 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h3><ul>
<li>只使用ACK，没有NAK</li>
<li>接收方对最后一个正确收到的分组发送ACK</li>
<li>为便于接收方表明正确收到了哪一个分组，ACK中必须指出被确认分组的序号</li>
<li>发送方收到重复的ACK按照NAK来处理</li>
</ul>
<h3 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h3><p>信道不但可能出错，还可能丢包</p>
<h3 id="rdt3-1"><a href="#rdt3-1" class="headerlink" title="rdt3.1"></a>rdt3.1</h3><p>使用流水线技术提高传输的效率</p>
<ul>
<li>扩大分组序号范围——用k位进行序号编码</li>
<li>扩大发送方乃至接收方的缓冲区大小——窗口</li>
<li>当流水线技术中丢失一个分组后，如何进行重传<ul>
<li>GBN协议：其后分组全部重传</li>
<li>SR协议：仅重传该分组<blockquote>
<p>滑动窗口大小<br>发送端窗口+接收端窗口 $ &lt;&#x3D; 2^k $</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="GBN协议"><a href="#GBN协议" class="headerlink" title="GBN协议"></a>GBN协议</h4><ul>
<li>发送端 $ &lt;&#x3D; 2^k -1 $</li>
<li>ACK(N)：接收方对序号n之前包括n在内的所有分组进行确认——累积ACK</li>
<li>对所有已发送但未确认的分组统一设置一个定时器</li>
<li>超时(n)：重传分组n和窗口中所有序号大于n的分组</li>
<li>失序分组<ul>
<li>丢弃（不缓存）-&gt;接收方无缓存</li>
<li>重发按序到达的最高序号放分组的ACK <blockquote>
<p>发送方窗口 $ &lt;&#x3D; 2^k-1$<br>接收端&#x3D;1</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议"></a>SR协议</h4><ul>
<li>发送方：<ul>
<li>从上层收到数据<ul>
<li>如果下一个可用于该分组的序号在窗口内，则将数据打包并发送</li>
</ul>
</li>
<li>超时(n)<ul>
<li>重传分组n，重置定时器</li>
</ul>
</li>
<li>收到确认(n)在[sendbase, sendbase+N-1]分为内<ul>
<li>标记分组n为已接收</li>
<li>如果n是发送窗口基序号sendbase，则将窗口基序号前推到下一个未确认序号</li>
</ul>
</li>
</ul>
</li>
<li>接收方<ul>
<li>分组序号n在[rcvbase, rcvbase+N-1]范围内<ul>
<li>发送n的确认ACK(n)</li>
<li>如果分组序号不连续（失序）：将其缓存</li>
<li>按序分组：将该分组以及以前缓存的序号连续的分组一起交付给上层，将窗口前推到下一个未收到的分组</li>
</ul>
</li>
<li>分组序号n在[rcvbase-N, rcvbase-1]范围内<ul>
<li>虽然曾经确认过，仍再次发送n的确认ACK(n)</li>
</ul>
</li>
<li>其它情况：忽略该分组</li>
</ul>
</li>
</ul>
<p>在SR协议中，接收方窗口 $ &lt;&#x3D; 2^{k-1} $</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">GBN</th>
<th align="left">SR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">确认方式</td>
<td align="left">累计确认</td>
<td align="left">单个确认</td>
</tr>
<tr>
<td align="left">定时器</td>
<td align="left">对所有已发送但未确认的分组统一设置一个定时器</td>
<td align="left">对所有以发送但未确认的分组分别设置定时器</td>
</tr>
<tr>
<td align="left">超时(n)</td>
<td align="left">重传分组n和窗口中所有序号大于n的分组</td>
<td align="left">仅重传分组n</td>
</tr>
<tr>
<td align="left">失序分组</td>
<td align="left">丢弃（不缓存）-&gt;接收方无缓存；重发按序到达的最高序号分组的ACK</td>
<td align="left">缓存；对失序分组进行选择性确认</td>
</tr>
</tbody></table>
<h2 id="面向连接的传输-TCP"><a href="#面向连接的传输-TCP" class="headerlink" title="面向连接的传输:TCP"></a>面向连接的传输:TCP</h2><ul>
<li><p>概述</p>
<ul>
<li>面向连接</li>
<li>全双工服务</li>
<li>点对点连接</li>
<li>可靠有序的字节流</li>
<li>流量控制 </li>
<li>拥塞控制</li>
<li>流水线</li>
</ul>
</li>
<li><p>关于序列号和ACK的进一步讨论</p>
<ul>
<li>序列号：在报文段数据中第一个字节在字节流中的编号</li>
<li>确认ack<ul>
<li>期待得到的下一个字节的seq</li>
<li>累计ack</li>
<li>Q:接收端如何处理乱序报文段实现</li>
<li>答：TCP规范没有规定，由实现者实现</li>
</ul>
</li>
</ul>
</li>
<li><p>样本RTT估算</p>
<ul>
<li>样本RTT：对报文段被发出到收到该报文的确认之间的时间进行测量（忽略重传）</li>
<li>样本RTT会由波动，要使得估算RTT更平滑，需要将最近几次的测量进行平均（指数加权平均移动），而非仅仅采用最近一次的SampleRTT<ul>
<li>$$ EstimatedRTT &#x3D; (1-\alpha) * EstimatedRTT + \alpha * SampleRTT $$</li>
<li>参考值$\alpha &#x3D; 0.125$，第一次计算的时候，$EstimatedRTT &#x3D; SampleRTT$</li>
</ul>
</li>
<li>考虑RTT的波动，估计EstimatedRTT与SampleRTT的偏差<ul>
<li>$$ DevRTT &#x3D; (1-\beta) * DevRTT + \beta * | SampleRTT - EstimatedRTT $$</li>
<li>参考值$\beta &#x3D; 0.25$，第一次计算时，$DevRTT&#x3D;0.5*SampleRTT$</li>
</ul>
</li>
<li>TCP中的超时间隔为 $TimeoutInterval &#x3D; EstimatedRTT + 4 * DevRTT$</li>
</ul>
</li>
</ul>
<h3 id="可靠的TCP数据传输"><a href="#可靠的TCP数据传输" class="headerlink" title="可靠的TCP数据传输"></a>可靠的TCP数据传输</h3><ul>
<li>IP协议是不可靠的</li>
<li>TCP采用了rdt部分阐述的数据可靠传输方法</li>
<li>特别之处：<ul>
<li>TCP编号采用按字节编号，而非按报文段编号</li>
<li>TCP仅采用唯一的超时定时器</li>
</ul>
</li>
</ul>
<p>产生TCP ACK的建议</p>
<table>
<thead>
<tr>
<th align="left">接收方事件</th>
<th align="left">TCP接收方动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">所期望序号的报文段按序到达。所有在期望序号及其以前的数据都已经被确认</td>
<td align="left">延迟的ACK。对另一个按序报文段的到达最多等待500ms.如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</td>
</tr>
<tr>
<td align="left">由期望序号的报文段按序到达。另一个按序报文段等待发送ACK</td>
<td align="left">立即发送单个累计ACK，以确认两个按序报文段</td>
</tr>
<tr>
<td align="left">比期望序号大的失序报文段到达，检测出数据流中的间隔</td>
<td align="left">立即发送冗余ACK，指明下一个期待字节的序号（也就是间隔的低端字节序号）</td>
</tr>
<tr>
<td align="left">能部分或完全填补接收数据间隔的报文段到达</td>
<td align="left">倘若该报文段起始于间隔的低端，则立刻发送ACK</td>
</tr>
</tbody></table>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><ul>
<li>超时周期往往太长<ul>
<li>增加重发丢失分组的延时</li>
</ul>
</li>
<li>通过重复的ACK检测丢失报文段<ul>
<li>发送方常要连续发送大量报文段</li>
<li>如果一个报文段丢失，会引起很多连续的重复ACK</li>
</ul>
</li>
<li>如果发送收到一个数据的3个重复ACK，他会认为确认数据之后的报文段丢失</li>
<li><strong>快速重传</strong>：在超时到来之前重传报文段</li>
</ul>
<h4 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h4><ul>
<li>每一次TCP重传均将下一次超时间隔设为先前值的两倍</li>
<li>超时间隔由EstimatedRTT和DevRTT决定<ul>
<li>收到上层应用的数据</li>
<li>收到未确认数据的ACK</li>
</ul>
</li>
</ul>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul>
<li>背景<ul>
<li>TCP接收方有一个缓存，所有上交的数据全部缓存在里面</li>
<li>应用进程从缓冲区中读取数据可能很慢</li>
</ul>
</li>
<li>目标<ul>
<li>发送方不会由于传得太多太快而使得接收方缓存溢出</li>
</ul>
</li>
<li>手段<ul>
<li>接收方在反馈时，将缓冲区剩余空间的大小填充在报文段首部的窗口字段中，通知发送方</li>
</ul>
</li>
<li>计算<ul>
<li>接收方：<ul>
<li>LastByteRcvd - LastByteRead &lt;&#x3D; RcvBuffer</li>
<li>RcvWindows &#x3D; RcvBuffer - [LastByteRcvd - LastByteRead]</li>
</ul>
</li>
<li>发送方<ul>
<li>LastByteSent - LastByteAcked &lt;&#x3D; RcvWindow</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况<ul>
<li>接收方通知发送方RcvWindow为0，且接收方无任何数据传送给发送方</li>
<li>发送方持续向接收方发送只有一个字节数据的报文段，目的是试探</li>
</ul>
</li>
</ul>
<h4 id="TCP连接的建立与释放"><a href="#TCP连接的建立与释放" class="headerlink" title="TCP连接的建立与释放"></a>TCP连接的建立与释放</h4><table>
<thead>
<tr>
<th align="left">主机A</th>
<th align="left">主机B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">连接请求 SYN, SEQ&#x3D;x</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">确认 SYN, ACK, SEQ&#x3D;y, ACK&#x3D;x+1</td>
</tr>
<tr>
<td align="left">确认 ACK, SEQ&#x3D;x+1, ACK&#x3D;y+1</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">主机A</th>
<th align="left">主机B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">应用进程释放连接，A不再发送报文 FIN, SEQ&#x3D;x</td>
<td align="left">通知主机应用进程</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">确认 ACK, SEQ&#x3D;y, ACK&#x3D;x+1</td>
</tr>
<tr>
<td align="left">此时A不会再向B发送数据，但是仍然能够接收B发送的数据，处于半关闭状态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">应用进程释放连接，B不再发送报文 FIN, ACK, SEQ&#x3D;y, ACK&#x3D;x+1</td>
</tr>
<tr>
<td align="left">确认 ACK, SEQ&#x3D;x+1, ACK&#x3D;y+1</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">客户机状态</th>
<th align="left">客户机动作</th>
<th align="left">服务器状态</th>
<th align="left">服务器动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CLOSED</td>
<td align="left"></td>
<td align="left">CLOSED -&gt; LISTEN</td>
<td align="left">服务器应用程序创建一个监听套接字</td>
</tr>
<tr>
<td align="left">CLOSED -&gt; SYN_SENT</td>
<td align="left">客户端应用程序启动一个TCP连接，发送SYN</td>
<td align="left">LISTEN -&gt; SYN_RCVD</td>
<td align="left">接收SYN并发送<em>SYN&amp;ACK</em></td>
</tr>
<tr>
<td align="left">SYN_SENT -&gt; ESTABLISHED</td>
<td align="left">接收<em>SYN&amp;ACK</em>，并发送ACK</td>
<td align="left">SYN_RCVD -&gt; ESTABLISHED</td>
<td align="left">接收ACK，不发送</td>
</tr>
<tr>
<td align="left">ESTABLISHED -&gt; FIN_WAIT1</td>
<td align="left">客户端应用程序启动关闭连接</td>
<td align="left">ESTABLISHED -&gt; CLOSE_WAIT</td>
<td align="left">接收FIN,发送ACK</td>
</tr>
<tr>
<td align="left">FIN_WAIT1 -&gt; FIN_WAIT2</td>
<td align="left">接收ACK，不发送</td>
<td align="left">CLOSE_WAIT -&gt; LAST_ACK</td>
<td align="left">发送FIN</td>
</tr>
<tr>
<td align="left">FIN_WAIT2 -&gt; TIME_WAIT</td>
<td align="left">接收FIN,发送ACK</td>
<td align="left">LAST_ACK -&gt; CLOSED</td>
<td align="left">接收ACK，不发送</td>
</tr>
<tr>
<td align="left">TIME_WAIT -&gt; CLOSED</td>
<td align="left">时间到了变为CLOSED状态</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h4><ul>
<li>非正式定义：“过多的源发送了过多的数据，超出了网络的处理能力”</li>
<li>现象<ul>
<li>丢包（路由器缓冲区溢出）</li>
<li>延时长（在路由器缓冲区排列）<ul>
<li>不同于流量控制！</li>
</ul>
</li>
</ul>
</li>
<li>拥塞控制的方法<ul>
<li>网络辅助的拥塞控制<ul>
<li>直接网络反馈：路由器以阻塞分组的形式通知发送方“网络拥塞了”</li>
<li>经由接收方的网络反馈：路由器标识从发送方刘翔接收方分组终端某个字段以只是拥塞的产生，由接收方通知发送方“网络拥塞了”</li>
</ul>
</li>
<li>端到端拥塞控制<ul>
<li>网络层不为拥塞控制提供任何帮助和支持</li>
<li>端系统通过对网络行为（丢包或时延增加）的观测判断网络是否发生拥塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><ul>
<li>传统TCP拥塞控制为端到端拥塞控制<ul>
<li>每个发送方自动感知网络拥塞的程度</li>
<li>发送方根据感知的结果限制外发的流量<ul>
<li>如果前方路径上出现了拥塞，则降低发送速率</li>
<li>如果前方路径上没有出现拥塞，则增加发送速率</li>
</ul>
</li>
</ul>
</li>
<li>传统的TCP拥塞控制需要解决的三个问题<ul>
<li>TCP发送方如何限制外发流量的速率<ul>
<li>拥塞窗口<ul>
<li>$LastByteSent - LastByteAcked &lt;&#x3D; CongWin \quad rate &#x3D; \frac{CongWin}{RTT} Bytes&#x2F;sec$</li>
</ul>
</li>
<li>发送方如何感知拥塞<ul>
<li>超时</li>
<li>三个冗余ACK</li>
</ul>
</li>
<li>在感知到拥塞后，发送方如何调节发送速率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Reno算法"><a href="#Reno算法" class="headerlink" title="Reno算法"></a>Reno算法</h5><ul>
<li>加性增，乘性减(AIMD)<ul>
<li>当出现丢包事件后将当前CongWin大小减半，可以大大减少注入到网络中的分组数</li>
<li>当没有丢包事件发生了，每个RTT之后将CongWEin增大1个MSS，使拥塞串口缓慢增大，防止网络过早出现拥塞</li>
</ul>
</li>
<li>慢启动<ul>
<li>建立连接时，CongWin&#x3D;1MSS</li>
<li>可用带宽&gt;&gt;MSS&#x2F;RTT<ul>
<li>初始阶段以指数的速度增加发送速率</li>
</ul>
</li>
<li>连接初始阶段，以指数的速度增加发送速率，直到发生一个丢包事件为止<ul>
<li>每收到一次确认则将CongWin的值增加一个MSS</li>
</ul>
</li>
<li>总结：初始速率很低，但速率的增长速度很快</li>
</ul>
</li>
<li>对收到3个重复ACK的反应——快速重传<ul>
<li>门限值设为当前CongWin的一半（门限值初始值65KB）</li>
<li>将CongWin减为新的门限值+3MSS</li>
<li>线性增大拥塞窗口</li>
</ul>
</li>
<li>对超时事件的反应<ul>
<li>门限值设为当前CongWin的一半（门限值初始值65KB）</li>
<li>将CongWin设为1个MSS大小</li>
<li>窗口以指数速度增大</li>
<li>窗口增大到门限值之后，再以线性速度增大</li>
</ul>
</li>
<li>快速恢复（TCP推荐但非必须实现）<ul>
<li>3个冗余ACK进入快速重传后</li>
<li>每收到一个冗余ACK: CongWin++</li>
<li>直至收到一个新的ACK: CongWin&#x3D;门限值，重新进入拥塞避免</li>
<li>在进入快速恢复之后及重新进入拥塞避免之间，如果出现超时现象，直接按照前述超时事件进行处理</li>
</ul>
</li>
<li>总结<ul>
<li>当拥塞窗口CongWin小于门限值Threshold时，发送方处于慢启动阶段，窗口以指数速度增大</li>
<li>当拥塞窗口CongWin大于门限值Threshold时，发送方处于拥塞避免阶段 ，窗口线性增大</li>
<li>当收到3个重复的ACK时，门限值Threshold设为拥塞窗口的1&#x2F;2，而拥塞窗口CongWin设为门限制值Threshold+3个MSS</li>
<li>当超时事件发生时，门限值Threshold设为拥塞窗口的1&#x2F;2，而拥塞窗口CongWin设为1个MSS</li>
</ul>
</li>
<li>Reno算法的改进——new reno<ul>
<li>reno存在的问题：当收到一个新的ACK，就会执行快速恢复，CongWin收缩到门限值，可能导致较长时间内无法发送新的报文段，也无法触发快速重传的机制<ul>
<li>信道空闲</li>
<li>timeout直接回到慢启动</li>
</ul>
</li>
<li>解决方案<ul>
<li>记录进入快速重传时的已发送的最高报文序号Recovery</li>
<li>每收到一个新的ACK，如果序号不大于Recovery，不退出快速恢复，而是重传该ACK后的报文段</li>
<li>一旦ACK序号大于Recovery，立即退出快速恢复，收缩到门限值</li>
</ul>
</li>
<li>新的问题<ul>
<li>部分分组可能已经被接收，无意义的重发</li>
</ul>
</li>
<li>解决方案<ul>
<li>在TCP报文段的选项字段中，增加SACK，选则重传</li>
</ul>
</li>
</ul>
</li>
<li>TCP Reno的吞吐量<ul>
<li>在忽略慢启动的情况下</li>
<li>当发生丢包事件前，窗口大小为W，吞吐量为$\frac{W}{RTT}$</li>
<li>丢包事件发生后，窗口大小减为$\frac{W}{2}$, 吞吐量为$\frac{W}{2RTT}$</li>
<li>平均吞吐量$0.75\frac{W}{RTT}$</li>
</ul>
</li>
<li>Reno算法吞吐量的一个问题<ul>
<li>将拥塞窗口值减半甚至减到1MSS，无法充分的利用链路带宽</li>
<li>CUBIC方案<ul>
<li>不调整慢启动和快速恢复，仅优化拥塞避免阶段</li>
<li>$W_{max}$: 最后检测到丢包时TCP拥塞窗口的大小</li>
<li>K: 无丢包情况下，拥塞窗口再次达到$W_{max}$的未来时间点</li>
<li>拥塞窗口增加量&#x3D;$f(|t-K|^3)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Vegas算法"><a href="#Vegas算法" class="headerlink" title="Vegas算法"></a>Vegas算法</h5><ul>
<li>Reno和CUBIC会稳定提高TCP发送速率，直到某个路由器的输出端出现数据包丢失为止：瓶颈链路</li>
<li>关注瓶颈链路对于了解拥塞状况是有价值的</li>
<li>提高TCP发送速率并不会增加存在拥塞瓶颈的端到端吞吐量</li>
<li>提高TCP发送速率会增加测得的RTT</li>
<li>目标：保持管道刚好充满，而不可以更满：让瓶颈链路忙于传输，但避免高延迟&#x2F;缓冲</li>
<li>基于时延的方法<ul>
<li>$RTT_{min} - 观察到的最小的RTT(无拥塞状态)$</li>
<li>无拥塞著阳台的吞吐率&#x3D;$\frac{cwnd}{RTT_{min}}$</li>
<li>测量得到的吞吐率&#x3D;$\frac{上一个RTT周期内发送的字节数}{RTT_{测量}}$<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 测得吞吐率“非常接近”无拥塞状态的吞吐率</span><br><span class="line">  线性增加cwnd  /* 因为路径上无拥塞 */</span><br><span class="line">else if 测得吞吐率“远小于”无拥塞状态的吞吐率</span><br><span class="line">  线性减小cwnd /* 因为路径上有拥塞 */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>拥塞控制过程中不存在诱导&#x2F;强制性能损失</li>
<li>在保持低时延的同时，最大化吞吐率</li>
</ul>
<h4 id="明确拥塞通告"><a href="#明确拥塞通告" class="headerlink" title="明确拥塞通告"></a>明确拥塞通告</h4><ul>
<li>TCP部署通常会实施网络辅助拥塞控制<ul>
<li>路由器在IP头(ToS字段)中标记的两个比特，用于指示拥塞情况<ul>
<li>由网络的运营商选则确定标记的策略</li>
</ul>
</li>
<li>拥塞指示由IP数据报携带送达目标主机</li>
<li>目标主机设置ACK报文段的ECE比特通知源主机：网络中存在拥塞</li>
<li>源主机调整拥塞窗口大小后（通常是减半），设置下一个报文段的CWR比特通知目标主机：拥塞窗口大小已减小</li>
</ul>
</li>
</ul>
<h4 id="TCP拥塞控制的公平性分析"><a href="#TCP拥塞控制的公平性分析" class="headerlink" title="TCP拥塞控制的公平性分析"></a>TCP拥塞控制的公平性分析</h4><ul>
<li>公平性的目标<ul>
<li>如果K个TCP连接共享同一个带宽为R的瓶颈链路，每个连接的平均传输速率为R&#x2F;K</li>
</ul>
</li>
<li>公平性和UDP<ul>
<li>多媒体应用一般不使用TCP<ul>
<li>不希望因为拥塞控制影响其速率</li>
</ul>
</li>
<li>多媒体应用采用UDP<ul>
<li>恒定的速率传输音频和视频数据，可容忍丢包</li>
</ul>
</li>
</ul>
</li>
<li>公平性和并性TCP连接<ul>
<li>无法组织应用在两个主机之间建立多个并性的连接(Web浏览器就是这样)</li>
</ul>
</li>
</ul>
<h2 id="运输层功能的演化"><a href="#运输层功能的演化" class="headerlink" title="运输层功能的演化"></a>运输层功能的演化</h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><ul>
<li>网络层在计算机网络中的地位<ul>
<li>为运输层提供支持<ul>
<li>运输层实现进程到进程的通信</li>
<li>运输层功能的实现依赖于网络层提供的服务</li>
</ul>
</li>
<li>为实现从源主机到目标主机成功地转发数据分组，端到端路径上的每台分组交换机上均需实现网络层</li>
</ul>
</li>
<li>网络层的目标<ul>
<li>实现主机到主机的通信<ul>
<li>如何选路</li>
<li>如何转发</li>
<li>确定是否可达</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络层的主要功能"><a href="#网络层的主要功能" class="headerlink" title="网络层的主要功能"></a>网络层的主要功能</h3><ul>
<li>选路<ul>
<li>在全局范畴为主机之间的通信进行选路，选路的结果反应为分组交换机上的转发表</li>
</ul>
</li>
<li>转发<ul>
<li>分组交换机上的网络层根据转发表以及分组首部信息，将分组通过对应链路进行转发</li>
</ul>
</li>
<li>状态报告<ul>
<li>通过控制消息感知网络通不通、主机是否可到达、路由是否可用等状态</li>
</ul>
</li>
<li>连接建立<ul>
<li>对于面向连接的完了过曾服务，提供连接建立的功能</li>
</ul>
</li>
<li>可能提供的服务<ul>
<li>确保交付</li>
<li>具有时延上界的确保交付</li>
<li>有序分组交付</li>
<li>确保最小带宽</li>
<li>确保最大时延抖动</li>
</ul>
</li>
</ul>
<p>几种实际使用的网络层服务模型</p>
<table>
<thead>
<tr>
<th align="left">网络体系结构</th>
<th align="left">服务模型</th>
<th align="left">带宽保证</th>
<th align="left">无丢失保证</th>
<th align="left">排序</th>
<th align="left">定时</th>
<th align="left">拥塞指示</th>
</tr>
</thead>
<tbody><tr>
<td align="left">因特网</td>
<td align="left">尽力而为</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">不维持</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">ATM</td>
<td align="left">CBR</td>
<td align="left">保证恒定速率</td>
<td align="left">是</td>
<td align="left">有序</td>
<td align="left">维持</td>
<td align="left">无拥塞</td>
</tr>
<tr>
<td align="left">ATM</td>
<td align="left">ABR</td>
<td align="left">保证最小速率</td>
<td align="left">无</td>
<td align="left">有序</td>
<td align="left">维持</td>
<td align="left">提供指示</td>
</tr>
</tbody></table>
<h2 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h2><ul>
<li>网络层选路转发服务<ul>
<li>虚电路服务：面向连接的服务，需事先握手</li>
<li>数据报服务：面向无连接的服务，无需握手</li>
</ul>
</li>
</ul>
<h4 id="虚电路服务"><a href="#虚电路服务" class="headerlink" title="虚电路服务"></a>虚电路服务</h4><ul>
<li>虚电路服务<ul>
<li>收发双方之间的路径如同电话线路一般</li>
<li>数据传输前，呼叫建立；传输结束后断开连接</li>
<li>每一个分组携带许电路的标识（而不是目的主机的地址）</li>
<li>路径上的每个路由器必须为进行中的连接维持连接状态信息</li>
<li>链路，路由器资源（带宽、缓冲区）可以分配给虚电路</li>
</ul>
</li>
<li>虚电路的组成<ul>
<li>从源到目的主机的路径</li>
<li>VC号，沿着该路径的每段链路的一个号码</li>
<li>沿着该路径的每台路由器中的转发表</li>
</ul>
</li>
</ul>
<h4 id="数据报服务"><a href="#数据报服务" class="headerlink" title="数据报服务"></a>数据报服务</h4><ul>
<li>数据报服务<ul>
<li>在网络层没有连接建立的过程</li>
<li>不维护连接状态信息</li>
<li>同一对主机间的报文可能会走不同的路径</li>
</ul>
</li>
</ul>
<h5 id="虚电路和数据报比较"><a href="#虚电路和数据报比较" class="headerlink" title="虚电路和数据报比较"></a>虚电路和数据报比较</h5><table>
<thead>
<tr>
<th align="left">虚电路网络</th>
<th align="left">数据报网络</th>
</tr>
</thead>
<tbody><tr>
<td align="left">聪明的网络，愚笨的终端</td>
<td align="left">简单的网络，复杂的终端</td>
</tr>
<tr>
<td align="left">保证速率和服务质量</td>
<td align="left">互联不同类型的网络更加容易</td>
</tr>
<tr>
<td align="left">定时维持状态</td>
<td align="left">启用新服务的速度更快，更简单</td>
</tr>
</tbody></table>
<h4 id="网络层与运输层相应服务的区别"><a href="#网络层与运输层相应服务的区别" class="headerlink" title="网络层与运输层相应服务的区别"></a>网络层与运输层相应服务的区别</h4><table>
<thead>
<tr>
<th align="left">网络层</th>
<th align="left">运输层</th>
</tr>
</thead>
<tbody><tr>
<td align="left">向运输层提供主机到主机的服务</td>
<td align="left">向应用层提供进程到进程的服务</td>
</tr>
<tr>
<td align="left">仅提供面向连接或面向无连接两种服务中的一种</td>
<td align="left">同时提供两种</td>
</tr>
<tr>
<td align="left">网络层的服务则在整个网络中实现，含路由器</td>
<td align="left">运输层的五福在网络边缘的端系统中实现</td>
</tr>
</tbody></table>
<h2 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h2><ul>
<li>数据包排队</li>
<li>交换单元：输入输出匹配</li>
<li>每次1个数据包从输入端口转交给输出端口，若要转交到相同输出端口，则一个通，其它阻塞</li>
</ul>
<h3 id="路由器输入端口"><a href="#路由器输入端口" class="headerlink" title="路由器输入端口"></a>路由器输入端口</h3><ul>
<li>物理层 –&gt; 线路端接口</li>
<li>数据链路层 –&gt; 数据链路处理（协议、拆封）</li>
<li>分散式交换 –&gt; 网络层处理（排队、查表、转发…）<ul>
<li>根据目的地址，输入端口内存中的路由选择表，查找确定输出端口</li>
<li>目标：以“线路速度”完成输入端口的处理</li>
<li>排队：若数据报到达速度超过端口到交换结构的转交速度，后续分组会暂时阻塞<ul>
<li>输出端口竞争时候会要排队</li>
<li>线头阻塞：输入队列中排队分组被位于线头的另一个分组阻塞，须等待交换结构发送</li>
<li>输入缓冲区溢出可导致排队时延和丢包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="路由器交换结构"><a href="#路由器交换结构" class="headerlink" title="路由器交换结构"></a>路由器交换结构</h3><ul>
<li>内存交换<ul>
<li>输入和输出端口间的交换是在路由器的直接控制下完成</li>
<li>分组被拷贝到系统内存中，在CPU的控制下转发至输出端口</li>
<li>转发速度受限于内存带宽（每个分组走两次总线）</li>
</ul>
</li>
<li>总线交换<ul>
<li>输入报文经共享总线将分组直接转发到输出端口</li>
<li>总线交换速度受限于总线带宽</li>
</ul>
</li>
<li>内联网络<ul>
<li>客服总线带宽限制</li>
<li>Banyan网络：用于计算机体系结构中多处理机互联</li>
<li>固定分组转发：将长度变化的IP分组拆分为固定尺寸的单元，通过交换网络进行转发</li>
</ul>
</li>
</ul>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><ul>
<li>缓存管理：当交换结构转交给输出端口的速率超过输出链路速率时</li>
<li>调度原则：在数据报队列中选则数据报进行传输</li>
<li>输出端口排队<ul>
<li>当通过交换结构到达的分组速率超过了输出链路的速率时，需要对分组进行缓存</li>
<li>输出端口缓冲区溢出会导致分组的排队和丢失</li>
</ul>
</li>
<li>缓存及排队策略<ul>
<li>对于有N条TCP链接经过的链路而言</li>
<li>$$ B &#x3D; \frac{RTT \times R}{\sqrt{N}} $$</li>
<li>调度策略<ul>
<li>先来先服务FCFS</li>
<li>加权公平排队WFQ</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存及排队策略"><a href="#缓存及排队策略" class="headerlink" title="缓存及排队策略"></a>缓存及排队策略</h3><ul>
<li>分组排队丢弃策略<ul>
<li>被动队列管理<ul>
<li>弃尾策略</li>
<li>删除一个或者多个已排队分组</li>
</ul>
</li>
<li>主动队列管理——随机早期检测RED<ul>
<li>随时计算平均队列长度$avg_{th}$</li>
<li>最小阈值$min_{th}$, 最大阈值$max_{th}$</li>
<li>$avg_{th}$小于$min_{th}$, 允许分组入列</li>
<li>$avg_{th}$大于$max_{th}$, 分组被标记或丢弃</li>
<li>$avg_{th}$在$min_{th}$和$max_{th}$之间，按照概率标记或丢弃分组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="路由表的内容"><a href="#路由表的内容" class="headerlink" title="路由表的内容"></a>路由表的内容</h5><table>
<thead>
<tr>
<th align="left">目的网络地址</th>
<th align="left">子网掩码</th>
<th align="left">下一跳</th>
</tr>
</thead>
<tbody><tr>
<td align="left">网络号的那个地址</td>
<td align="left">~</td>
<td align="left">既可以是接口，也可以是路由器</td>
</tr>
</tbody></table>
<h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><ul>
<li>版本<ul>
<li>4bit，如IPv4,IPv6，版本协议不同，无法通信</li>
</ul>
</li>
<li>服务类型<ul>
<li>8bit，用于服务质量保证</li>
<li>报文处理方式，每一位分别代表最小延时、最大吞吐量、最高可靠性、最小成本，只选一个</li>
<li>最新的服务类型6位定义区分服务，2位保留</li>
</ul>
</li>
<li>生存时间<ul>
<li>分组寿命管理，避免数据报进入循环路由无法退出</li>
<li>反映源目的主机之间数据报经历的跳数，每经过1个节点，跳数减1</li>
<li>不同系统，TTL默认最大取值不同</li>
</ul>
</li>
<li>首部检验和<ul>
<li>16bit，差错检测，只检验首部</li>
</ul>
</li>
<li>协议<ul>
<li>8bit，用于标识传输层地址或协议</li>
</ul>
</li>
<li>源地址: 32bit<ul>
<li>发送端标识，IP地址</li>
</ul>
</li>
<li>目的地址: 32bit<ul>
<li>接收端标识，IP地址</li>
</ul>
</li>
<li>报文长度相关字段<ul>
<li>首部长度: 4bit, 单位4字节，取值范围5-15，即20-40字节</li>
<li>总长度: 16bit, 单位是字节，取值范围0-65535，实际报文数据长度位总长度减去首部长度。以太网链路报文只允许1500字节</li>
</ul>
</li>
<li>分片相关字段<ul>
<li>标识: 16bit, 网络层服务的上层传输层的同义词报文（可能超过1500字），使用相同的标记，相当于每次会话使用相同标识</li>
<li>标志: 3bit，第1位保留；第2位表示是否能分片；第3位标识分片是否结束：1为未结束，0为结束</li>
<li>片偏移：每个分片在整个报文（分组）中的位置（8字节为度量单位）</li>
</ul>
</li>
<li>链路层帧大小有限，超过如何处理<ul>
<li>网络链路MTU（最大传输单位）有限<ul>
<li>不同类型的链路有不同的MTU值</li>
</ul>
</li>
<li>IP数据报需分片和重组<ul>
<li>将一个打数据报拆分为几个小数据报</li>
<li>重组只在目的主机进行</li>
<li>数据报首部的标识、标志以及片偏移三个字段用于分片和重组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ul>
<li>IP地址与接口有关，而与主机，路由器却没有太多关联</li>
<li>IP地址使用于主机、路由器内部和它们之间的物理链路和逻辑链路接口</li>
<li>IP地址是网络号+主机号形成的</li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left">适用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类</td>
<td align="left">0</td>
<td align="left">网络号</td>
<td align="left">主机号</td>
<td align="left">大型网络</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">B类</td>
<td align="left">10</td>
<td align="left">网络号</td>
<td align="left">主机号</td>
<td align="left">中型网络</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">C类</td>
<td align="left">110</td>
<td align="left">网络号</td>
<td align="left">主机号</td>
<td align="left">小型网络</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">D类</td>
<td align="left">1110</td>
<td align="left">组播地址</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">E类</td>
<td align="left">1111</td>
<td align="left">保留为今后使用</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>互联网中的IP地址<ul>
<li>在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。</li>
<li>路由器总是具有两个或以上的IP地址。路由器的每一个接口都有一个不同网络号的IP地址</li>
</ul>
</li>
<li>IPv4面临的问题<ul>
<li>地址空间消耗很快<ul>
<li>通过NAT减少了IP地址的需求量，间接扩大了IP地址的数量</li>
</ul>
</li>
<li>首部长度不定（20-60字节），中间节点（路由器）需要消耗相当资源用于分组处理</li>
<li>缺少QoS</li>
<li>安全性不够高</li>
</ul>
</li>
</ul>
<h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><ul>
<li>格式<ul>
<li>版本: 4bit</li>
<li>流量类型: 8bit</li>
<li>流标签: 20bit</li>
<li>有效载荷长度: 16bit</li>
<li>下一个首部: 8bit</li>
<li>跳限制: 8bit</li>
<li>源地址: 128bit</li>
<li>目的地址: 128bit</li>
<li>数据</li>
</ul>
</li>
<li>无检查和，中间节点无需计算</li>
<li>中间节点不再负责分片和重组，由端节点负责</li>
<li>首部长度固定，加速中间节点转发速度</li>
</ul>
<h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4><ul>
<li>双栈技术<ul>
<li>新加入的设备支持IPv4&#x2F;IPv6双协议栈</li>
<li>一段链路上，如果源和目标均支持IPv6，则使用IPv6进行通信</li>
<li>如果任一方不支持IPv6，则使用IPv4进行通信</li>
<li>可能会出现信息的丢失</li>
</ul>
</li>
<li>隧道技术</li>
</ul>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>将两级IP(网络号+主机号)的主机号部分，分靠前部分的几位出来作为子网号，变成三级IP(网络号+子网号+主机号)</p>
<p>子网掩码：将网络号和子网号相应的位置全置1，主机号相应位置全置0，即可得到子网掩码</p>
<p>划分子网时的网络地址就成为了<br>$$ IP &amp; 子网掩码 &#x3D; 网络地址 $$</p>
<h4 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h4><ul>
<li>对外隐藏子网的存在，对内指示网络号和子网络号的位置</li>
</ul>
<h4 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h4><ul>
<li>引入子网掩码后，路由器的寻址过程将演变成一个两级寻址过程<ul>
<li>检查目的IP地址的网络号</li>
<li>检查目的IP地址的子网号</li>
</ul>
</li>
</ul>
<h2 id="无类域间路由CIDR"><a href="#无类域间路由CIDR" class="headerlink" title="无类域间路由CIDR"></a>无类域间路由CIDR</h2><ul>
<li>CIDR编址格式<ul>
<li>IP地址 ::&#x3D; {&lt;网络前缀&gt;, &lt;主机号&gt;}</li>
<li>斜线记法: 192.168.0.1&#x2F;24</li>
<li>简写记法: 10.0.0.0&#x2F;10 -&gt; 10&#x2F;10</li>
</ul>
</li>
<li>CIDR寻址<ul>
<li>最长前缀匹配<ul>
<li>使用CIDR时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果</li>
<li>应当从匹配结果中选则具有最长网络前缀的路由：最长前缀匹配</li>
<li>网络前缀越长，其地址块就越小，因而路由就越具体</li>
<li>最长前缀匹配又成为最长匹配或最佳匹配</li>
</ul>
</li>
<li>CIDR路由匹配可能存在多个结果，这种时候就要选则最长前缀的地址</li>
</ul>
</li>
</ul>
<h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><ul>
<li>DHCP协议并不仅仅只能获取IP地址<ul>
<li>网关地址</li>
<li>DNS地址</li>
<li>子网掩码</li>
</ul>
</li>
</ul>
<h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><ul>
<li>为什么需要网络地址转换NAT<ul>
<li>外网获取的IP地址资源有限</li>
<li>内网IP地址变动无需告知外网</li>
<li>更换ISP后内网IP地址不变</li>
<li>内网主机外网资源不可见</li>
</ul>
</li>
<li>NAT的意义<ul>
<li>本地网络只要使用一个IP地址就可以和外部网络相连</li>
<li>不需要从ISP出获得大批IP地址：所有设备可以使用同一个IP地址</li>
<li>可以在不通知外部网络的情况下改变内网主机的IP地址</li>
<li>即使改变了ISP也无须改变内网主机的IP地址</li>
<li>内网主机对外网主机而言是不可见的、不可寻址的</li>
</ul>
</li>
<li>NAT的实现<ul>
<li>发送数据报：将每个外出报文的源IP地址，端口号替换为NAT  IP地址以及新的端口号<ul>
<li>远程客户机&#x2F;服务器将以NAT IP地址以及新的端口号作为目的地址进行相应</li>
</ul>
</li>
<li>记住每一个地址转换对（在NAT转发表中），即(源IP地址, 端口号) -&gt; (NAT IP地址, 新的端口)</li>
<li>接收数据报：根据NAT转换表将每个进入报文的NAT IP地址，端口号替换为相应的源IP地址以及端口号</li>
</ul>
</li>
<li>NAT中的本地地址：<ul>
<li>10&#x2F;8</li>
<li>172.16&#x2F;12</li>
<li>192.168&#x2F;16</li>
</ul>
</li>
<li>三种地址转换方式<ul>
<li>静态NAT：一个本地地址对应一个全球地址</li>
<li>动态NAT：一个全球地址对应多个本地地址</li>
<li>端口NAT：一个本地地址的端口对应到一个全球地址的端口</li>
</ul>
</li>
<li>NAT内网访问方案<ul>
<li>端口映射：采用端口NAT，在路由器中静态的为服务器配置一条记录</li>
<li>通用即插即用UPnP(用于P2P)<ul>
<li>内部主机通过IGD协议了解公共IP地址<ul>
<li>向路由器注册&#x2F;移除映射记录 (内部IP, 内部端口) -&gt; (公共IP, 公共端口)</li>
</ul>
</li>
<li>内部主机向外部公开(公共IP， 公共端口)</li>
</ul>
</li>
<li>中继(用于Skype)</li>
</ul>
</li>
<li>NAT带来的争议<ul>
<li>端口号应该用于进程编址，而飞用于主机编址</li>
<li>路由器仅应当处理高达第三层的分组</li>
<li>NAT协议违反了端到端原则，中间节点不应介入</li>
<li>应使用IPv6来解决IP短缺的问题</li>
</ul>
</li>
</ul>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><ul>
<li>为什么需要ICMP<ul>
<li>IP数据报逐段转发</li>
<li>IP数据报非可靠传输</li>
<li>网络状态不可知</li>
</ul>
</li>
<li>ICMP的作用<ul>
<li>错误报告</li>
<li>请求&#x2F;应答</li>
<li>报文控制</li>
</ul>
</li>
</ul>
<h4 id="ICMP协议报文分类"><a href="#ICMP协议报文分类" class="headerlink" title="ICMP协议报文分类"></a>ICMP协议报文分类</h4><ul>
<li>差错于控制报文协议ICMP<ul>
<li>差错报告报文<ul>
<li>信息不可到达报告</li>
<li>超时报告</li>
<li>参数出错报告</li>
</ul>
</li>
<li>控制报文<ul>
<li>源抑制报文</li>
<li>重定向报文</li>
</ul>
</li>
<li>请求&#x2F;应答报文<ul>
<li>回应请求&#x2F;应答报文</li>
<li>时间戳请求&#x2F;应答报文</li>
<li>地址模请求&#x2F;应答报文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h4><p>前4个字节统一都是类型(1字节)代码(1字节)检验和(2字节)</p>
<p>ICMP报文封装在IP组中</p>
<p>ICMP消息：一个类型字段和一个编码字段</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">代码</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">回声回答（对ping的回答）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">目的主机不可达</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">目的协议不可达</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">3</td>
<td align="left">目的端口不可达</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">6</td>
<td align="left">目的网络未知</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">7</td>
<td align="left">目的主机未知</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">0</td>
<td align="left">源抑制（拥塞控制，未用）</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">0</td>
<td align="left">回声请求（ping）</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">0</td>
<td align="left">路由器通告</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">0</td>
<td align="left">路由器发现</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">0</td>
<td align="left">TTL过期</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">0</td>
<td align="left">IP首部错误</td>
</tr>
</tbody></table>
<h5 id="信息报文不可达"><a href="#信息报文不可达" class="headerlink" title="信息报文不可达"></a>信息报文不可达</h5><ul>
<li>信宿机硬件出现故障或关机</li>
<li>发送者指定的地址不存在</li>
<li>网关不知道去往信宿的路径</li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型(3)</th>
<th align="left">码(0-12)</th>
<th align="left">校验和</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未用(全0)</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">出错数据报报头+前64bit数据</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">…</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="参数出错报文"><a href="#参数出错报文" class="headerlink" title="参数出错报文"></a>参数出错报文</h5><ul>
<li><p>路由器或信宿机在丢弃参数出错的报文时</p>
<table>
<thead>
<tr>
<th align="left">类型(12)</th>
<th align="left">码(0或1)</th>
<th align="left">校验和</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指针</td>
<td align="left">未用(全0)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">出错数据报报头+前64bit数据</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">…</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
<li><p>0：数据报某个参数错，指针域指向出错字节</p>
</li>
<li><p>1：数据报缺少某个选项，无指针域</p>
</li>
</ul>
<h5 id="重定向报文"><a href="#重定向报文" class="headerlink" title="重定向报文"></a>重定向报文</h5><ul>
<li>路由转发过程中发现源主机可以将报文直接发送给下游路由节点</li>
</ul>
<p>|类型(5)|码(0-3)|校验和|<br>|网关IP地址|<br>|数据报包头+前64bit数据|<br>|?…|</p>
<ul>
<li>1：对主机重定向报文</li>
<li>2：对服务类型和网络的重定向报文</li>
<li>3：对服务类型和主机的重定向报文</li>
</ul>
<p>ICMP差错报告与控制报文是单项传输的报文</p>
<h4 id="ICMP协议的应用"><a href="#ICMP协议的应用" class="headerlink" title="ICMP协议的应用"></a>ICMP协议的应用</h4><ul>
<li>ping：使用ICMP回送和应答消息来确定一台主机是否可达</li>
<li>tracert：确定到目的地主机的确切路由器</li>
</ul>
<h2 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h2><ul>
<li>概念<ul>
<li>默认路由器：一台主机“直接”连接到的路由器</li>
<li>源路由器：源主机的默认路由器</li>
<li>目的路由器：目标主机的默认路由器</li>
</ul>
</li>
<li>选路算法的目的：给定一组路由器以及连接路由器的链路，从中找到一条从源路由器到目标路由器的“好的”的路径<ul>
<li>“好的”通常指具有最低费用的路径</li>
</ul>
</li>
<li>选路算法分类<ul>
<li>根据信息是全局性还是分散式的进行分类<ul>
<li>全局选路算法<ul>
<li>所有路由器都直到整个网络拓扑图以及链路的费用信息</li>
<li>链路状态算法</li>
</ul>
</li>
<li>分散式选路算法<ul>
<li>每个路由器仅有与其相连链路的费用信息</li>
<li>通过迭代计算过程与相邻节点交换信息</li>
<li>距离向量算法</li>
</ul>
</li>
</ul>
</li>
<li>根据信息是静态还是动态的进行分类<ul>
<li>静态选路算法<ul>
<li>随着时间的流逝，路由的变化非常缓慢</li>
</ul>
</li>
<li>动态选路算法<ul>
<li>路由信息可以更快的发生变化</li>
<li>周期性的更新</li>
<li>可以相依你个拓扑或链路费用的变化</li>
</ul>
</li>
</ul>
</li>
<li>根据是否对负载敏感进行分类<ul>
<li>负载敏感算法<ul>
<li>链路费用会动态地变化以反应出链路当前的状况</li>
</ul>
</li>
<li>负载迟钝算法<ul>
<li>链路费用不明显地反应链路当前状况</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="链路状态选路算法"><a href="#链路状态选路算法" class="headerlink" title="链路状态选路算法"></a>链路状态选路算法</h3><h4 id="Dijkstra’s算法"><a href="#Dijkstra’s算法" class="headerlink" title="Dijkstra’s算法"></a>Dijkstra’s算法</h4><ul>
<li>所有节点都直到网络拓扑和链路费用<ul>
<li>通过链路状态广播获得信息</li>
<li>所有节点具有该网络的同一个完整的视图</li>
</ul>
</li>
<li>计算从某节点到网络中所有其它节点的最低费用<ul>
<li>为该节点提供转发表</li>
</ul>
</li>
<li>迭代：经过算法的K次迭代后，可直到到K个目的节点的最低费用路径</li>
<li>符号定义<ul>
<li><code>c(x, y)</code>：从节点x到节点y的链路费用；如果x和y不是直连的，则$c(x, y) &#x3D; \infty$</li>
<li><code>D(v)</code>：随着算法进行本次迭代，从源节点到目的v的最低费用路径的费用</li>
<li><code>p(v)</code>：从源节点到v沿着当前最低费用路径的前以节点</li>
<li><code>N&#39;</code>：节点子集。v在<code>N&#39;</code>中，如果从源节点到路径的最低费用路径已知<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">N&#x27; = &#123;u&#125;</span><br><span class="line">for all nodes in v</span><br><span class="line">  if v adjacent to u</span><br><span class="line">    then D(v) = c(u, v)</span><br><span class="line">  else D(v) = inf</span><br><span class="line"></span><br><span class="line">Loop</span><br><span class="line">  find w not in N&#x27; such that D(w) is a minimum</span><br><span class="line">    add w to N&#x27;</span><br><span class="line">    update D(v) for all v adjacent to w and not in N&#x27;</span><br><span class="line">      D(v) = min( D(v), D(w) + c(w, v) )</span><br><span class="line">until all nodes in N&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>算法复杂性<ul>
<li>对于第一次迭代：需要搜索所有的n个节点以确定出节点w，w不在N’中切具有最低费用</li>
<li>在所有迭代中需要搜索的节点总数为$\frac{n(n+1)}{2}$，所以链路状态算法在最差情况下复杂性为$O(n^2)$</li>
<li>该算法的一种更复杂的实现，使用了堆，其计算复杂性为$O(m log n)$</li>
</ul>
</li>
<li>存在的问题<ul>
<li>虽然算法本身没有问题，但是如果完全纯粹依赖dijkstra，可能导致有的链路负载过大，有的链路又空闲</li>
<li>解决方案<ul>
<li>强制链路费用不依赖于所承载的流量<ul>
<li>无法解决高拥塞的问题，不可不可接受</li>
</ul>
</li>
<li>确保所有的路由器不同时运行LS算法<ul>
<li>因特网上的路由器能够自同步</li>
<li>随机化路由器发送链路通告的时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="因特网中的链路状态选路——OSPF协议"><a href="#因特网中的链路状态选路——OSPF协议" class="headerlink" title="因特网中的链路状态选路——OSPF协议"></a>因特网中的链路状态选路——OSPF协议</h4><ul>
<li><p>协议交互范围及方法</p>
<ul>
<li>OSPF协议消息限于本自治系统域内</li>
<li>OSPF协议消息采用泛洪发送</li>
</ul>
</li>
<li><p>协议交互信息内容</p>
<ul>
<li>与本路由器相邻的所有路由器的链路状态</li>
</ul>
</li>
<li><p>协议交互时机</p>
<ul>
<li>仅当链路状态发生变化时，采用泛洪法向所有路由器发送信息</li>
</ul>
</li>
<li><p>OSPF路由协议相关链路状态数据库</p>
<ul>
<li>路由器之间频繁的交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库</li>
<li>链路状态数据库实际上就是全网拓扑结构图，它在全网范围内是一致的</li>
<li>OSPF的链路有状态数据库能较快的进行更新，使各个路由器能及时更新其路由表。OSPF的更新过程收敛得快是其重要优点</li>
</ul>
</li>
<li><p>OSPF如何保证所有节点知道网络拓扑和链路费用？</p>
<ul>
<li>洪泛法：本路由向本AS中所有路由器发送信息</li>
<li>消息内容：与本路由器相邻的所有路由器的链路状态</li>
<li>发送时机：当链路状态发生变化时开始发送</li>
</ul>
</li>
<li><p>链路状态数据库的优缺点</p>
<ul>
<li>所有路由器上均有全网一致的拓扑结构图</li>
<li>更新过程收敛较快</li>
<li>但是数据库存储空间占用很大</li>
<li>最小生成树耗时大</li>
<li>拓扑变化导致网络动荡</li>
</ul>
</li>
<li><p>OSPF的补充说明</p>
<ul>
<li>不强制如何设置链路有权值的策略，但提供对给定链路权值集合确定最低费用路径的机制</li>
<li>即使链路状态未发生变化，每30分钟广播一次链路状态</li>
<li>链路状态以OSPF通告的形式封装在包尔维尼中，由IP分组承担（协议号：89）</li>
<li>OSPF路由器之间的交换都是经过鉴别的（简单的、MD5的），以确认OSPF通告的真实性，防止伪造和篡改</li>
<li>OSPF通告都是有序列号的，以防止重放攻击</li>
<li>OSPF中支持多条具有相同费用的路径</li>
<li>OSPF支持多播选路和层次路由</li>
</ul>
</li>
</ul>
<h3 id="距离向量选路算法"><a href="#距离向量选路算法" class="headerlink" title="距离向量选路算法"></a>距离向量选路算法</h3><p>距离向量的计算<br>$$ d_x(y) &#x3D; min_v {c(x, v) + d_v(y) } $$<br>x到y的最短距离，等于在所有与x相邻的点的距离，分别加上这些相邻点到y点的距离 （就是一个递归）</p>
<ul>
<li>RIP路由表更新算法<ul>
<li>路由器X得到相邻路由器Y的路由表，从而得知：Y到网络Z的最短距离为N</li>
<li>如果路由器X没有到网络Z的路由条目，则添加一条经由路由器Y到网络Z距离N+1的路由条目</li>
<li>如果路由器X已有到网络Z的路由条目，其距离为M，如果$M &gt; N+1$，则更新该条目为经由路由器Y到网络Z并且距离为N+1，否则不更新</li>
</ul>
</li>
<li>链路状态改变时的特点<ul>
<li>好消息传得快</li>
<li>坏消息传得慢<ul>
<li>无穷计数</li>
<li>路由环路</li>
</ul>
</li>
</ul>
</li>
<li>RIP协议重要参数<ul>
<li>链路费用：相邻两点链路费用为1“跳”，最大费用限制为15</li>
<li>通告周期：选路更新通告周期为30秒</li>
<li>邻居离线：邻居离线判定周期为180秒</li>
<li>协议端口：基于UDP，端口为520</li>
</ul>
</li>
</ul>
<h3 id="LS-VS-DV"><a href="#LS-VS-DV" class="headerlink" title="LS VS DV"></a>LS VS DV</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">LS</th>
<th align="left">DV</th>
</tr>
</thead>
<tbody><tr>
<td align="left">报文数量</td>
<td align="left">n个节点，E条链路$O(nE)$</td>
<td align="left">只在直连的邻居之间交换报文取决于邻居数</td>
</tr>
<tr>
<td align="left">收敛速度</td>
<td align="left">$O(n^2)$，可能震荡</td>
<td align="left">路由环路，无穷计数</td>
</tr>
<tr>
<td align="left">健壮性</td>
<td align="left">节点能够向其连接的链路，广播不正确费用，独立计算路由表</td>
<td align="left">一个节点可向任意或所有目的节点通告其不正确的最低费用路径。每个节点的计算都会传递给它的邻居，错误被传播</td>
</tr>
</tbody></table>
<h2 id="BGP-4协议"><a href="#BGP-4协议" class="headerlink" title="BGP-4协议"></a>BGP-4协议</h2><ul>
<li>层次路由<ul>
<li>因特网规模过大<ul>
<li>路由器无法存储每台主机的选路信息</li>
<li>路由表更新的报文广播将导致无剩余带宽发送数据使用</li>
</ul>
</li>
<li>管理自治<ul>
<li>因特网&#x3D;网络的网络</li>
<li>每个网络管理员可能希望能够按自己的愿望运行和管理其网络</li>
</ul>
</li>
<li>解决方案<ul>
<li>将路由器聚合到一个区域，“自治系统”(AS)</li>
<li>在相同AS内的路由器可全部运行同样的选路算法</li>
</ul>
</li>
<li>自治系统内部选路协议<ul>
<li>内部网关协议IGP(Interior Gateway Protocal)，目前这类路由选则协议使用的最多，如RIP和OSPF</li>
</ul>
</li>
<li>在不同AS内的路由器可以运行不同的自治系统内部选路协议</li>
</ul>
</li>
</ul>
<h4 id="层次路由——转发选路算法"><a href="#层次路由——转发选路算法" class="headerlink" title="层次路由——转发选路算法"></a>层次路由——转发选路算法</h4><ul>
<li>转发表是由AS内部选路算法和AS间选路算法共同决定的<ul>
<li>AS内部选路算法为内部目的地址设置转发表信息</li>
<li>AS内部选路算法和AS间选路算法共同为外部目的地址设置转发表信息</li>
</ul>
</li>
<li>自治系统间路由器的任务<ul>
<li>当从源到目标有多条选路可走时，转发表必须能够确定路径</li>
<li>热土豆选路：选则具有最小最低费用的网关</li>
</ul>
</li>
<li>层次路由——层次OSPF<ul>
<li>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域</li>
<li>每一个区域都有一个32bit的区域标识符</li>
<li>区域也不能太大，在一个区域内的路由器最好不要超过200个</li>
<li>划分区域<ul>
<li>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量</li>
<li>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其它区域的网络拓扑的情况</li>
<li>OSPF使用层次结构的区域划分。在上层的区域叫做主干区域(backbone area)。主干区域的标识符规定为0.0.0.0.主干区域的作用是用来连同其它在下层的区域。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="因特网上的AS间路由——BGP4"><a href="#因特网上的AS间路由——BGP4" class="headerlink" title="因特网上的AS间路由——BGP4"></a>因特网上的AS间路由——BGP4</h3><ul>
<li>因特网的规模太大，使得自治系统之间路由选则非常困难<ul>
<li>对于自治系统之间的路由选则，要寻找最佳路由是很不现实的</li>
<li>自治系统之间的路由选则必须考虑技术无关的一些策略</li>
</ul>
</li>
<li>BGP为每个AS提供一种手段，以处理<ul>
<li>从相邻AS获取子网可达性信息</li>
<li>向该AS内部的所有路由器传播这些可达性信息</li>
<li>基于该可达性信息和AS策略，决定到达子网的“好”路由<ul>
<li>边界网关协议BGP只能是力求寻找一条能够 到达目的网络切比较好的路由（不能兜圈子），而非寻找一条最佳路由</li>
</ul>
</li>
</ul>
</li>
<li>BPG-4与BGP发言人<ul>
<li>每一个AS要选则一个路由器作为该AS的“BGP发言人”</li>
<li>两个BGP发言人通过一个共享网络连接在一起的</li>
</ul>
</li>
<li>BPG路由通告<ul>
<li>当一个路由器得知一个新前缀，它为该前缀在其转发表中创建一个表项</li>
<li>BPG消息中会包含“路由”<ul>
<li>“路由”包括前缀和属性：AS-PATH, NETX-HOP</li>
</ul>
</li>
</ul>
</li>
<li>BPG路由选则<ul>
<li>当有两条或者更多条最佳域间路由</li>
<li>采用热土豆思想选则距离NEXT-HOP最近的路由<ul>
<li>采用IGP确定哪个边界路由器是最近的</li>
</ul>
</li>
<li>获取NEXT-HOP属性</li>
<li>获取最短路径</li>
<li>确定端口，加入转发表</li>
</ul>
</li>
</ul>
<h2 id="路由协议总结"><a href="#路由协议总结" class="headerlink" title="路由协议总结"></a>路由协议总结</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">RIP</th>
<th align="left">OSPF</th>
<th align="left">BGP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议类型</td>
<td align="left">IGP</td>
<td align="left">IGP</td>
<td align="left">EGP</td>
</tr>
<tr>
<td align="left">信息表达格式</td>
<td align="left">距离-向量协议</td>
<td align="left">链路-状态协议</td>
<td align="left">路径向量</td>
</tr>
<tr>
<td align="left">交换信息范围</td>
<td align="left">相邻路由器</td>
<td align="left">自治系统或区域内路由器</td>
<td align="left">BGP发言人</td>
</tr>
<tr>
<td align="left">交换信息内容</td>
<td align="left">路由表</td>
<td align="left">链路状态</td>
<td align="left">路径向量</td>
</tr>
<tr>
<td align="left">交换信息时间</td>
<td align="left">每30秒</td>
<td align="left">当链路状态变化</td>
<td align="left">有变化</td>
</tr>
<tr>
<td align="left">原则</td>
<td align="left">最短路径</td>
<td align="left">最小代价</td>
<td align="left">可达性</td>
</tr>
<tr>
<td align="left">收敛过程</td>
<td align="left">较快</td>
<td align="left">快</td>
<td align="left">快</td>
</tr>
<tr>
<td align="left">传输协议</td>
<td align="left">UDP</td>
<td align="left">IP</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">适用网络类型</td>
<td align="left">小型网络</td>
<td align="left">大型网络</td>
<td align="left">自治系统之间</td>
</tr>
<tr>
<td align="left">衡量标准</td>
<td align="left">距离</td>
<td align="left">可有多种度量标准</td>
<td align="left">无</td>
</tr>
</tbody></table>
<h1 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h1><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><ul>
<li>术语<ul>
<li>节点：主机和路由器</li>
<li>链路：沿着通信路径连接相邻节点的通信信道<ul>
<li>有线链路</li>
<li>无线链路</li>
</ul>
</li>
<li>帧：链路层的分组单元<ul>
<li>链路层负责将数据报封装成帧通过链路从一个节点传输到物理上相邻的下一个节点</li>
</ul>
</li>
</ul>
</li>
<li>特别说明<ul>
<li>数据报在不同链路上可能由不同的链路层协议进行处理</li>
<li>不同的链路层协议可能提供不同的服务</li>
</ul>
</li>
</ul>
<h4 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h4><ul>
<li>成帧、链路访问<ul>
<li>将数据加上头部和尾部，封装成数据帧</li>
<li>共享介质的信道访问</li>
<li>帧头部用MAC地址标识源和目的（不同于IP地址）</li>
</ul>
</li>
<li>可靠传递<ul>
<li>很少用于误码率低的电路（光纤、双绞线链路）</li>
<li>用于误码率高的链路（无线链路）</li>
</ul>
</li>
<li>流量控制<ul>
<li>在相邻的收发节点间限制流量</li>
</ul>
</li>
<li>差错检测<ul>
<li>信号衰减和电磁干扰噪声导致出错</li>
<li>接收方检测到错误存在：给发送方发送信号要求重传或丢弃该数据帧</li>
</ul>
</li>
<li>差错纠正<ul>
<li>接收方检测和纠正帧中错误，不用重传</li>
</ul>
</li>
<li>半双工和全双工<ul>
<li>半双工时，链路两端的节点都能传输分组，但不能同时传输</li>
</ul>
</li>
</ul>
<h4 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h4><ul>
<li>在每一台设备上（主机、交换机、路由器）</li>
<li>链路层在“适配器”（网卡NIC）或者芯片上实现</li>
<li>直接于主机的系统总线相连</li>
<li>是硬件、软件和固件的结合体</li>
</ul>
<h4 id="适配器通信"><a href="#适配器通信" class="headerlink" title="适配器通信"></a>适配器通信</h4><ul>
<li>发送方<ul>
<li>在一个帧内封装数据报</li>
<li>增加差错检测位，可靠交付，流量检测等</li>
</ul>
</li>
<li>接收方<ul>
<li>查找错误，可靠交付，流量控制等</li>
<li>取出数据报，交给网络层</li>
</ul>
</li>
<li>适配器是半自治单元<ul>
<li>帧的接收和发送、检错、丢弃均是自主进行</li>
<li>向上提交数据时，需要节点干预</li>
<li>最终受控于节点</li>
</ul>
</li>
</ul>
<h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><h4 id="因特网检查和"><a href="#因特网检查和" class="headerlink" title="因特网检查和"></a>因特网检查和</h4><ul>
<li>发送方<ul>
<li>将数据段的内容作为16bit的整数序列</li>
<li>校验和：累加求和，计算和的1的补码</li>
<li>发送方将得到的校验和值放入PDU校验和字段</li>
</ul>
</li>
<li>接收方<ul>
<li>计算收到的数据段的校验和</li>
<li>检查计算出的校验和于校验和字段中的值是否相同<ul>
<li>NO——检测到错误</li>
<li>YES——没有错误</li>
</ul>
</li>
</ul>
</li>
<li>特别注意<ul>
<li>仅用于TCP, UDP和IPv4</li>
</ul>
</li>
</ul>
<h4 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h4><ul>
<li>d比特的数据D</li>
<li>选则r+1比特模式（生成多项式），表示为G</li>
<li>目标：选则r个CRC比特，R，以便<ul>
<li>&lt;D, R&gt;恰好额能够被G整除（模2计算）</li>
<li>接收方一致G，用G去除&lt;D, R&gt;，若余数非0，则检测到错误</li>
<li>能检测到所有少于r+1比特的错误</li>
</ul>
</li>
<li>在实践中被广泛应用（以太网、802.11 WiFi, ATM）</li>
</ul>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><h4 id="两种链路"><a href="#两种链路" class="headerlink" title="两种链路"></a>两种链路</h4><ul>
<li>点到点链路<ul>
<li>PPP&#x2F;以太网交换机和主机之间的点到点链路</li>
</ul>
</li>
<li>广播链路（共享线路或介质）<ul>
<li>传统以太网&#x2F;802.11 无线LAN</li>
<li>特点<ul>
<li>单个共享广播信道</li>
<li>两个或多个节点同时传输：相互干扰</li>
</ul>
</li>
<li>碰撞：一个节点同时收到两个或多个信号</li>
</ul>
</li>
</ul>
<h3 id="多址访问协议"><a href="#多址访问协议" class="headerlink" title="多址访问协议"></a>多址访问协议</h3><ul>
<li>分布式算法巨野顶节点如何共享信道，如节点何时可以传输数据</li>
<li>特别注意：有共享信道的通信（协商）需使用信道本身<ul>
<li>没有额外的信道来进行协调</li>
</ul>
</li>
<li>理想的多址访问协议需要满足<ul>
<li>假定：信道为速率为R b&#x2F;s的广播信道</li>
<li>当只有一个节点有数据发送时，该节点的吞吐量为R</li>
<li>当M个节点有数据发送时，每个节点吞吐量为R&#x2F;M</li>
<li>全分散控制<ul>
<li>没有特定节点用于调整传输</li>
<li>没有始终同步</li>
</ul>
</li>
<li>简单</li>
</ul>
</li>
<li>分类<ul>
<li>信道划分协议<ul>
<li>将信道划分成小的“片”（时隙、频率、编码）</li>
<li>将“片”分配给节点使用</li>
</ul>
</li>
<li>随机访问协议<ul>
<li>信道没有被分隔，允许碰撞</li>
<li>碰撞恢复</li>
</ul>
</li>
<li>轮流协议<ul>
<li>节点轮流传送，但数据量大的节点轮流更长实践</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><ul>
<li>TDMA(Time Division Multiple Access)<ul>
<li>循环访问信道</li>
<li>每个节点在每次循环中得到固定长度的时隙（时隙长度&#x3D;传输单个分组实践）</li>
<li>没有数据发送的时隙空闲</li>
</ul>
</li>
<li>FDMA(Frequnce Division Multiple Access)<ul>
<li>信道按频谱分成若干频段</li>
<li>每个节点分配固定频段</li>
<li>在频段不用时该部分信道被闲置和浪费</li>
</ul>
</li>
</ul>
<h4 id="随机访问协议"><a href="#随机访问协议" class="headerlink" title="随机访问协议"></a>随机访问协议</h4><ul>
<li>当节点有数据发送时<ul>
<li>以信道全部速率R传入</li>
<li>没有主节点起协调作用</li>
</ul>
</li>
<li>两个或多个节点传送时——碰撞</li>
<li>随机访问协议解决<ul>
<li>如何检测碰撞</li>
<li>如何从碰撞中恢复（如：延时后重传）</li>
</ul>
</li>
<li>随机访问协议举例<ul>
<li>ALOHA、时隙ALOHA</li>
<li>CSMA, CSMA&#x2F;CD, CSMA&#x2F;CA</li>
</ul>
</li>
</ul>
<h5 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h5><ul>
<li>Additive Link On-Line HAwaii system</li>
<li>因群岛未知的散布，网络拓扑采用了星型结构</li>
<li>为节省费用和易于组网，网络中各站点的通信采用了无线传输截至</li>
<li>由于采用无线电信道，考虑到无法申请更多的频率点，因而所有站点都使用统一的频率通过主机交换信息</li>
</ul>
<p>纯ALOHA的工作效率 $\frac{1}{2e} &#x3D; 0.18$<br>$$<br>P(给定节点成功概率) &#x3D; P(给定节点传送) * P(在[t0-1,t0]没其它节点传送) * P(在[t0, t0+1]没其它节点传送)<br>$$<br>$$<br> &#x3D; p * (1-p)^{N-1} * (1-p)^{N-1}<br>$$<br>$$<br> &#x3D; p * (1-p)^{2(N-1)}<br>$$</p>
<p>时隙ALOHA的工作效率 $\frac{1}{e} &#x3D; 0.37$<br>$$ P(给定节点成功概率) &#x3D; P(给定节点传送) * P(没有其它节点传送) $$<br>$$ &#x3D; p * (1-p){N-1} $$</p>
<h5 id="载波监听CSMA"><a href="#载波监听CSMA" class="headerlink" title="载波监听CSMA"></a>载波监听CSMA</h5><ul>
<li>传输前监听<ul>
<li>如果信道空闲，传送整个帧</li>
<li>如果信道忙，推迟传送</li>
</ul>
</li>
<li>分类<ul>
<li>非坚持CSMA<ul>
<li>一旦监听到信道忙（即发送有其它站在发送数据），就不再坚持监听下去，而是根据协议的算法延迟一个随机的时间后重新再监听。若进行载波监听时发现信道空闲，则将准备好的帧发送出去</li>
</ul>
</li>
<li>时隙非坚持CSMA<ul>
<li>采用划分时隙的随机接入CSMA协议，协议规定只能再每个时隙开始时才能发送帧率</li>
</ul>
</li>
<li>l坚持CSMA<ul>
<li>当一个站点要传送数据时，首先侦听信道，看是否有其它站点正在传送。如果信道正忙，它就持续等待直到它侦听到信道空闲时，便将数据送出。如发生冲突，站点就等待一个随机长的时间，然后重新开始</li>
</ul>
</li>
<li>P坚持CSMA<ul>
<li>当一个站点要传送数据时，首先侦听信道，看是否有其它站点正在传送。如果信道正忙，它就持续等待直到它侦听到信道空闲时，以概率P发送数据，而以高铝(1-P)延迟一段时间$\tau$（网络中最远的端到端的传播时延），重新监听信道。若发生冲突，站点就等待一个随机长的时间，然后重新开始</li>
</ul>
</li>
</ul>
</li>
<li>比较<ul>
<li>非坚持：不能充分利用信道刚刚转入空闲期的这段时间</li>
<li>l坚持：容易再上述时间产生冲突</li>
<li>P坚持：可以在一定程度上客服这些缺点，但却很难选则一个能用于各种通信量强度的P值，所以在实际网络中常选则l坚持</li>
</ul>
</li>
</ul>
<h5 id="带冲突检测的载波侦听CSMA-CD"><a href="#带冲突检测的载波侦听CSMA-CD" class="headerlink" title="带冲突检测的载波侦听CSMA&#x2F;CD"></a>带冲突检测的载波侦听CSMA&#x2F;CD</h5><ul>
<li>在短时间内碰撞被检测<ul>
<li>在有线LANs中比较容易：测量信号强度，比较收、发信号</li>
<li>在无线LANs中比较困难：传输时接收器是关闭的</li>
</ul>
</li>
<li>碰撞后停止传输，减少信道浪费</li>
<li>强化碰撞：<ul>
<li>当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送若干比特的认为干扰信号，以便让所有用户都直到现在已经发生了碰撞</li>
</ul>
</li>
<li>争用期<ul>
<li>最先发送数据帧的站，再发送数据帧后至多经过时间$2\tau$（两倍端到端往返时延）就可以知道发送的数据帧是否遭受了碰撞</li>
<li>以太网的端到端往返时延$2\tau$成为争用期，或碰撞窗口</li>
<li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</li>
</ul>
</li>
</ul>
<h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><h5 id="与其它协议的比较"><a href="#与其它协议的比较" class="headerlink" title="与其它协议的比较"></a>与其它协议的比较</h5><ul>
<li>信道划分协议<ul>
<li>在重负荷时<ul>
<li>共享信道有效、公平</li>
</ul>
</li>
<li>在轻负荷时效率低<ul>
<li>信道访问延时，即使只有一个活动节点，也只能分配到$\frac{1}{N}$的带宽</li>
</ul>
</li>
</ul>
</li>
<li>随机访问协议<ul>
<li>轻负荷时效率高<ul>
<li>只有一个节点时，能充分利用信道</li>
</ul>
</li>
<li>在重负荷下<ul>
<li>碰撞的开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h5><ul>
<li>主节点邀请从节点轮流传输</li>
<li>关注<ul>
<li>轮询开销</li>
<li>等待时间</li>
<li>单点失效（主节点）</li>
</ul>
</li>
</ul>
<h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h5><ul>
<li>控制令牌一次通过各个节点</li>
<li>令牌报文</li>
<li>关注<ul>
<li>令牌的开销</li>
<li>等待时间</li>
<li>单点失效(token)</li>
</ul>
</li>
</ul>
<h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul>
<li>组成<ul>
<li>48bit</li>
<li>前24bit由IEEE分配管理——OUI号</li>
<li>后24bit由厂商自行分配</li>
</ul>
</li>
<li>作用<ul>
<li>在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点</li>
<li>MAC地址烧入网络适配器的ROM中，不可更改</li>
</ul>
</li>
<li>与IP地址的比较<ul>
<li>MAC地址是平面地址，类似身份证号</li>
<li>IP地址是层次地址，类似邮政编码</li>
<li>在不同的网络间迁移时，MAC地址不会改变</li>
<li>IP地址需要改变以适应新的网络配置</li>
</ul>
</li>
</ul>
<h3 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议(ARP)"></a>地址解析协议(ARP)</h3><ul>
<li>目标<ul>
<li>根据目标的IP地址获取其MAC地址</li>
</ul>
</li>
<li>ARP高速缓存<ul>
<li>局域网节点的IP&#x2F;MAC地址映射</li>
<li><code>&lt;IP; MAC; TTL&gt;</code></li>
<li>TTL (Time To Live): 超过TTL的地址映射会被删除（一般20分钟）</li>
</ul>
</li>
</ul>
<h5 id="同一局域网内工作流程"><a href="#同一局域网内工作流程" class="headerlink" title="同一局域网内工作流程"></a>同一局域网内工作流程</h5><ul>
<li>建立ARP请求包</li>
<li>广播发送该ARP请求包</li>
<li>目的IP的主机收到该ARP请求包，建立包含自己MAC地址的ARP应答包（注意，应答包和请求包的源、目标不一致。源始终是发出包的主机的）</li>
<li>直接向目的IP的主机发送该ARP应答包</li>
<li>目的IP更新ARP高速缓存</li>
</ul>
<h5 id="局域网间工作流程"><a href="#局域网间工作流程" class="headerlink" title="局域网间工作流程"></a>局域网间工作流程</h5><h5 id="互联网环境下的ARP"><a href="#互联网环境下的ARP" class="headerlink" title="互联网环境下的ARP"></a>互联网环境下的ARP</h5><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li>类型<ul>
<li>总线式以太网</li>
<li>交换式以太网</li>
</ul>
</li>
<li>帧结构<ul>
<li>数据字段：（46字节，1500字节）</li>
<li>前同步码<ul>
<li>总共8字节，前7字节的格式为10101010，最后一个字节格式为10101011</li>
<li>用于同步发送方与接收方始终</li>
</ul>
</li>
<li>地址：6字节<ul>
<li>若适配器收到以太网帧，目的地址为自己的MAC地址或广播地址（如ARP包），就将帧中的数据传递给网络层</li>
<li>否则，适配器丢弃该帧</li>
</ul>
</li>
<li>类型：上层协议类型（大多为IP协议，也支持其它协议）</li>
<li>CRC：由接收方检查，若检测到错误，就将该帧丢弃</li>
</ul>
</li>
<li>提供的服务<ul>
<li>无连接服务：在送适配器和接收适配器之间不需要握手</li>
<li>不可靠服务：接收适配器不发送确认帧或否认帧给发送方<ul>
<li>交给网络层的数据报可能存在间隙</li>
<li>若应用使用TCP，间隙会被填充</li>
<li>否则，应用就会看见间隙</li>
</ul>
</li>
</ul>
</li>
<li>以太网使用的CSMA&#x2F;CD<ul>
<li>特点<ul>
<li>没有时隙</li>
<li>当适配器侦听到其它适配器在传输，它不传输帧，即载波侦听</li>
<li>正在传输的适配器若检测到其它适配器也在传输，则它中止自己的传输，即碰撞检测</li>
<li>在重新传输之前，适配器要等待一段随机时间，即随机回退</li>
</ul>
</li>
<li>算法<ul>
<li>适配器收到来种子网络层的数据报，创建帧</li>
<li>若适配器检测到信道空闲，则开始传输帧；若检测到信道忙，就开始等待，直到信道空闲再开始传输该帧</li>
<li>若适配器传输了整个帧而没有检测到其它适配器的传输，则该适配器完成该帧的传输</li>
<li>若适配器在传输时检测到其它适配器也在传输，则停止传输，发送拥塞信号</li>
<li>中止传输后，适配器进入指数回退阶段，在经历第m次碰撞后，适配器随机总${0, 1, 2, …, 2^m-1}$中选则K值。适配器在等待K*512比特时间后，返回第2步</li>
</ul>
</li>
<li>几个定义<ul>
<li>拥塞信号：用来确保所有传输者都能够检测到碰撞而传输的信号；长度为48bit</li>
<li>比特时间：传输1比特所需时间。在10Mbps的以太网中，当K&#x3D;1023时，等待时间大约为50ms</li>
<li>指数回退算法<ul>
<li>目的：适配器重传时试图估计正确的负载<ul>
<li>重载：随机等待的时间可能会更长</li>
</ul>
</li>
<li>第一次碰撞：从{0, 1}中选则K；延迟是K*512比特传输时间</li>
<li>第二次碰撞后：从{0, 1, 2, 3}中选则K</li>
<li>第十次碰撞后：从{0, 1, …, 1023}中选则K</li>
</ul>
</li>
</ul>
</li>
<li>重要特性<ul>
<li>使用CSMA&#x2F;CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）</li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</li>
<li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率</li>
</ul>
</li>
<li>争用期长度<ul>
<li>以太网取51.2 us为争用期的长度</li>
<li>对于10Mb&#x2F;s以太网，在征用期间内可发送512bit，即64字节</li>
<li>以太网在发送数据时，若前64字节没有发生碰撞，则后续的数据就不会发生碰撞</li>
</ul>
</li>
<li>最短有效帧长<ul>
<li>如果发生碰撞，就一定是在发送的前64字节之内</li>
<li>由于一检测到碰撞就立即终止发送，这时已经发送出去的数据一定小于64字节</li>
<li>以太网规定了最短有效帧长度为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="信号编码"><a href="#信号编码" class="headerlink" title="信号编码"></a>信号编码</h3><ul>
<li>曼彻斯特编码<ul>
<li>低电平到高电平为0，高电平到低电平为1</li>
</ul>
</li>
<li>差分曼切斯特编码<ul>
<li>第一个信号：<ul>
<li>中间电平从高到低，表示1</li>
<li>中间电平从低到高，表示0</li>
</ul>
</li>
<li>后续信号<ul>
<li>每个区间内的头和下一个区间的头是相同电平，表示1</li>
<li>每个区间内的头和下一个区间的头是相反电平，表示0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="集线器（或转发器）互联"><a href="#集线器（或转发器）互联" class="headerlink" title="集线器（或转发器）互联"></a>集线器（或转发器）互联</h3><ul>
<li>主干集线器将LAN网段互联起来</li>
<li>扩展了节点间的最大距离</li>
<li>原先独立的网段碰撞域变成了一个大的碰撞域</li>
<li>不能将10BaseT和100BaseT以太网互联</li>
</ul>
<h3 id="以太网交换机互联"><a href="#以太网交换机互联" class="headerlink" title="以太网交换机互联"></a>以太网交换机互联</h3><ul>
<li>一种存储-转发设备，在MAC层实现LAN互联</li>
<li>工作原理<ul>
<li>不断监听各接口是否有信号</li>
<li>收到无差错的帧则缓存，反之将差错帧丢弃</li>
<li>若所受帧的目的MAC地址属另一网段，则通过站表决定向何接口转发</li>
<li>交换机不转发同一网段内通信的帧</li>
<li>交换机不修改所转发的帧的源地址</li>
</ul>
</li>
<li>优势<ul>
<li>过滤通信量</li>
<li>扩大了局域网的物理范围</li>
<li>提高了可靠性</li>
<li>可互连不同物理层、不同MAC子层何不同速率的局域网</li>
</ul>
</li>
<li>缺点<ul>
<li>由于要接收和转发，增加了时延</li>
<li>MAC子层没有流量控制功能，网络负荷重时，交换机缓存空间可能发生溢出，产生帧丢失现象</li>
<li>出现广播风暴。交换机只适合用户少于几百个和通信量不太大的局域网，否则有时会因传播过多广播信息而产生网络拥塞</li>
</ul>
</li>
<li>和集线器的区别<ul>
<li>集线器指示将网络的覆盖距离简单延长，而且距离有限，具体实现在物理层；交换机不仅具有将LAN的覆盖距离延长的作用，而且理论上可做到无线延长，具体实现在MAC层</li>
<li>集线器仅具有简单的信号整形和放大的功能；交换机则属于一种智能互联设备，它主要提供信号的存储&#x2F;转发、数据过滤、路由选则等能力</li>
<li>集线器仅是一种硬设备，而交换机既包括硬件又包括软件</li>
</ul>
</li>
<li>交换机的透明性<ul>
<li>局域网上的每个站并不知道所发送的帧将经过哪几个交换机，即交换机对各站来说是看不见的</li>
</ul>
</li>
<li>交换机选路原理<ol>
<li>从接口x收到帧，有差错则丢弃，否则在站表中查找目的站MAC地址</li>
<li>找到有，则取出相应的接口d，转3，否则转5</li>
<li>如果所给MAC地址的接口d&#x3D;x，则丢弃此帧（不需要转发），否则从接口d转发此帧；</li>
<li>转6</li>
<li>向除x以外的所有接口转发此帧（可保证找到目的站）</li>
<li>如源站不在站表中，则将源站MAC地址写入站表，等级该帧进入交换机的接口号和时间，设置计时器，然后转8，否则转7</li>
<li>更新计时器（由于网络拓扑经常变化，因此超时记录要删除，以反应最新状态）</li>
<li>等待新的数据帧，转1</li>
</ol>
</li>
<li>交换机存在的问题——兜圈子 </li>
<li>解决方案——支撑树算法<ul>
<li>互连在一起的交换机彼此通信后，就能找出原来的网络拓扑的一个子集，在这个自己里整个连同的完了过中不存在回路。一旦支撑树确定了交换机，就会将某些接口断开，以确保从原来的拓扑得出一个支撑树</li>
<li>支撑树算法选则一个交换机作为树的根，然后以最短路径为一句，找到树上的每一个节点</li>
<li>为了让支撑树能反应网络拓扑的变化，每隔几秒钟每个交换机要广播其标识号，和它所直到的其它交换机</li>
<li>缺点：互联局域网数目非常大时，支撑树算法可能花费很多时间</li>
</ul>
</li>
<li>以太网交换机VS路由器<ul>
<li>两者都是存储转发设备<ul>
<li>路由器：网络层设备（检查网络层头部）</li>
<li>交换机：链路层设备</li>
</ul>
</li>
<li>路由器维护路由表，实现路由算法</li>
<li>交换机维护交换表，实现MAC地址过滤、学习算法</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">集线器</th>
<th align="left">路由器</th>
<th align="left">交换机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">流量隔离</td>
<td align="left">无</td>
<td align="left">有</td>
<td align="left">有</td>
</tr>
<tr>
<td align="left">即插即用</td>
<td align="left">有</td>
<td align="left">无</td>
<td align="left">有</td>
</tr>
<tr>
<td align="left">优化选路</td>
<td align="left">无</td>
<td align="left">有</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">直通交换</td>
<td align="left">有</td>
<td align="left">无</td>
<td align="left">有</td>
</tr>
</tbody></table>
<h3 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h3><ul>
<li>概念：虚拟局域网VLAN是指以软件方式来实现逻辑工作组划分与管理的一种网络工作组组建技术</li>
<li>特征<ul>
<li>局域网交换机是组件虚拟局域网的核心设备</li>
<li>组成逻辑工作组的各节点不受物理未知的限制，换言之，同一逻辑工作组的成员不一定要连在同一个物理网段上</li>
<li>当一个节点从一个逻辑工作组转移到另一个逻辑工作组的时候，只需要通过软件设定，而不需要改变它在网络中的物理位置</li>
</ul>
</li>
<li>基于端口的虚拟局域网<ul>
<li>交换机端口被分成多组（由交换机管理软件完成），单个物理交换机可以被划分为多个虚拟交换机</li>
</ul>
</li>
<li>虚拟交换机的构建方式<ul>
<li>基于交换机接口号</li>
<li>基于MAC地址</li>
<li>基于IP地址</li>
</ul>
</li>
<li>功能：<ul>
<li>端口隔离：不同组的端口的帧仅仅能发送到本组内的其它端口（如果是基于交换机接口号划分的话）</li>
<li>动态的成员管理：端口可以在VLAN之间动态分配</li>
<li>VLANS之间的转发：通过路由完成转发（就像使用单独的交换机一样）</li>
</ul>
</li>
<li>干线端口<ul>
<li>转发在多个物理交换机上的VLAN帧<ul>
<li>交换机之间在VLAN中转发的帧不是普通的802.1帧，必须要包含VLAN ID信息</li>
<li>在802.lq协议中，干线端口转发的帧需要添加和删除额外的报头字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="回顾：Web页面请求的历程"><a href="#回顾：Web页面请求的历程" class="headerlink" title="回顾：Web页面请求的历程"></a>回顾：Web页面请求的历程</h2><ul>
<li>请求连接Internet所需的参数<ul>
<li>正在连接的笔记本需要获得IP地址、网关、DNS服务器等信息</li>
</ul>
</li>
</ul>
<ol>
<li>动态获取本机的IP地址<ol>
<li>DHCP请求依次进行UDP封装，IP封装，802.3以太网帧封装 </li>
<li>以太网帧向局域网发送广播（目的:FFFFFFFFFFFF），由运行DHCP server的网关路由器受到</li>
<li>路由器进行以太网帧解封、IP解封、UDP解封，得到DHCP请求</li>
<li>DHCP server生成DHCP ACK报文，该报文包含客户端IP、掩码、网管你以及DNS服务器</li>
<li>DHCP server进行封装，将数据帧通过局域网转发（交换机自学习），在客户端进行解封装</li>
<li>DHCP client收到了DHCP ACK应答。客户端现在有了IP地址，直到了自己的名字、DNS服务器和网关</li>
</ol>
</li>
<li>ARP（DNS之前，HTTP之前）——通过域名获得目标节点的IP<ul>
<li>在发送HTTP请求之前，需要直到目标域名的IP地址：DNS</li>
</ul>
<ol>
<li>客户端创建DNS请求，进行UDP封装，IP风窗，以太帧封装。在发送到网关路由器之前，需要直到路由器的接口MAC地址：采用ARP协议</li>
<li>客户端广播发送ARP请求，路由器收到以后，发送ARP应答，给出路由器接口的MAC地址</li>
</ol>
</li>
<li>使用DNS<ol>
<li>客户端知道了网关路由器的MAC地址，可以发送包含DNS请求的数据帧了</li>
<li>包含DNS查询的IP数据报通过局域网交换机发到网关路由器</li>
<li>校园网的IP数据报路由转发到comcast网络（路由表由RIP, OSPF, IS-IS和&#x2F;或BGP协议产生）的DNS服务器</li>
<li>多路分解到DNS server</li>
<li>DNS server向客户端发送包含目标域名的IP的DNS应答</li>
</ol>
</li>
<li>TCP连接<ol>
<li>为了发送HTTP请求，客户端首先要创建到web服务器的TCP套接字</li>
<li>TCP SYN报文（三次握手的第一步）域间路由到web server</li>
<li>web server回应TCP SYNACK（三次握手的第二步）</li>
<li>客户端再次回应TCP ACK（三次握手的第三步）</li>
<li>TCP连接建立</li>
</ol>
</li>
<li>HTTP请求<ol>
<li>HTTP request发送到TCP socket</li>
<li>包含HTTP请求的IP数据报路由转发到目标域名地址</li>
<li>web server进行HTTP reply响应（包含web page）</li>
<li>包含HTTP响应的IP数据报被路由转发回客户端</li>
<li>web页面最终显示</li>
</ol>
</li>
</ol>
<h1 id="无线网络和移动网络"><a href="#无线网络和移动网络" class="headerlink" title="无线网络和移动网络"></a>无线网络和移动网络</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="无线网络的元素"><a href="#无线网络的元素" class="headerlink" title="无线网络的元素"></a>无线网络的元素</h3><ul>
<li>无线主机</li>
<li>基站<ul>
<li>典型的作用是用于连接无线网络</li>
<li>负责向其覆盖范围内的主机发送和接收分组，在无线网络和无线主机之间起链路层中继的作用。如：蜂窝塔、802.11接入点</li>
</ul>
</li>
<li>无线链路<ul>
<li>典型的作用是用于连接无线主机和基站</li>
<li>也可以用于骨干链路</li>
<li>与链路访问相匹配的多址访问协议</li>
<li>多种数据传输速率和传输距离</li>
</ul>
</li>
</ul>
<h3 id="基础设施模式"><a href="#基础设施模式" class="headerlink" title="基础设施模式"></a>基础设施模式</h3><ul>
<li>无线局域网可以分为两大类：有固定基础设施和自组网络(ad hoc网络)</li>
<li>基础设施模式是指预先建立起来的、能够覆盖一定地理范围的一批固定基站</li>
<li>移动主机通过基站接入有线网络</li>
<li>切换：移动主机的移动可能会改变与之相关联的基站</li>
</ul>
<h5 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h5><ul>
<li>关联<ul>
<li>无线主机位于某个基站的无线通信覆盖范围内</li>
<li>该主机使用该基站中继它与更大网络之间的数据</li>
</ul>
</li>
<li>切换<ul>
<li>当一台移动主机移动范围超出一个基站的覆盖范围而到达另一个基站的覆盖范围后，它将改变其接入更大网络的连接点</li>
</ul>
</li>
<li>ad hoc网络<ul>
<li>一种没有固定基础设施的自组网络</li>
<li>无基站</li>
<li>节点（移动主机）仅仅能够在其覆盖范围内向其它节点传送数据</li>
<li>节点之间相互通信组成的临时网络：在它们内部进行选路和地址分配</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">单跳</th>
<th align="left">多跳</th>
</tr>
</thead>
<tbody><tr>
<td align="left">有基础设施</td>
<td align="left">具有与较大的有限网络连接的基站（WiFi、蜂窝）</td>
<td align="left">可能通过其它无线节点中继他们的通信：网状网络</td>
</tr>
<tr>
<td align="left">无基础设施(ad hoc)</td>
<td align="left">无基站，不连接到更大的网络（蓝牙、自组织网络）</td>
<td align="left">没有基站，不连接到更大的网络，可能必须在其它几个节点之间中继报文：MANET（移动自组织网络），VANET（车载自组织网络）</td>
</tr>
</tbody></table>
<h2 id="无线链路和网络特性"><a href="#无线链路和网络特性" class="headerlink" title="无线链路和网络特性"></a>无线链路和网络特性</h2><ul>
<li>无线链路的特征<ul>
<li>递减的信号强度</li>
<li>来自其它源的干扰</li>
<li>多径传播</li>
<li>-&gt; 无线链路中的比特差错比有线链路中更为常见</li>
</ul>
</li>
<li>无线链路中差错处理<ul>
<li>采用CRC进行帧校验</li>
<li>采用ARQ协议进行重传</li>
</ul>
</li>
<li>无线链路质量描述<ul>
<li>信号的传输会引入噪声，可能出现差错</li>
<li>常用的两个描述链路质量的量<ul>
<li>SNR——信噪比</li>
<li>BER——比特差错率</li>
</ul>
</li>
<li>信噪比与比特差错率的关系<ul>
<li>对于给定的调制方案，SNR越高，BER越低</li>
<li>对于给定的SNR，具有较高比特传输率的调制技术将具有较高的BER</li>
</ul>
</li>
</ul>
</li>
<li>隐藏终端问题<ul>
<li>存在障碍物</li>
<li>信号衰减</li>
</ul>
</li>
<li>码多址访问CDMA<ul>
<li>CDMA(Code Division Multiple Access)每个用户可以在同样的时间内用相同的频带进行通信。由于各用户使用经过特殊挑选的不同码类型，因此不会造成干扰。这种通信信号具有很高的抗干扰能力</li>
<li>每个用户被指派一个唯一的m bit码片序列</li>
<li>所有用户共享相同的频道，但每个用户用自己的“码片”序列对数据编码<ul>
<li>发送比特“1”时，发送指定给改站点的m bit码片序列</li>
<li>发送比特“0”时，发送此m bit的二进制反码</li>
<li>习惯上，将码片序列中的“0”写成“-1”，“1”写成“+1”</li>
</ul>
</li>
<li>允许多个用户宫村和发送信号，且互相干扰极小</li>
<li>每一个站的码片序列各不相同，互相正交<ul>
<li>任何两个站点（如S和T站点）的码片向量规格化内积为0 $S \cdot T &#x3D; \frac{1}{m} \sum s_it_i &#x3D; 0$</li>
<li>任何码片向量和自己的规格化内积为1 $S \cdot S &#x3D; \frac{1}{m} \sum s_is_i &#x3D; 1$</li>
<li>任何码片向量和其反码的规格化内积为-1 $S \cdot (-S) &#x3D; \frac{1}{m} \sum s_i (-s_i) &#x3D; -1$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Wi-Fi-802-11无线LAN"><a href="#Wi-Fi-802-11无线LAN" class="headerlink" title="Wi-Fi:802.11无线LAN"></a>Wi-Fi:802.11无线LAN</h2><ul>
<li>802.11协议簇<ul>
<li>802.11b<ul>
<li>工作在不需要许可证的2.4~2.485GHz的无线频谱上</li>
<li>最高数据速率11Mbps</li>
<li>采用直接序列扩频(DSSS)</li>
</ul>
</li>
<li>802.11a<ul>
<li>频率范围:5.1~5.8GHz</li>
<li>最高数据速率: 54Mbps</li>
</ul>
</li>
<li>802.11g<ul>
<li>2.4~2.485GHz范围</li>
<li>最高数据速率54Mbps</li>
</ul>
</li>
<li>802.11n: 多天线<ul>
<li>2.4<del>2.485、5.1</del>5.8GHz范围</li>
<li>单流最高数据速率150Mbps</li>
<li>多流最高数据速率600Mbps</li>
</ul>
</li>
<li>802.11ac<ul>
<li>5.1~5.8GHz范围</li>
<li>单流最高数据速率<ul>
<li>433Mbps@80MHz信道带宽</li>
<li>866Mbps@160MHz信道带宽</li>
</ul>
</li>
<li>多流最高数据速率1.73Gbps、3.47Gbps</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="第六代WiFi：802-11ax"><a href="#第六代WiFi：802-11ax" class="headerlink" title="第六代WiFi：802.11ax"></a>第六代WiFi：802.11ax</h4><ul>
<li>单流速率提升至1.2Gbps，8x8模式下提供高达9.6Gbps的传输速率</li>
<li>支持较窄的子载波间隔以及增加的符号持续时间，更有利于确保信号的健壮性，令wifi覆盖至更远范围</li>
<li>引入曾在4G LITE上使用的正交频分多址(OFDMA)技术，加之同时支持2.4GHz和5GHz频段，能创造出更多可用的数据通道，解决无线网络拥堵问题</li>
<li>通过在多AP多用户并发场景中引入很多LTE领域的组网特性，让信号的抗干扰性大幅提升</li>
</ul>
<h3 id="802-11协议簇"><a href="#802-11协议簇" class="headerlink" title="802.11协议簇"></a>802.11协议簇</h3><ul>
<li>都使用CSMA&#x2F;CA协议实现多路访问</li>
<li>都可以用于固定基础设施模式和自组网络模式</li>
</ul>
<h3 id="802-11体系结构"><a href="#802-11体系结构" class="headerlink" title="802.11体系结构"></a>802.11体系结构</h3><ul>
<li>无线终端通过基站(AP)进行通信</li>
<li>一个基站的服务范围<ul>
<li>基本服务集(BSS)</li>
</ul>
</li>
<li>基本服务集BSS包括<ul>
<li>无线终端 </li>
<li>基站AP</li>
<li>Ad hoc模式下只有终端</li>
</ul>
</li>
<li>802.11b的信道划分<ul>
<li>2.4GHz-2.485GHz，共85MHz</li>
<li>划分为11个部分重叠的信道集</li>
<li>两个信道仅当中间相隔4个即以上的信道时，无重叠</li>
<li>1、6、11三个信道不重叠，可同时工作</li>
</ul>
</li>
</ul>
<h4 id="802-11b中主机关联AP的过程"><a href="#802-11b中主机关联AP的过程" class="headerlink" title="802.11b中主机关联AP的过程"></a>802.11b中主机关联AP的过程</h4><ul>
<li>每个AP周期性发送信标帧，包括AP的SSID和MAC<ul>
<li>SSID: Service Set Identifier,服务集标识</li>
</ul>
</li>
<li>主机对11个信道进行扫描，获取所有可用的AP信标帧</li>
<li>主机选则其中一个AP进行关联，加入其所属子网</li>
<li>主机向关联AP发送DHCP发现报文，获取IP地址</li>
<li>可能需要身份鉴别</li>
</ul>
<h4 id="WiFi：发送方的工作流程"><a href="#WiFi：发送方的工作流程" class="headerlink" title="WiFi：发送方的工作流程"></a>WiFi：发送方的工作流程</h4><ol>
<li>如果侦听到信道闲置了DIFS秒</li>
<li>传输整个帧（无冲突检测）</li>
<li>如果侦听到信道忙，则选则一个随机避退值作为定时器的定时时间，并在侦听信道空闲时递减该值</li>
<li>定时到且信道空闲就发送数据</li>
<li>如果收到确认，且站点要继续发送数据，则执行第一步</li>
<li>如果没有收到确认(ACK)，则在更大范围内选取随机值，重复第3步</li>
<li>如果帧收到则OK，等待SIFS秒后返回ACK<blockquote>
<p>ACK是必须的，因为隐蔽站问题</p>
</blockquote>
</li>
</ol>
<h3 id="802-11的MAC协议"><a href="#802-11的MAC协议" class="headerlink" title="802.11的MAC协议"></a>802.11的MAC协议</h3><ul>
<li>CSMA&#x2F;CA</li>
<li>802.11不采用冲突检测的原因：<ul>
<li>检测碰撞的能力要求站点具有同时发送和接收的能力</li>
<li>802.11适配器，接收信号的强度可能远远小于发送信号的强度，从而被淹没，无法检测到</li>
<li>如果一定要实现，则硬件代价会非常大</li>
<li>另外，即使站点具备同时发送和监听的能力，也会由于隐蔽终端和衰减的问题，无法检测到所有的碰撞</li>
</ul>
</li>
<li>802.11采取碰撞避免而非碰撞检测</li>
</ul>
<h4 id="wifi的冲突避免"><a href="#wifi的冲突避免" class="headerlink" title="wifi的冲突避免"></a>wifi的冲突避免</h4><ul>
<li>思路：允许发送方“预约”信道而非随机访问：避免长的数据帧冲突<ul>
<li>发送方在发送数据帧之前首先使用CSMA协议发送一个短的请求发送RTS(request-to-send)帧给AP：<ul>
<li>RTS也可能仍然会相互冲突（但时间很短）</li>
</ul>
</li>
<li>AP广播一个允许发送CTS(clear-to-send)帧响应RTS</li>
<li>RTS被所有节点侦听到<ul>
<li>发送方发送数据帧</li>
<li>其它站点推迟发送<blockquote>
<p>使用短的预约帧可以完全避免数据帧发生冲突</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="802-11-MAC帧格式"><a href="#802-11-MAC帧格式" class="headerlink" title="802.11 MAC帧格式"></a>802.11 MAC帧格式</h5><table>
<thead>
<tr>
<th align="left">2</th>
<th align="left">2</th>
<th align="left">6</th>
<th align="left">6</th>
<th align="left">6</th>
<th align="left">2</th>
<th align="left">4</th>
<th align="left">0-2312</th>
<th align="left">4</th>
</tr>
</thead>
<tbody><tr>
<td align="left">帧控制</td>
<td align="left">持续期</td>
<td align="left">地址1</td>
<td align="left">地址2</td>
<td align="left">地址3</td>
<td align="left">序号控制</td>
<td align="left">地址4</td>
<td align="left">有效载荷</td>
<td align="left">CRC</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">无线主机或AP接收该帧的MAC地址</td>
<td align="left">无线主机或AP发送该帧的MAC地址</td>
<td align="left">与AP连接的路由器接口的MAC地址</td>
<td align="left"></td>
<td align="left">仅在ad hoc模式中使用</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="WiFi帧首部的帧控制部分"><a href="#WiFi帧首部的帧控制部分" class="headerlink" title="WiFi帧首部的帧控制部分"></a>WiFi帧首部的帧控制部分</h5><table>
<thead>
<tr>
<th align="left">2</th>
<th align="left">2</th>
<th align="left">4</th>
<th align="left">1</th>
<th align="left">1</th>
<th align="left">1</th>
<th align="left">1</th>
<th align="left">1</th>
<th align="left">1</th>
<th align="left">1</th>
<th align="left">1</th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议版本</td>
<td align="left">帧类型(RTS, CTS, ACK, 数据)</td>
<td align="left">子类</td>
<td align="left">到AP</td>
<td align="left">从AP</td>
<td align="left">更多标识</td>
<td align="left">重试</td>
<td align="left">功率管理</td>
<td align="left">更多数据</td>
<td align="left">WEP</td>
<td align="left">Rsvd</td>
</tr>
</tbody></table>
<h4 id="802-11同一子网内的移动性"><a href="#802-11同一子网内的移动性" class="headerlink" title="802.11同一子网内的移动性"></a>802.11同一子网内的移动性</h4><p>当H1既在AP1下又在AP2下，但AP1和AP2连接去同一个hub或交换机的时候，H1仍然在同一个IP子网中，IP地址也可能相同。</p>
<p>交换机：哪个AP与H1关联？<br>-&gt; 自学习<br>交换机将看到来自H1的帧并“记住”能达到H1的哪个交换机端口</p>
<h4 id="802-11速率自适应"><a href="#802-11速率自适应" class="headerlink" title="802.11速率自适应"></a>802.11速率自适应</h4><ul>
<li>基站和移动终端之间的传输速度会随着移动终端的移动和SNR的变化而智能的调整<ul>
<li>当终端向原理基站的方向移动时，SNR减小，BER增大</li>
<li>当BER增大到一定程度时，将速率切换到一个较低水平来保障较低的BER</li>
</ul>
</li>
</ul>
<h4 id="功率管理"><a href="#功率管理" class="headerlink" title="功率管理"></a>功率管理</h4><ul>
<li>node-to-AP: “我将保持睡眠状态直到下一个信标帧”<ul>
<li>AP直到不应当向这个节点发送任何帧</li>
<li>AP缓存所有需要发送给该节点的帧</li>
<li>节点在下一个信标帧率前唤醒</li>
</ul>
</li>
<li>信标帧：包含了帧被缓存在AP中的节点的列表<ul>
<li>如果又帧，待发送节点会保持活动状态，请求这些帧，再转入睡眠状态。</li>
<li>如果没有帧，重新进入睡眠状态直到下一个信标帧前</li>
</ul>
</li>
</ul>
<h3 id="802-15——无线个人区域网"><a href="#802-15——无线个人区域网" class="headerlink" title="802.15——无线个人区域网"></a>802.15——无线个人区域网</h3><ul>
<li>半径小于10米</li>
<li>取代电缆（鼠标，键盘，耳机）</li>
<li>自组网：无固定基础设施</li>
<li>802.15：从蓝牙技术规范演变而来<ul>
<li>2.4-2.5GHz ISM频段</li>
<li>最大数据速率3Mbps</li>
</ul>
</li>
<li>主&#x2F;从式：<ul>
<li>主设备轮询从设备</li>
<li>批准从设备的传输请求</li>
</ul>
</li>
</ul>
<h2 id="移动管理：原理"><a href="#移动管理：原理" class="headerlink" title="移动管理：原理"></a>移动管理：原理</h2><ul>
<li>移动节点的地址是否有必要始终保持不变<ul>
<li>取决于应用需要</li>
</ul>
</li>
<li>有哪些可用的有线基础设施的支持<ul>
<li>假设存在固定的基础设施让移动用户连接<ul>
<li>家庭的ISP网络</li>
<li>办公室的无线接入网络</li>
<li>沿高速公路的无线接入网络</li>
</ul>
</li>
<li>无固定的基础设施时<ul>
<li>自组织网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>归属网络：移动用户永久的“家”</li>
<li>永久地址：归属网络中的地址，用它一定可以找到一定用户</li>
<li>归属代理(HA)：当移动用户在远程时，代表移动节点执行移动管理功能的实体</li>
<li>被访问网络：移动用户当前所在的网络<ul>
<li>外部代理：在被访问网络中帮助移动节点完成移动管理功能的实体</li>
<li>永久地址(MA)：保持不变</li>
<li>转交地址(COA)：在被访问网络中的地址</li>
</ul>
</li>
<li>通信者：希望与移动节点通信的实体</li>
</ul>
<h4 id="两种解决办法"><a href="#两种解决办法" class="headerlink" title="两种解决办法"></a>两种解决办法</h4><ul>
<li>让路由器处理：路由器通过通常的路由表交换方式向邻居通告移动节点的永久地址<ul>
<li>路由表指明移动用户的位置</li>
<li>不需要对网络基础结构做出重大改变</li>
<li>无法扩展到百万移动用户！！！</li>
</ul>
</li>
<li>让终端处理<ul>
<li>简介路由：通信者如果需要与移动用户通信，归属代理首先截获这些数据报，然后通过移动用户的COA将数据转发给外部代理，然后从该外部代理转发给移动用户</li>
<li>直接路由：通信这获取移动用户的外部地址，然后直接将数据报发给移动用户</li>
</ul>
</li>
</ul>
<h4 id="移动节点的注册"><a href="#移动节点的注册" class="headerlink" title="移动节点的注册"></a>移动节点的注册</h4><p>移动用户进入被访问网络时向外部代理注册</p>
<p>外部代理向归属代理注册移动用户的COA：“这个移动用户在我的网络中”</p>
<h4 id="移动节点间的选路"><a href="#移动节点间的选路" class="headerlink" title="移动节点间的选路"></a>移动节点间的选路</h4><ul>
<li>间接选路<ul>
<li>通信者将数据报指向移动用户的归属地址，并将数据报发送到网络中</li>
<li>归属代理首先截获数据报，并将其封装在一个目的地址为COA的数据报内，然后将这些数据报转发给外部代理</li>
<li>外部代理收到数据报，从中取出通信这的原始数据报，然后转发给移动用户</li>
<li>移动用户直接响应通信者</li>
</ul>
</li>
<li>直接选路<ul>
<li>通信者向归属代理请求，然后收到移动用户的外部地址</li>
<li>通信者将数据报发给外部代理</li>
<li>外部代理收到数据报，然后转发给移动用户</li>
<li>移动用户直接响应通信者</li>
<li>问题：对通信者来说是非透明的：通信者必须从归属代理那里得到转交地址COA<ul>
<li>如果移动用户从一个被访问网络移动到另一个网络，通信者就找不到了</li>
<li>解决方案：<ul>
<li>当用户移动到新的网络的时候，通信者仍然只用指向会话开始时被访问的外部网络，该网络的外部代理自己和新网络的外部代理之间建立联系并发送数据报</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>支持移动性的因特网体系结构与协议统称为移动IP(RFC3344)</p>
<ul>
<li>要素<ul>
<li>归属代理、外部代理、外部代理注册转交地址、封装</li>
</ul>
</li>
<li>移动标准的组成<ul>
<li>代理发现</li>
<li>向归属代理注册</li>
<li>数据报的间接路由</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>git相关操作</title>
    <url>/2024/04/02/git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="git的相关操作"><a href="#git的相关操作" class="headerlink" title="git的相关操作"></a>git的相关操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><code>git help &lt;command&gt;</code> 获取git命令的帮助信息</li>
<li><code>git init</code> 创建一个新的git仓库，其数据会被存放在一个名为’.git的目录下’</li>
<li><code>git status</code> 显示当前的仓库状态</li>
<li><code>git add &lt;filename&gt;</code> 添加文件到暂存区<ul>
<li><code>git add .</code> 把当前路径下的所有文件都添加到暂存你去（递归的），但是不包括’.gitignore’文件中声明的不被包含的文件</li>
</ul>
</li>
<li><code>git commit</code> 创建一个新的提交</li>
<li><code>git log</code> 显示历史日志</li>
<li><code>git log --all --graph --decorate</code> 可视化历史记录（有向无环图）</li>
<li><code>git diff &lt;filename&gt;</code> 显示与暂存区文件的差异</li>
<li><code>git diff &lt;revisiokn&gt; &lt;filename&gt;</code> 显示某个文件两个版本之间的差异</li>
<li><code>git checkout &lt;revision&gt;</code> 更新HEAD和目前的分支</li>
</ul>
<h2 id="分支和合并"><a href="#分支和合并" class="headerlink" title="分支和合并"></a>分支和合并</h2><ul>
<li><code>git branch</code> 显示分支</li>
<li><code>git branch &lt;name&gt;</code> 创建分支</li>
<li><code>git checkout &lt;name&gt;</code> 切换到分支<ul>
<li><code>git checkout -b &lt;name&gt;</code> 创建分支并切换到该分支</li>
</ul>
</li>
<li><code>git merge &lt;revision&gt;</code> 合并分支到当前分支</li>
<li><code>git mergetool</code> 使用工具来处理合并冲突</li>
<li><code>git rebase</code> 将一系列补丁变基变为新的基线</li>
</ul>
<h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><ul>
<li><code>git remote</code> 列出远端</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code> 添加一个远端</li>
<li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code> 将对象传送至远端并更新远端引用</li>
<li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code> 创建本地和远端分支的关联关系</li>
<li><code>git fetch</code> 从远端获取对象&#x2F;索引</li>
<li><code>git pull</code> 相当于<code>git fetch; git merge</code></li>
<li><code>git clone</code> 从远端下载仓库</li>
</ul>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul>
<li><code>git commit --amend</code> 编辑提交的内容或信息</li>
<li><code>git reset HEAD &lt;file&gt;</code> 恢复暂存的文件</li>
<li><code>git checkout -- &lt;file&gt;</code> 丢弃修改</li>
</ul>
<h2 id="git高级操作"><a href="#git高级操作" class="headerlink" title="git高级操作"></a>git高级操作</h2><ul>
<li><code>git config</code> 可以设置git的相关参数</li>
<li><code>git clone --depth=1</code> 浅克隆，不包括完整的版本历史信息</li>
<li><code>git add -p</code> 交互式暂存</li>
<li><code>git rebase -i</code> 交互式边基</li>
<li><code>git blame</code> 查看最后修改某行的人</li>
<li><code>git stash</code> 暂时移除工作目录下的修改内容</li>
<li><code>git bisect</code> 通过二分查找搜索历史记录</li>
</ul>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>子模块就是当你的项目中存在着另外一个git仓库，这种时候，如果你希望能够保持另外一个git仓库的独立性，就需要吧“另外一个git仓库”给设置为当前项目的子模块。</p>
<p>如果你非常希望能够删除子模块的话，直接进入到子模块文件夹中，删除<code>.git</code>文件夹就可以了。但是请务必注意是否符合相关的许可要求。</p>
<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>在克隆一个包含子模块的项目的时候，默认的<code>git clone</code>只会克隆下来子模块所在的目录，文件夹内部并没有文件。一般来说直接通过<code>git clone --recurse-submodules</code>来要求同时克隆子模块。</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>当在你的项目内部还额外通过<code>git clone</code>克隆下来了另外一个仓库的时候，应当使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add &lt;submodule-url&gt; &lt;submodule-path&gt;</span><br></pre></td></tr></table></figure>
<p>来把子模块添加到本项目中。可以在<code>.gitsubmodules</code>文件中看到相关的内容。</p>
<h4 id="初始化和更新"><a href="#初始化和更新" class="headerlink" title="初始化和更新"></a>初始化和更新</h4><p>为了确保子模块能够被初始化和更新，还需要运行以下两个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure>

<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>在子模块中更改完后，在主项目中直接通过<code>git add &lt;submodule-path&gt;</code>来进行同步</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>只是单纯的在主项目中使用<code>git pull</code>并不会把你在子模块中的更新也推送到子模块对应的仓库中。</p>
<p>一个普通的办法就是直接进入到子模块的目录下，手动进行<code>git push</code>，然后再回到主项目中执行推送。</p>
<p>当然，也可以通过以下命令让git自动尝试推送子模块，然后再推送主项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --recursive-submodules=on-demand</span><br></pre></td></tr></table></figure>

<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h2><p>用来做比较的命令。在linux上系统本身还有一个<code>diff</code>命令用来比较两个不同的文件，但是<code>git diff</code>是用来进行仓库级别的比较。在windows上除了使用在线代码比较之外，还推荐使用软件<code>winMerge</code>来进行文件夹级别的比较，可以找出文件夹下每个文件的不同，在文件上也提供行级别的比较。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;]</span><br></pre></td></tr></table></figure>
<p>查看你相对于索引（下次提交的暂存区域）锁做的修改。（上次<code>git commit</code>和当前工作区状态的区别）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [&lt;commit&gt;] &lt;commit&gt; [--] [&lt;path&gt;]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] &lt;commit&gt;...&lt;commit&gt; [--] [&lt;path&gt;]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>



<h2 id="附加小方法"><a href="#附加小方法" class="headerlink" title="附加小方法"></a>附加小方法</h2><p>在Windows上,有时会遇到无法ssh无法push上github的时候，尝试在开代理的情况下，在<code>~/.ssh/config</code>中添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName ssh.github.com</span><br><span class="line">    Port 443</span><br></pre></td></tr></table></figure>
<p>因为你的代理肯定都会照看到443端口的访问的，所以只要让ssh的时候也是走443端口就可以解决问题了。</p>
]]></content>
      <categories>
        <category>basic_cs</category>
      </categories>
  </entry>
  <entry>
    <title>airhust视觉追踪入门</title>
    <url>/2024/09/21/airhust%E8%A7%86%E8%A7%89%E8%BF%BD%E8%B8%AA%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h2><h2 id="yolo简介"><a href="#yolo简介" class="headerlink" title="yolo简介"></a>yolo简介</h2><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><ol>
<li>conda环境</li>
<li>python基础语法</li>
<li>tmux的基本用法</li>
</ol>
<h1 id="云端环境部署"><a href="#云端环境部署" class="headerlink" title="云端环境部署"></a>云端环境部署</h1><h2 id="darknet-yolo-pjreddie版本"><a href="#darknet-yolo-pjreddie版本" class="headerlink" title="darknet-yolo, pjreddie版本"></a>darknet-yolo, pjreddie版本</h2><h3 id="克隆和编译darknet仓库"><a href="#克隆和编译darknet仓库" class="headerlink" title="克隆和编译darknet仓库"></a>克隆和编译darknet仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pjreddie/darknet</span><br><span class="line">cd darknet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点补充： <code>git</code>是一个版本管理器。一些常用的git命令是必须要能够掌握的。</p>
</blockquote>
<p>进入到<code>darknet</code>文件夹以后，可以看到文件夹的结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/darknet</span><br><span class="line">    cfg/ 模型参数配置文件</span><br><span class="line">    data/ 训练相关参数</span><br><span class="line">    examples/</span><br><span class="line">    include/</span><br><span class="line">    python/</span><br><span class="line">    scripts/</span><br><span class="line">    src/</span><br><span class="line">    LICENSE*</span><br><span class="line">    Makefile  工程项目构建文件</span><br><span class="line">    README.md  最重要，必须认真阅读！</span><br></pre></td></tr></table></figure>
<h4 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h4><p>一般来说，在上手一个github项目的时候，必须先阅读的是这个项目中的<code>README.md</code>文件，该文件会告诉你本项目中的一些基础、必要的说明，甚至还有一些情况下会直接告诉你如何快速开始、如何跑起本项目的一个测试用例等。</p>
<h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><p><code>make</code>是一个工程项目构建文件。实际作用类似<code>cmake</code>。当然，这里其实倒反天罡了，正确的描述应该是cmake像make，因为make比cmake早很多。现在cmake使用的会比make更频繁一些，也是因为make的语法比较抽象，不是特别容易写和读。相比之下cmake就会简单很多。当然，如果仔细观察过cmake之后的build文件夹的话，会发现里面其实仍然是有Makefile的。</p>
<p>在这里我们必须要去修改Makefile文件，不然如果使用默认编译的话是无法在较快的时间内训练出一个能够使用的模型的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">GPU=0</span><br><span class="line">CUDNN=0</span><br><span class="line">OPENCV=0</span><br><span class="line">OPENMP=0</span><br><span class="line">DEBUG=0</span><br></pre></td></tr></table></figure>
<p>先来看前面几行，这里就是编译时候的简单配置。0就是不使用，1就是使用。在以上几个参数中，<code>GPU</code>是必须要设置成为1的，否则如果使用CPU的话，又烧电脑，又训不出来有用的东西。</p>
<p><code>CUDNN</code>是nvidia开发的一个深度学习加速库，理论上来说可以加速训练的速度，当然，这里不是必须的。但是如果感兴趣可以自己尝试去为服务器配置cudnn。</p>
<p><code>OPENCV</code>是目前最广泛使用的计算机视觉库，在后续的视觉相关任务中是必然绕不开的一部分。但是在这里不一定需要打开，这里使用opencv最主要的目的一般是提高darknet对于数据集图片格式的兼容性，但是在绝大多数情况下是不会遇到非常古怪格式的数据集的。</p>
<p>接下来还必须修改<code>ARCH</code>参数。这个参数是和你使用的设备是强相关的。你使用的是什么显卡，在这里就应该使用该显卡架构对应的参数。如果遇到不确定的，就根据显卡的名称去网上查。</p>
<p>在以上参数都改好了以后，就可以直接编译了，在这里我们可是直接使用命令<code>make</code>就可以了。需要注意的是，使用make命令的前提是Makefile文件必须和运行make指令时候所在的路径一致，否则make命令会找不到Makefile的</p>
<h4 id="cfg-data"><a href="#cfg-data" class="headerlink" title="cfg&amp;data"></a>cfg&amp;data</h4><p>接下来修改模型相关的配置文件，进入到文件夹<code>cfg/</code>下。首先我们要改参数<code>batch</code>。batch参数是一次性进行训练、推理的图片数量，这个参数如果太大可能会超出GPU的显存，但是适当大一些可以提高训练速度。至于其它参数一般来说也不需要修改，当然，也可以参照着网上的一些解说，适当的自己尝试着去修改。</p>
<p>然后最重要的就是修改classes参数。我们需要明确的告诉yolo，我们希望训练的模型是希望能够检测多少个类别的模型，对应的参数名称是<code>yolo/classes</code>，但是仅修改classes是不够的，还需要把和classes强相关的<code>convolutional/filters</code>参数给修改，对应公式是<br>$$ filters &#x3D; 3 \times ( 5 + len(classes)) $$<br>并且应当注意，在yolov3.cfg中，这样的参数有三组。</p>
<p>然后我们需要自己写一个属于我们本次项目的.data文件，具体的写法可以参照着<code>cfg/</code>下的其它.data文件来写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classes = $&#123;num_classes&#125;</span><br><span class="line">train = $&#123;path-to-trainlist.txt&#125;</span><br><span class="line">valid = $&#123;path-to-vallist.txt&#125;</span><br><span class="line">backup = $&#123;path-to-backup-dir&#125;</span><br><span class="line">names = $&#123;path-to-.names-file&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们还需要写一个适合我们比赛项目中会用到的.names文件。对应着我们每一个类的名字。在这里需要非常注意的是.names文件中每个类的名字和对应的行数，在后面会影响我们的数据集的标注。</p>
<h3 id="数据集的处理"><a href="#数据集的处理" class="headerlink" title="数据集的处理"></a>数据集的处理</h3><p>一个完整的“数据集”，其实应该同时包括图片和标签，这样才能够训练。</p>
<h4 id="labelimg"><a href="#labelimg" class="headerlink" title="labelimg"></a>labelimg</h4><p>labelimg是一款数据集标注工具。我们需要使用pip来安装。但是同时因为labelimg已经比较具有“年代感”了，所以对于太新版本的python不是特别适应。这就是我们需要conda的时候了。conda可以方便的创建多个python虚拟环境，每个虚拟环境之间互相不影响，在我们当前的需求下非常适用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n labelimg python=3.6</span><br></pre></td></tr></table></figure>
<p>以上命令可以帮助我们创建一个名为<code>labelimg</code>的虚拟环境，根据命令提示，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate labelimg</span><br></pre></td></tr></table></figure>
<p>然后使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install labelImg</span><br></pre></td></tr></table></figure>
<p>最后使用<code>lablimg</code>启动。</p>
<h4 id="xml格式的标签转yolo格式的标签"><a href="#xml格式的标签转yolo格式的标签" class="headerlink" title="xml格式的标签转yolo格式的标签"></a>xml格式的标签转yolo格式的标签</h4><p>以下代码能够把VOC格式的标签转换为YOLO格式的标签，具体细节根据需要自行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">size, box</span>):</span><br><span class="line">    dw = <span class="number">1.</span> / size[<span class="number">0</span>]</span><br><span class="line">    dh = <span class="number">1.</span> / size[<span class="number">1</span>]</span><br><span class="line">    x = (box[<span class="number">0</span>] + box[<span class="number">1</span>]) / <span class="number">2.0</span></span><br><span class="line">    y = (box[<span class="number">2</span>] + box[<span class="number">3</span>]) / <span class="number">2.0</span></span><br><span class="line">    w = box[<span class="number">1</span>] - box[<span class="number">0</span>]</span><br><span class="line">    h = box[<span class="number">3</span>] - box[<span class="number">2</span>]</span><br><span class="line">    x = x * dw</span><br><span class="line">    w = w * dw</span><br><span class="line">    y = y * dh</span><br><span class="line">    h = h * dh</span><br><span class="line">    <span class="keyword">return</span> (x, y, w, h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_annotation</span>(<span class="params">input_list, output_path, classes</span>):</span><br><span class="line">    <span class="keyword">for</span> xml_file <span class="keyword">in</span> input_list:</span><br><span class="line">        image_id = os.path.splitext(os.path.basename(xml_file))[<span class="number">0</span>]</span><br><span class="line">        out_file = <span class="built_in">open</span>(os.path.join(output_path, image_id + <span class="string">&#x27;.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        tree = ET.parse(xml_file)</span><br><span class="line">        root = tree.getroot()</span><br><span class="line">        size = root.find(<span class="string">&#x27;size&#x27;</span>)</span><br><span class="line">        w = <span class="built_in">int</span>(size.find(<span class="string">&#x27;width&#x27;</span>).text)</span><br><span class="line">        h = <span class="built_in">int</span>(size.find(<span class="string">&#x27;height&#x27;</span>).text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> root.<span class="built_in">iter</span>(<span class="string">&#x27;object&#x27;</span>):</span><br><span class="line">            difficult = obj.find(<span class="string">&#x27;difficult&#x27;</span>).text</span><br><span class="line">            cls = obj.find(<span class="string">&#x27;name&#x27;</span>).text</span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> <span class="built_in">int</span>(difficult) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cls_id = classes.index(cls)</span><br><span class="line">            xmlbox = obj.find(<span class="string">&#x27;bndbox&#x27;</span>)</span><br><span class="line">            b = (<span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmin&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;xmax&#x27;</span>).text), <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymin&#x27;</span>).text),</span><br><span class="line">                 <span class="built_in">float</span>(xmlbox.find(<span class="string">&#x27;ymax&#x27;</span>).text))</span><br><span class="line">            bb = convert((w, h), b)</span><br><span class="line">            out_file.write(<span class="built_in">str</span>(cls_id) + <span class="string">&quot; &quot;</span> + <span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> bb]) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">classes = []  <span class="comment"># the classes name</span></span><br><span class="line">images_path = <span class="string">&quot;../dataset5/images&quot;</span></span><br><span class="line">xml_path = <span class="string">&quot;../dataset5/labels_xml&quot;</span></span><br><span class="line">tar_images_path = <span class="string">&quot;../dataset5/images&quot;</span></span><br><span class="line">tar_label_path = <span class="string">&quot;../dataset5/labels_txt&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(tar_images_path):</span><br><span class="line">    os.makedirs(tar_images_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(tar_label_path):</span><br><span class="line">    os.makedirs(tar_label_path)</span><br><span class="line"></span><br><span class="line">xml_ids = [os.path.splitext(f)[<span class="number">0</span>] <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(xml_path) <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.xml&#x27;</span>)]</span><br><span class="line">image_ids = [os.path.splitext(f)[<span class="number">0</span>] <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(images_path)</span><br><span class="line">                <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.jpg&#x27;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&#x27;JPG&#x27;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&#x27;jpeg&#x27;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&#x27;JPEG&#x27;</span>)]</span><br><span class="line"><span class="keyword">assert</span> xml_ids == image_ids  <span class="comment"># if xml_ids != immage_ids, than annotations are not complete!</span></span><br><span class="line"></span><br><span class="line">xmls_path = [os.path.join(xml_path, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(xml_path) <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.xml&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">convert_annotation(xmls_path, tar_label_path, classes)</span><br><span class="line"></span><br><span class="line">images_path = [os.path.join(images_path, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(images_path)</span><br><span class="line">                <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.jpg&#x27;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&#x27;JPG&#x27;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&#x27;jpeg&#x27;</span>) <span class="keyword">or</span> f.endswith(<span class="string">&#x27;JPEG&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># for image in images_path:</span></span><br><span class="line"><span class="comment">#     shutil.copy(image, tar_images_path)</span></span><br></pre></td></tr></table></figure>
<h4 id="划分train-val"><a href="#划分train-val" class="headerlink" title="划分train&#x2F;val"></a>划分train&#x2F;val</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_images_and_labels</span>(<span class="params">src_path, dst_path</span>):</span><br><span class="line">    os.makedirs(<span class="string">f&#x27;../<span class="subst">&#123;dst_path&#125;</span>/images&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    os.makedirs(<span class="string">f&#x27;../<span class="subst">&#123;dst_path&#125;</span>/labels&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]:</span><br><span class="line">        os.makedirs(<span class="string">f&#x27;../<span class="subst">&#123;dst_path&#125;</span>/images/&#x27;</span> + <span class="built_in">dir</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        os.makedirs(<span class="string">f&#x27;../<span class="subst">&#123;dst_path&#125;</span>/labels/&#x27;</span> + <span class="built_in">dir</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        shutil.copy(<span class="string">f&quot;../<span class="subst">&#123;src_path&#125;</span>/images/<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;../<span class="subst">&#123;dst_path&#125;</span>/images/train/<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span>)</span><br><span class="line">        shutil.copy(<span class="string">f&quot;../<span class="subst">&#123;src_path&#125;</span>/labels/<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;../<span class="subst">&#123;dst_path&#125;</span>/labels/train/<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> val_ids:</span><br><span class="line">        shutil.copy(<span class="string">f&quot;../<span class="subst">&#123;src_path&#125;</span>/images/<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;../<span class="subst">&#123;dst_path&#125;</span>/images/val/<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span>)</span><br><span class="line">        shutil.copy(<span class="string">f&quot;../<span class="subst">&#123;src_path&#125;</span>/labels/<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span>,</span><br><span class="line">                    <span class="string">f&quot;../<span class="subst">&#123;dst_path&#125;</span>/labels/val/<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">src_path = <span class="string">&quot;dataset_all&quot;</span></span><br><span class="line">dst_path = <span class="string">&quot;dataset6&quot;</span></span><br><span class="line">image_ids = [os.path.splitext(f)[<span class="number">0</span>] <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">f&#x27;../<span class="subst">&#123;src_path&#125;</span>/labels&#x27;</span>) <span class="keyword">if</span></span><br><span class="line">                f.endswith(<span class="string">&#x27;.txt&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shuffle the image ids and split into train and val</span></span><br><span class="line">random.shuffle(image_ids)</span><br><span class="line">split = <span class="built_in">int</span>(<span class="number">0.1</span> * <span class="built_in">len</span>(image_ids))</span><br><span class="line">val_ids = image_ids[:split]</span><br><span class="line">train_ids = image_ids[split:]</span><br><span class="line">copy_images_and_labels(src_path, dst_path)</span><br></pre></td></tr></table></figure>
<h4 id="生成trainlist-txt-vallist-txt"><a href="#生成trainlist-txt-vallist-txt" class="headerlink" title="生成trainlist.txt &amp; vallist.txt"></a>生成trainlist.txt &amp; vallist.txt</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定需要遍历的文件夹</span></span><br><span class="line">folder_path = <span class="string">&#x27;../dataset_darknet/images/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件，准备写入</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;trainlist.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 遍历文件夹</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">        <span class="comment"># 遍历所有文件</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># 检查文件是否为.jpg文件</span></span><br><span class="line">            <span class="keyword">if</span> name.endswith(<span class="string">&quot;.jpg&quot;</span>):</span><br><span class="line">                <span class="comment"># 获取文件的绝对路径</span></span><br><span class="line">                abs_path = os.path.abspath(os.path.join(root, name))</span><br><span class="line">                <span class="comment"># 写入文件</span></span><br><span class="line">                file.write(abs_path + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="获取预训练权重"><a href="#获取预训练权重" class="headerlink" title="获取预训练权重"></a>获取预训练权重</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/darknet53.conv.74</span><br></pre></td></tr></table></figure>
<h4 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h4><p>使用tmux新开一个窗口，然后运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./darknet detector train cfg/$&#123;your-.data-file&#125; cfg/$&#123;your-cfg-file&#125; darknet53.conv.74</span><br></pre></td></tr></table></figure>

<h2 id="darknet-hank-ai版本"><a href="#darknet-hank-ai版本" class="headerlink" title="darknet-hank.ai版本"></a><a href="https://github.com/hank-ai/darknet">darknet-hank.ai版本</a></h2><h3 id="克隆hank-ai版本darknet"><a href="#克隆hank-ai版本darknet" class="headerlink" title="克隆hank.ai版本darknet"></a>克隆hank.ai版本darknet</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hank-ai/darknet</span><br><span class="line">cd darknet</span><br></pre></td></tr></table></figure>
<p>进入到工程项目中，首先阅读README.md和CMakeLists.txt，查看项目说明以及如何构建项目，发现项目要求cmake版本大于等于3.24。使用<code>cmake --version</code>查看当前cmake版本，如果版本过低，需要使用<code>snap</code>或者<code>apt</code>更新cmake。</p>
<h3 id="编译darknet"><a href="#编译darknet" class="headerlink" title="编译darknet"></a>编译darknet</h3><p>为了能够加速训练，我们有必要使用cuda，因此首先检查本机环境是否有cuda，并且是否与nvidia驱动匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用这个命令查看驱动对应的cuda版本</span></span><br><span class="line">nvcc -V</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用这个命令查看cuda版本</span></span><br></pre></td></tr></table></figure>
<p>如果找不到nvcc，则应该需要考虑<code>$PATH</code>中是不是没有包含cuda环境变量；同时最好检查一下是否设置<code>LD_LIBRARY_PATH</code>或者在<code>/etc/ld.so.conf</code>下配置动态链接库路径。</p>
<p>当确定cuda存在以后，先新建目录<code>build</code>用来存放编译时候产生的各种文件，并进入到目录中，依次使用<code>cmake</code>,<code>make</code>编译项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make -j4 package</span><br></pre></td></tr></table></figure>
<p>阅读CMakeLists我们可以发现，该工程项目的cmake不是为了创建一个可执行文件，而是为了CPack</p>
<p>在编译成功之后，应该能够在<code>build</code>文件夹中找到一个<code>darknet-&lt;INSERT-VERSION-YOU-BUILT-HERE&gt;.deb</code>的文件，是一个debian系统的软件安装包。使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i darknet-&lt;INSERT-VERSION-YOU-BUILT-HERE&gt;.deb</span><br></pre></td></tr></table></figure>
<p>来安装编译生成的安装包。</p>
<p>安装之后，查找是否存在文件<code>/usr/bin/darknet</code>，如果不存在，则一定说明没有安装成功。</p>
<h3 id="数据集的处理-1"><a href="#数据集的处理-1" class="headerlink" title="数据集的处理"></a>数据集的处理</h3><p>关于labelimg和VOC格式转YOLO格式详见<a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%A4%84%E7%90%86">darknet-yolo, pjreddie版本</a></p>
<h3 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h3><h4 id="获取预训练权重-1"><a href="#获取预训练权重-1" class="headerlink" title="获取预训练权重"></a>获取预训练权重</h4><p>根据项目说明，到 <a href="https://github.com/hank-ai/darknet/releases/download/v2.0/yolov3.weights">https://github.com/hank-ai/darknet/releases/download/v2.0/yolov3.weights</a> 处下载预训练权重。</p>
<h2 id="yolov5"><a href="#yolov5" class="headerlink" title="yolov5"></a>yolov5</h2><p>yolov5是一个比darknet要新很多的一个仓库,可以从仓库的更新时间就可以发现.一般来说,yolov5相比darknet可以有更快的推理速度和更高的精度.</p>
<p>当然,实际上yolo到了这个地步以后,已经不仅仅有yolov5了,同时还有yolov7,yolov8,yolox等等版本.但是这些版本使用的都是python,而且在使用上来说和yolov5区别不大,所以本次我们只详细介绍yolov5</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>从github上克隆<a href="https://github.com/ultralytics/yolov5.git">yolov5</a></p>
<p>同之前提到过的一样.当克隆下来一个仓库以后,仍然非常建议从README.md开始入手这个仓库.但是在这里我们就不仔细阅读了.我们主要辨析一下yolov5和darknet的区别.</p>
<p>首先,因为yolov5几乎完全都是使用python构成的,所以这里我们最好创建一个conda虚拟环境,专门用来做yolo相关的东西.</p>
<p>创建conda虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n yolo python=3.10</span><br></pre></td></tr></table></figure>
<p>安装虚拟环境yolo所需要的相关依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="数据集的处理-2"><a href="#数据集的处理-2" class="headerlink" title="数据集的处理"></a>数据集的处理</h3><p>所有yolo使用的数据集的格式都是一样的.但是不同的是darknet在训练的时候需要使用<code>trainlist.txt</code>来找到所有的训练图片和对应标注,在yolov5中,需要使用的是yaml格式的文件.</p>
<p>数据集中的图片和标签的摆放需要使用符合yolov5的默认规范,否则就得自己手动去改源码,这样是比较麻烦的,但是也不至于不推荐.多看看大佬的代码也是好的.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">path:</span> <span class="string">/path/to/dataset</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/val</span></span><br><span class="line"></span><br><span class="line"><span class="attr">names:</span> </span><br><span class="line">  <span class="attr">0:</span> <span class="string">$&#123;your_classes&#125;</span></span><br><span class="line">  <span class="attr">1:</span> <span class="string">$&#123;your_classes&#125;</span></span><br><span class="line">  <span class="attr">2:</span> <span class="string">$&#123;your_classes&#125;</span></span><br><span class="line">  <span class="attr">3:</span> <span class="string">$&#123;your_classes&#125;</span></span><br><span class="line"><span class="attr">nc:</span> <span class="string">$&#123;num_classes&#125;</span></span><br></pre></td></tr></table></figure>

<p>在训练yolo的时候,需要自己写一个如上格式的yaml文件,用来告诉yolo训练数据集的基本信息.</p>
<p>其中,<code>path</code>就是数据集的路径,数据集路径下的文件树必须要是以下形式的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dataset</span><br><span class="line">    /images</span><br><span class="line">        /train</span><br><span class="line">        /val</span><br><span class="line">    /labels</span><br><span class="line">        /train</span><br><span class="line">        /val</span><br></pre></td></tr></table></figure>
<p>并且要保证images中的图片和labels中的标签是互相对应的.train和val中的图片、标签也要是对应的才可以.</p>
<h3 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h3><p>yolov5的训练不需要自己手动去下载预训练权重文件,在训练的时候yolov5会自动检测是否有预训练权重文件,当然也可以做到在已经训练过的模型上继续训练.</p>
<p>训练的一般命令是如下格式的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python train.py --data /path/to/mydata.yaml --epochs 1000 --weights &#x27; &#x27; --cfg yolov5n.yaml --batch-size 32</span><br></pre></td></tr></table></figure>

<ul>
<li><code>data</code>后面就是要跟着自己写的yaml文件</li>
<li><code>epochs</code>就是训练轮数.这里设置一个比较大的值也挺好的,因为yolo自己会根据学习率、损失率来自动判断什么时候停止,防止模型过拟合,也可以防止浪费一些不必要的时间.</li>
<li><code>weights</code>是权重文件的路径,如果是使用官方的预训练权重文件的话这里就什么都不用填.</li>
<li><code>cfg</code>后面跟这都是对模型的细致描述.yolov5整体上来说虽然是yolo的一大版本,但是内部还是有一些不同的模型,具体可以查看README.md里面的说明.一般来说更大的模型会有更好的精度,但是不可避免的推理时间也会更长.需要注意的是,出了在<code>mydata.yaml</code>中指定了模型的目标推理类型数量之后,还得渠道对应的<code>yolov5n.yaml</code>中的对应位置也要修改推理类型数量.</li>
<li><code>batch-size</code>就是每次同时训练多少张图片,只要不要让显存爆炸就可以了</li>
</ul>
<h1 id="端侧部署"><a href="#端侧部署" class="headerlink" title="端侧部署"></a>端侧部署</h1><h2 id="darknet-ros"><a href="#darknet-ros" class="headerlink" title="darknet_ros"></a>darknet_ros</h2><p>端侧部署，darknet_ros的部署应该是根据着脚本文件一步一步修改过来。</p>
<p>首先，在<code>darknet_ros.launch</code>中，可以看到两个非常显眼的两个文件名，<code>ros.yaml</code>和<code>yolov2-tiny.yaml</code>。那么让我们进入到两个文件分别一探究竟。</p>
<h3 id="ros-yaml"><a href="#ros-yaml" class="headerlink" title="ros.yaml"></a><code>ros.yaml</code></h3><p><code>ros.yaml</code>中，我们可以发现是一些<code>darknet_ros</code>程序本身相关的参数设置。在没有特殊情况下不要动这个文件。</p>
<h3 id="yolov2-tiny-yaml"><a href="#yolov2-tiny-yaml" class="headerlink" title="yolov2-tiny.yaml"></a><code>yolov2-tiny.yaml</code></h3><p><code>yolov2-tiny.yaml</code>就是我们需要修改的文件了。</p>
<p>在其中可以看到又有两个值得注意的文件名。cfg文件和weights文件。</p>
<p>联想到我们之前在云端训练darknet_ros的时候，我们就修改过了cfg文件夹中的关于模型参数的文件，所以这里我们应当把我们当时在云端部署模型时候训练对应的cfg文件复制到端侧设备上，并把yaml文件中的config_file的name改为我们自己使用的文件名。</p>
<p>同理，weights文件就是darknet训练出来的权重文件，我们也应当做和cfg文件相似的操作。</p>
<p>参数<code>threshold</code>是用来调整yolo的置信度的。当yolo对于一个框的可信度低于<code>threshold</code>的时候，yolo将不会显示这个框，也不会发布这个框的任何消息，减少干扰。这个参数的调整应当结合比赛的实际情况。如果在一个较插的情况下，应该宁可自己在后续的程序中多手动过滤一些不必要的信息，也要防止直接识别不出来。</p>
<p>最后，names部分也应当直接复制之前在云端训练时候的names文件部分的内容。</p>
<p>这里需要提醒大家注意的是，不管你在云侧上面获得了怎么样的训练效果，或者是你使用<code>darknet detect</code>命令测试了多少张图片，大家都应当始终要把模型落实到开发板上来。根据我们过往的经验总结，在云侧使用<code>darknet detect</code>命令获得的效果和在开发板上实际的效果通常是不太一样的。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/01/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>jetson_xavier_nx-ubuntu18-04-ros-melodic-yolov5-cpp实践</title>
    <url>/2024/06/09/jetson_xavier_nx-ubuntu18-04-ros-melodic-yolov5-cpp%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="ros换源"><a href="#ros换源" class="headerlink" title="ros换源"></a>ros换源</h2><p>原中科大源很多包都已经不再被维护了，使用清华源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p>因为jetson xavier nx自带的opencv没有支持cuda，为了能够使用cuda，需要源码编译opencv4.5。</p>
<p>但是在我的情况下，我的ros的工作空间中有太多的文件已经依赖自带的opencv了，所以不能直接删除自带的opencv而完全替换为新的opencv4.5.4。因此需要能够同时允许系统自带opencv和支持cuda的opencv4.5.4</p>
<h3 id="opencv4-5-4编译"><a href="#opencv4-5-4编译" class="headerlink" title="opencv4.5.4编译"></a>opencv4.5.4编译</h3><p>从opencv官网下载opencv4.5.4的源码，和对应的opencv_contribe的源码，解压。<br>为了不影响本来就有的opencv，在<code>/usr/local/</code>下自己新建一个<code>opencv4.5.4</code>的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /usr/local/opencv4.5.4</span><br></pre></td></tr></table></figure>
<p>进入到解压后的<code>opencv-4.5.4</code>文件夹中，自己新建一个<code>build</code>文件夹，进入其中，使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/usr/local/opencv4.5.4 \</span><br><span class="line">-DOPENCV_ENABLE_NONFREE=1 \</span><br><span class="line">-DBUILD_opencv_python2=1 \</span><br><span class="line">-DBUILD_opencv_python3=1 \</span><br><span class="line">-DWITH_FFMPEG=1 \</span><br><span class="line">-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda \</span><br><span class="line">-DCUDA_ARCH_BIN=7.2 \</span><br><span class="line">-DCUDA_ARCH_PTX=7.2 \</span><br><span class="line">-DWITH_CUDA=1 \</span><br><span class="line">-DENABLE_FAST_MATH=1 \</span><br><span class="line">-DCUDA_FAST_MATH=1 \</span><br><span class="line">-DWITH_CUBLAS=1 \</span><br><span class="line">-DOPENCV_GENERATE_PKGCONFIG=1 \</span><br><span class="line">-DOPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-4.5.4/modules \</span><br><span class="line">..</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，<code>CMAKE_INSTALL_PREFIX</code>就是希望把opencv按转到的目标路径，<code>OPENCV_EXTRA_MODULES_PATH</code>是对应的<code>opencv_contrib</code>中的module文件夹的相对路径。</p>
<p>在<code>cmake</code>成功后，就可以<code>make</code>了。</p>
<p>因为是在jetson板子上进行编译，所以需要的时间可能会非常长，又不想费精力去弄交叉编译了，所以要尽可能的利用多核，在我这里我使用<code>make -j6</code>因为nx有6个CPU核心，同时开了一个<code>tmux</code>窗口，这样可以防止不小心把make给挂了。</p>
<p>在<code>make</code>结束后还需要<code>sudo make install</code>，把一些相关的库放到<code>/usr</code>等系统目录下。</p>
<h3 id="对应cv-bridge的处理"><a href="#对应cv-bridge的处理" class="headerlink" title="对应cv_bridge的处理"></a>对应<code>cv_bridge</code>的处理</h3><p>melodic自带的cv_bridge和opencv4.5会有冲突，所以如果希望使用opencv4.5，需要自己在工作空间下下载源码vision_opencv，然后使用工作空间内的cv_bridge。</p>
<p>为了能够使用opencv4.5，需要下载<a href="https://github.com/ros-perception/vision_opencv/tree/noetic">noetic 版本的vision_opencv</a>,并且修改<code>vision_opencv/cv_bridge</code>下的CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(cv_bridge)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(OpenCV_DIR <span class="string">&quot;/usr/loca/opencv4.5.4&quot;</span>)  <span class="comment"># 此处OpenCV_DIR修改为自己安装的opencv的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS rosconsole sensor_msgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> ANDROID)</span><br><span class="line">  <span class="keyword">find_package</span>(PythonLibs)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(PYTHONLIBS_VERSION_STRING <span class="keyword">VERSION_LESS</span> <span class="string">&quot;3.8&quot;</span>)</span><br><span class="line">    <span class="comment"># Debian Buster</span></span><br><span class="line">    <span class="keyword">find_package</span>(Boost REQUIRED python3)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="comment"># Ubuntu Focal</span></span><br><span class="line">    <span class="keyword">find_package</span>(Boost REQUIRED python)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(_opencv_version <span class="number">4</span>)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">4.5</span>.<span class="number">4</span> QUIET)  <span class="comment"># 为了明确指定希望使用的opencv的版本</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> OpenCV_FOUND)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Did not find OpenCV 4, trying OpenCV 3&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(_opencv_version <span class="number">3</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>但是仅仅修改以后，cmake虽然可以了，但是在编译的时候仍然会遇到报错“<br>&#x2F;home&#x2F;nvidia&#x2F;zal_ws&#x2F;src&#x2F;vision_opencv&#x2F;cv_bridge&#x2F;src&#x2F;module.hpp: In function ‘void* do_numpy_import()’:<br>&#x2F;usr&#x2F;include&#x2F;python2.7&#x2F;numpy&#x2F;__multiarray_api.h:1537:144: error: return-statement with no value, in function returning ‘void*’ [-fpermissive]<br> #define import_array() {if (_import_array() &lt; 0) {PyErr_Print(); PyErr_SetString(PyExc_ImportError, “numpy.core.multiarray failed to import”); return NUMPY_IMPORT_ARRAY_RETVAL; } }<br>”</p>
<p>根据报错信息，直接去修改源码：</p>
<p>进入<code>/vision_opencv/cv_bridge/src/module.hpp</code>，把<code>do_numpy_import</code>函数的声明修改为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">do_numpy_import</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">import_array</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次<code>catkin_make</code>，成功编译。</p>
<h3 id="在工作空间中指定需要的cv-bridge和opencv"><a href="#在工作空间中指定需要的cv-bridge和opencv" class="headerlink" title="在工作空间中指定需要的cv_bridge和opencv"></a>在工作空间中指定需要的cv_bridge和opencv</h3><p>在自己的<code>CMakeLists.txt</code>中明确指定需要的opencv版本,cv_bridge不需要专门指定，<code>catkin_make</code>的时候会优先使用工作空间内的<code>cv_bridge</code>的源码编译生成的包的。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(OpenCV_DIR <span class="string">&quot;/usr/local/opencv4.5.4&quot;</span>)  <span class="comment"># Opencv的安装路径</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">4.5</span>.<span class="number">4</span> REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  ... <span class="comment"># 其它需要的包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>接下来，在代码中，就可以正常的导入<code>opencv4.5</code>和<code>cv_bridge</code>了。</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>ros</tag>
        <tag>opencv</tag>
        <tag>jetson</tag>
      </tags>
  </entry>
  <entry>
    <title>nmcli相关命令</title>
    <url>/2024/09/13/nmcli%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="nmcli相关命令"><a href="#nmcli相关命令" class="headerlink" title="nmcli相关命令"></a>nmcli相关命令</h1><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p>nmcli总共有八大部分的参数</p>
<table>
<thead>
<tr>
<th align="left">section</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">help</td>
<td align="left">获取帮助</td>
</tr>
<tr>
<td align="left">general</td>
<td align="left">获得网络管理器相关的状态和全局参数的值</td>
</tr>
<tr>
<td align="left">networking</td>
<td align="left">开启、重启、停止网络管理器</td>
</tr>
<tr>
<td align="left">radio</td>
<td align="left">管理无线设备和相关协议</td>
</tr>
<tr>
<td align="left">connection</td>
<td align="left">管理连接</td>
</tr>
<tr>
<td align="left">device</td>
<td align="left">管理网络设备</td>
</tr>
<tr>
<td align="left">agent</td>
<td align="left">配置和管理安全设置</td>
</tr>
<tr>
<td align="left">monitor</td>
<td align="left">监控网络的相关变化情况</td>
</tr>
</tbody></table>
<h2 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h2><p>dev管理的是机器的硬件设备</p>
<h4 id="检查设备联网情况"><a href="#检查设备联网情况" class="headerlink" title="检查设备联网情况"></a>检查设备联网情况</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli dev status</span><br></pre></td></tr></table></figure>
<p>以上命令会打印出当前机器上所有可能用来联网的设备以及它是否有网络连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cassius@ubuntu:~$ nmcli dev status</span><br><span class="line">DEVICE         TYPE      STATE         CONNECTION</span><br><span class="line">eth0           ethernet  connected     Wired connection 1</span><br><span class="line">wlan0          wifi      connected     AirHustA</span><br><span class="line">docker0        bridge    connected     docker0</span><br><span class="line">p2p-dev-wlan0  wifi-p2p  disconnected  --</span><br><span class="line">l4tbr0         bridge    unmanaged     --</span><br><span class="line">dummy0         dummy     unmanaged     --</span><br><span class="line">rndis0         ethernet  unmanaged     --</span><br><span class="line">usb0           ethernet  unmanaged     --</span><br><span class="line">lo             loopback  unmanaged     --</span><br></pre></td></tr></table></figure>
<p>例如，在我的设备上显示以太网和无线网都有连接，并且docker通过桥接模式连接到宿主机。</p>
<h4 id="查看可用的wifi"><a href="#查看可用的wifi" class="headerlink" title="查看可用的wifi"></a>查看可用的wifi</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli dev wifi list</span><br></pre></td></tr></table></figure>
<p>以上命令就会打印出设备检测到的wifi。同一个wifi可能会被打印出来多次，因为wifi使用着不同的信道。</p>
<h2 id="con"><a href="#con" class="headerlink" title="con"></a>con</h2><p>con是管理设备的相关连接配置，如定义IP地址、子网掩码、网关、DNS服务器等</p>
<h4 id="查看联网状态"><a href="#查看联网状态" class="headerlink" title="查看联网状态"></a>查看联网状态</h4><p>如果只希望查看连了网的设备，可以通过以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure>
<p>查看结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cassius@ubuntu:~$ nmcli con show</span><br><span class="line">NAME                UUID                                  TYPE      DEVICE</span><br><span class="line">Wired connection 1  30b11a44-5fd9-3717-9b55-71879f7d85b2  ethernet  eth0</span><br><span class="line">AirHustA            ba28574e-ab8a-47bc-a0a2-631e0e1ee0ca  wifi      wlan0</span><br><span class="line">docker0             905202de-05c7-45a3-8d96-0d83022c3bcd  bridge    docker0</span><br></pre></td></tr></table></figure>
<p>更进一步的，可以查看连接中的设备的更详细的信息，只要在show后面加上具体的设备名称，如在我的情况下，就应该是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con show &#x27;Wired connection 1&#x27;</span><br></pre></td></tr></table></figure>
<p>这里之所以需要加单引号是因为设备名称中有空格，如果没有空格这里就不需要加单引号了。</p>
<h4 id="添加新的连接配置文件"><a href="#添加新的连接配置文件" class="headerlink" title="添加新的连接配置文件"></a>添加新的连接配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con add con-name &lt;connection-name&gt; type wifi ifname wlan0 ssid &lt;wifi-name&gt; ipv4.method auto</span><br></pre></td></tr></table></figure>
<p>通过以上命令，可以创建一个新的连接，通过wifi俩姐到一个叫做<code>&lt;connection-name&gt;</code>的wifi，并且指定ipv4地址通过DHCP方法获取。一般情况下，该指令需要sudo权限。</p>
<p>虽然一般情况下连接的是wifi，但是如果要连接的是以太网的话，<code>type</code>后面跟的应该是<code>ethernet</code>， <code>ifname</code>后面也应该跟着以太网口的设备名，一般是<code>eth0</code></p>
<h5 id="输入wifi密码"><a href="#输入wifi密码" class="headerlink" title="输入wifi密码"></a>输入wifi密码</h5><p>如果wifi是使用wpa2协议来保护的话，后续通过以下两条命令把wifi密码添加到配置文件中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli connection modify CS_INF wifi-sec.key-mgmt wpa-psk</span><br><span class="line">nmcli connection modify CS_INF wifi-sec.psk &lt;wifi-password&gt;</span><br></pre></td></tr></table></figure>

<h5 id="开启热点"><a href="#开启热点" class="headerlink" title="开启热点"></a>开启热点</h5><p>热点本质上也只是一个本机的连接，所以也是通过nmcli来添加配置文件，就可以连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con add type wifi ifname &lt;wireless-dev-name&gt; con-name &lt;connection-name&gt; ssid &lt;hot-spot-name&gt; [autoconnect yes]</span><br><span class="line">```·</span><br><span class="line">以上命令中，`&lt;wireless-dev-name&gt;`一般是诸如`wlp3s0`这样的设备名，注意不可能是`wifi`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### 修改连接</span></span></span><br><span class="line">```shell</span><br><span class="line">nmcli con modify &lt;connection-name&gt; ipv4.method manual ipv4.address 10.0.0.10/8 ipv4.gateway 10.10.10.1</span><br></pre></td></tr></table></figure>
<p>以上命令就相当于在系统设置中指定ip地址为手动模式，设置了ipv4地址为10.0.0.10，子网掩码为255.0.0.0，网关为10.10.10.1</p>
<h5 id="自动连接"><a href="#自动连接" class="headerlink" title="自动连接"></a>自动连接</h5><p>如果希望设备每次能够自动尝试连接上某一个连接，可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con modify &lt;conection-name&gt; autoconnect yes</span><br></pre></td></tr></table></figure>
<p>来要求设备每次都自动尝试连接到<code>&lt;connection-name&gt;</code>上</p>
<h4 id="删除连接"><a href="#删除连接" class="headerlink" title="删除连接"></a>删除连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con del &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con down &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con up &lt;connection-name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>basic_cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nmcli</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>qat_installation</title>
    <url>/2025/07/21/qat_installation/</url>
    <content><![CDATA[<h1 id="在一台阿里云主机上安装intel-qat"><a href="#在一台阿里云主机上安装intel-qat" class="headerlink" title="在一台阿里云主机上安装intel qat"></a>在一台阿里云主机上安装intel qat</h1><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><ul>
<li><code>pkg-config</code> -&gt; <code>sudo apt update &amp;&amp; sudo apt install pkg-config</code></li>
<li><code>boost</code> -&gt; <code>sudo apt install libboost-all-dev</code></li>
<li><code>udev</code> -&gt; <code>sudo apt install libudev-dev</code></li>
<li><code>nasm</code></li>
</ul>
<h3 id="systemd-issues"><a href="#systemd-issues" class="headerlink" title="systemd issues"></a>systemd issues</h3><p>在ubuntu24.04上,虽然可以通过<code>apt</code>轻松的安装qat_driver和qat_lib和qat_zip,但是似乎ubuntu会把qat_service.service自动软链接到&#x2F;dev&#x2F;null上,导致qat_service没有办法自动启动.</p>
<p>因此,必须检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /usr/lib/systemd/system/qat_service.service</span><br></pre></td></tr></table></figure>

<p>是否是软链接到了&#x2F;dev&#x2F;null下,如果是的话就把这个给删除,然后使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl unmask qat_service.service</span><br><span class="line">systemctl enable qat_service.service</span><br><span class="line">systemctl start qat_service.service</span><br></pre></td></tr></table></figure>


<h2 id="QATZip"><a href="#QATZip" class="headerlink" title="QATZip"></a>QATZip</h2><h3 id="compression"><a href="#compression" class="headerlink" title="compression"></a>compression</h3><h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><p><code>qzCompress</code>-&gt;<code>qzCompressExt</code>-&gt;<code>qzCompressCrcExt</code></p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p><code>qzInit</code>:</p>
<h2 id="kae-installation"><a href="#kae-installation" class="headerlink" title="kae installation"></a>kae installation</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>在Kunpeng 920 7270Z的服务器上,BIOS版本必须至少是21.17才可以看得到各种kae的加速器设备</p>
<p>当确定BIOS版本正确后,根据华为网站上的检查调理顺着查看,应该三种设备都可以看得到</p>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>OpenEuler22.03_sp3自带openssl,但是openssl,所以不需要源码安装openssl了</p>
<p>但是需要注意的是,openssl所在的路径将不再是<code>/usr/local/lib/engine-1.1/</code>,所以在后续设置<code>OPENSSL_ENGINES</code>环境变量之前,需要首先检查OpenSSL的这个目录所在位置,使用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">penssl version -a | grep ENGINESDIR</span><br></pre></td></tr></table></figure>
<p>获得的输出即为OPENSSL_ENGINES的所应当对应的值</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>确保<code>OPENSSL_ENGINES</code>环境变量设置正确,其它步骤和华为网站上一致,但是不要使用rpm安装,最好使用源码编译安装,rpm里面有一些环境变量被写死了,因为openssl的路径不一致的问题,导致rpm安装后openssl还是无法使用kae的</p>
]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>qat</tag>
        <tag>kae</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux的使用</title>
    <url>/2024/09/17/tmux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="tmux的作用"><a href="#tmux的作用" class="headerlink" title="tmux的作用"></a>tmux的作用</h1><ul>
<li>终端复用（能够把一个终端当作好几个终端来用，影视剧中很常见的“黑客场景” <code>hollywood</code> 就是基于tmux的）<ul>
<li>可以让新窗口接入已经存在的会话</li>
<li>允许每个会话又多个连接窗口，因此可以多人实时共享会话</li>
<li>窗口垂直和水平分隔</li>
<li>一个窗口同时访问多个会话</li>
</ul>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h3 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new-session -t $&#123;session-name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="展示会话"><a href="#展示会话" class="headerlink" title="展示会话"></a>展示会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>
<p>展示所有tmux的会话，和相应的状态</p>
<h3 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h3><p>快捷键<code>^b d</code>，或者使用下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>
<h3 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux a -t $&#123;session-name&#125;</span><br><span class="line">tmux a -t $&#123;session-id&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>session-name</code>或者<code>session-id</code>都可以通过<code>tmux ls</code>命令查看到</p>
<p>tmux同时还支持模糊识别，比如说如果你只有一个名字为”mysession”的会话，可以直接通过<code>tmux a -t a</code>接入到会话中。</p>
<h3 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux kill-session  # 按照id顺序杀死会话</span><br><span class="line">tmux kill-session -t $&#123;session-name&#125;  # 杀死指定名字的会话</span><br><span class="line">tmux kill-session -t $&#123;session-id&#125;  # 杀死指定id的会话 </span><br></pre></td></tr></table></figure>
<h3 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux switch -t $&#123;session-id&#125;</span><br><span class="line">tmux switch -t $&#123;session-name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux rename-session -t $&#123;session-id&#125; $&#123;session-name&#125;</span><br><span class="line">tmux rename-session -t $&#123;old-session-name&#125; $&#123;new-session-name&#125;</span><br></pre></td></tr></table></figure>

<h2 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h2><p>tmux允许把一个窗口分成多个窗格</p>
<h3 id="划分窗格"><a href="#划分窗格" class="headerlink" title="划分窗格"></a>划分窗格</h3><ul>
<li><code>^b &quot;</code> 将会把窗口划分为上下两个窗格</li>
<li><code>^b %</code> 将会把窗口划分为左右两个窗格</li>
</ul>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p><code>^b</code> + 方位键移动光标。</p>
<h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><p>tmux允许在一个会话内有多个窗口</p>
<h3 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new-window -n $&#123;window-name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux select-window -t $&#123;window-id&#125;</span><br><span class="line">tmux select-window -t $&#123;window-name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重命名窗口"><a href="#重命名窗口" class="headerlink" title="重命名窗口"></a>重命名窗口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux rename-window $&#123;new-name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h3><ul>
<li><code>^b c</code>: 创建一个新窗口</li>
<li><code>^b p</code>: 切换到上一个窗口(previous)</li>
<li><code>^b n</code>: 切换到下一个窗口(next)</li>
<li><code>^b $&#123;number&#125;</code>: 切换到指定编号的窗口</li>
<li><code>^b w</code>: 从列表中选则窗口</li>
<li><code>^b ,</code>: 窗口重命名</li>
</ul>
]]></content>
      <categories>
        <category>basic_cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的相关操作</title>
    <url>/2024/04/02/vim%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Vim的相关操作"><a href="#Vim的相关操作" class="headerlink" title="Vim的相关操作"></a>Vim的相关操作</h1><h2 id="Vim的操作模式："><a href="#Vim的操作模式：" class="headerlink" title="Vim的操作模式："></a>Vim的操作模式：</h2><ul>
<li>正常模式：在文本中四处移动光标进行修改</li>
<li>插入模式：插入文本</li>
<li>替换模式：替换文本</li>
<li>可视化（一般，行，块）模式：选中文本块</li>
<li>命令模式：用于执行命令</li>
</ul>
<p>在默认设置下，Vim会在左下角显示当前的模式。Vim启动时的默认模式是正常模式。</p>
<p>你可以按下<code>&lt;ESC&gt;</code>从任何其它模式返回正常模式。在正常模式，键入<code>i</code>进入插入模式，<code>R</code>进入替换模式，<code>v</code>进入可视（一般）模式，<code>V</code>进入可视（行）模式，<code>^v</code>进入可视（块）模式，<code>:</code>进入命令模式。</p>
<h2 id="缓存，标签页，窗口"><a href="#缓存，标签页，窗口" class="headerlink" title="缓存，标签页，窗口"></a>缓存，标签页，窗口</h2><p>Vim会维护一系列打开的文件，成为“缓存”。一个Vim会话包含一系列标签页，每个标签页包含一系列窗口（分割面板）。每个窗口显示一个缓存。跟网页浏览器等其它程序不一样，缓存和窗口不是一一对应的关系；窗口只是视角。一个缓存可以在多个窗口打开，甚至在同一个标签页内的多个窗口打开。</p>
<ul>
<li>组合键<code>^w+s</code>会上下分割当前打开的文件。</li>
<li><code>:sp &lt;filename&gt;</code>会上下分割当前文件和新打开的文件<filename></li>
<li>组合键<code>^w+v</code>会左右分割当前打开的文件。</li>
<li><code>:vsp &lt;filename&gt;</code>会左右分割当前打开的文件和新打开的文件<filename></li>
<li><code>^w+h</code> 将当前光标定位到左边的屏幕。</li>
<li><code>^w+l</code> 将当前光标定位到右边的屏幕。</li>
<li><code>^w+j</code> 将当前光标移动到下面的屏幕。</li>
<li><code>^w+k</code> 将当前光标移动到上面的屏幕。</li>
<li><code>^w+H</code> 将当前的分屏移动到左边。</li>
<li><code>^w+L</code> 将当前的分屏移动到右边。</li>
<li><code>^w+J</code> 将当前的分屏移动到下边。</li>
<li><code>^w+K</code> 将当前的分屏移动到上边。</li>
<li><code>^w+c</code> 关闭当前的分屏。</li>
<li><code>^w+q</code> 关闭当前的分屏，如果是最后一个则将退出Vim。</li>
</ul>
<h2 id="Vim的退出"><a href="#Vim的退出" class="headerlink" title="Vim的退出"></a>Vim的退出</h2><ul>
<li><code>:w</code> 保存当前对文件的修改，但是不退出文件</li>
<li><code>:w!</code> 强制保存但是不退出文件</li>
<li><code>:w &lt;file&gt;</code> 保存当前的文件修改到<file>文件当中。</li>
<li><code>:q!</code> 退出文件，对文件的修改不做保存。</li>
<li><code>qa!</code> 退出所有的文件，并且不保存。</li>
<li><code>:wq</code> 保存并退出。</li>
<li><code>:e &lt;file&gt;</code> 打开<file>文件。</li>
<li><code>:e!</code> 放弃对文件的所有修改，恢复文件到上次保存的位置。</li>
<li><code>:saveas &lt;file&gt;</code> 另存为<file></li>
<li><code>:bn</code>和<code>:bp</code> 当打开多个文件的时候可以进行上一个文件或者下一个文件的切换。</li>
</ul>
<h2 id="Vim的插入"><a href="#Vim的插入" class="headerlink" title="Vim的插入"></a>Vim的插入</h2><ul>
<li><code>i</code> 是在光标所在的字符之前插入需要录入的文本。</li>
<li><code>I</code> 是在光标所在的行首插入需要录入的文本。</li>
<li><code>a</code> 是在光标所在的字符之后插入需要录入的文本。</li>
<li><code>A</code> 是在光标所在的行末插入需要录入的文本。</li>
<li><code>s</code> 是删除光标所在处的字符然后插入文本。</li>
<li><code>S</code> 是删除光标所在行，在当前行的行首插入文本。</li>
</ul>
<h2 id="Vim的命令模式"><a href="#Vim的命令模式" class="headerlink" title="Vim的命令模式"></a>Vim的命令模式</h2><h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><ul>
<li><code>:set nu</code> 显示行号。</li>
<li><code>:set nonu</code> 不显示行号。</li>
<li><code>:&lt;n&gt;</code> 定位到第<n>行</li>
<li><code>:&lt;n&gt;,&lt;m&gt;&lt;cmd&gt;</code> 对第n到第m行执行操作，如删除就是<code>:&lt;n&gt;,&lt;m&gt;d</code>，复制就是<code>&lt;n&gt;,&lt;m&gt;y</code></li>
</ul>
<h3 id="关键字查找"><a href="#关键字查找" class="headerlink" title="关键字查找"></a>关键字查找</h3><ul>
<li><code>/&#123;目标字符串&#125;</code> 查找文本中匹配的目标字符串，查到以后按<code>n</code>会去寻找下一个匹配，<code>N</code>会去寻找上一个匹配。</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>在命令模式下<code>dd</code>会删除本行。</li>
<li><code>:&lt;n1&gt;,&lt;n2&gt;d</code> 从第<n1>行一直删除到<n2>行（两边都闭区间）</li>
</ul>
<h3 id="Vim处理文本替换"><a href="#Vim处理文本替换" class="headerlink" title="Vim处理文本替换"></a>Vim处理文本替换</h3><ul>
<li><code>:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换的标志&#125;</code>,其中作用范围分为当前行、全文、选区等。</li>
<li>例如：<ul>
<li><code>:s/zempty/handsome/g</code> 将会把当前光标所在行的zempty替换成handsome</li>
<li><code>%s/zempty/handsome/g</code> 将会把全文中的zempty替换成handsome</li>
<li><code>&lt;n1&gt;,&lt;n2&gt;s/zempty/handsome/g</code> 把<n1>行到<n2>行的所有zempty替换为handsome。</li>
</ul>
</li>
<li>替换标志中，<code>g</code>代表global全局替换，空替换只替换从光标位置开始的第一次，<code>i</code>表示大小写不敏感，<code>I</code>表示大小写敏感，<code>c</code>表示需要确认。</li>
</ul>
<h3 id="Vim执行Linux命令"><a href="#Vim执行Linux命令" class="headerlink" title="Vim执行Linux命令"></a>Vim执行Linux命令</h3><p><code>:!&lt;command&gt;</code> 将执行<command>命令</p>
<h2 id="Vim的正常模式"><a href="#Vim的正常模式" class="headerlink" title="Vim的正常模式"></a>Vim的正常模式</h2><ul>
<li><code>h,j,k,l</code>分别代表左右下上。</li>
<li>在当前行上移动光标<ul>
<li><code>0</code> 移动到行头</li>
<li><code>^</code> 移动到本行的第一个不是blank的字符</li>
<li><code>$</code> 移动到行尾</li>
<li><code>g_</code> 移动到本行最后一个不是blank字符的位置</li>
<li><code>w</code> 光标移动到下一个单词的开头</li>
<li><code>e</code> 光标移动到下一个单词的结尾</li>
<li><code>f&lt;c&gt;</code> 光标移动到本行下一个为<c>的字符处</li>
</ul>
</li>
<li>跨行移动光标<ul>
<li><code>nG</code> 光标定位到第N行行首</li>
<li><code>gg</code> 光标定位到第一行的行首</li>
<li><code>G</code> 光标定位到最后一行的行首</li>
<li><code>H</code> 光标定位到最后一行的行首</li>
</ul>
</li>
</ul>
<h2 id="Vim的基础文本操作"><a href="#Vim的基础文本操作" class="headerlink" title="Vim的基础文本操作"></a>Vim的基础文本操作</h2><ul>
<li>删除<ul>
<li><code>d</code>就是删除的意思</li>
<li><code>dw</code> 删除一个单词</li>
<li><code>d&lt;n&gt;w</code> 删除<n>个单词</li>
<li><code>dd</code> 删除整行</li>
<li><code>&lt;n&gt;dd</code> 删除光标处开始的<n>行</li>
<li><code>d$</code> 删除光标到本行的借位</li>
<li><code>dH</code> 删除屏幕显示的第一行文本到光标所在</li>
<li><code>dG</code> 删除光标所在行到文本结束</li>
</ul>
</li>
<li>复制<ul>
<li><code>y</code>就是复制的意思</li>
<li><code>yw</code> 复制一个单词</li>
<li><code>yy</code> 复制整行</li>
</ul>
</li>
<li>粘贴<ul>
<li><code>p</code> 就是粘贴的意思，在光标后粘贴</li>
<li><code>P</code> 在光标前粘贴</li>
</ul>
</li>
<li>撤销<ul>
<li><code>u</code> 撤销刚才的操作</li>
<li><code>^r</code> 恢复撤销操作</li>
</ul>
</li>
<li>删除字符串操作和替换<ul>
<li><code>x</code> 删除光标当前所在的字符</li>
<li><code>r</code> 替换光标当前所在的字符</li>
</ul>
</li>
</ul>
<h1 id="neovim-LazyVim"><a href="#neovim-LazyVim" class="headerlink" title="neovim+LazyVim"></a>neovim+LazyVim</h1><h2 id="modal-editing"><a href="#modal-editing" class="headerlink" title="modal editing"></a>modal editing</h2><h3 id="从normal进入insert模式"><a href="#从normal进入insert模式" class="headerlink" title="从normal进入insert模式"></a>从normal进入insert模式</h3><ul>
<li><code>i</code>: 在当前光标左边插入字符</li>
<li><code>a</code>: 在当前光标右边插入字符</li>
<li><code>I</code>: 在当前光标所在行的行首插入字符</li>
<li><code>A</code>: 在当前光标所在行的行末插入字符</li>
<li><code>o</code>: 在当前行所在的下一行插入字符</li>
<li><code>O</code>: 在当前行所在的上一行插入字符</li>
</ul>
<h3 id="进入visual模式"><a href="#进入visual模式" class="headerlink" title="进入visual模式"></a>进入visual模式</h3><p>visual模式是为了一次性选中多行的</p>
<h3 id="command模式"><a href="#command模式" class="headerlink" title="command模式"></a>command模式</h3><p>按下冒号就进入了命令模式。在命令模式中，按下命令的开头字母之后，按<code>tab</code>会出现补全。当有多个补全候选的时候，继续按<code>tab</code>向下选择，<code>shift+tab</code>向上选择</p>
<h3 id="z模式"><a href="#z模式" class="headerlink" title="z模式"></a>z模式</h3><p>z模式本质上就是跳转模式的一个若干快捷键的集合。比如<code>zt</code>就是把当前光标所在行移动到屏幕顶部。<code>zb</code>就是把当前光标所在行移动到屏幕底部。<code>zz</code>是把当前光标所在行移动到屏幕中间。</p>
<h3 id="词间移动"><a href="#词间移动" class="headerlink" title="词间移动"></a>词间移动</h3><ul>
<li><code>e</code>: 移动到下一个单词的最后一个字母</li>
<li><code>w</code>: 移动到下一个单词的第一个字母</li>
<li><code>b</code>: 移动到前一个单词的第一个字母</li>
<li>以上三个指令都可以先带上数字，一次性跳过多个单词</li>
</ul>
]]></content>
      <categories>
        <category>basic_cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>LPNS-paper-reading</title>
    <url>/2025/07/21/LPNS-paper-reading/</url>
    <content><![CDATA[<h1 id="论文整理"><a href="#论文整理" class="headerlink" title="论文整理"></a>论文整理</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><ul>
<li>latency在一些情况下很重要,但是过往研究主要集中关注如何提高虚拟机的吞吐量,而没有重点关注延迟</li>
<li>LPNS关注的是本地存储,不考虑网络存储<ul>
<li>self-feedback control</li>
<li>flexible IO queue</li>
<li>command scheduling</li>
<li>scalable polling design</li>
<li>deterministic network calculus-based formalization method(这个是一个性能评估的算法)</li>
</ul>
</li>
<li>主要竞品: MDev-NVMe和SPDK</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>云服务器厂商提升他们的云服务器的IO吞吐量,并且还保证每个客户的带宽公平, 但是忽略了有的客户可能不需要很高的吞吐量,但是要保证他们的IO延迟不能过高</li>
<li>在现在的方案下,如果一块硬盘被多个客户机共享,那么可能延迟敏感的客户,在其它客户进行大量读写的时候,导致他自己的延迟陡增,不能满足他的需求<ul>
<li>原因: 现代SSD控制器在接收到大量IO请求的时候,是以轮转调度的方式来处理的,所以当其它客户大量发IO请求的时候,延迟敏感的客户就被拖下水了</li>
</ul>
</li>
<li>LPNS干了什么<ul>
<li>在传统的虚拟机和硬件之间夹进去了一个动态队列调度器</li>
<li>IO command调度器,保证延迟敏感客户不会被其它普通用户拖慢</li>
<li>提出通过deterministic network calcules的方法的方法来从理论上计算细腻话存储中延迟的可预测性,给出确定的延迟上界</li>
</ul>
</li>
<li>创新&#x2F;贡献<ul>
<li>提出使用确定性网络演算,来为延迟上界提供数学模型</li>
<li>LPNS的架构<ul>
<li>自适应反馈机制:根据多租户负载动态调整资源分配</li>
</ul>
</li>
<li>基于中介式透传<ul>
<li>云服务器厂商不需要更新硬件&#x2F;花钱</li>
</ul>
</li>
<li>实验结果确认有效果</li>
</ul>
</li>
</ul>
<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><h3 id="NVMe"><a href="#NVMe" class="headerlink" title="NVMe"></a>NVMe</h3><p>NVMe在接受IO请求的时候是怎么做的</p>
<p>HostOS构造NVMe指令,然后放到submission queue中,并告知NVMe控制器.NVMe控制器执行命令,把数据拷贝到DMA中,然后构造完成结果到completion queue中</p>
<h3 id="Local-NVMe-Storage-for-Clous-Services"><a href="#Local-NVMe-Storage-for-Clous-Services" class="headerlink" title="Local NVMe Storage for Clous Services"></a>Local NVMe Storage for Clous Services</h3><ul>
<li>网络存储(存储池)</li>
<li>存储在本机中(和CPU、内存在同一个物理机器中)</li>
</ul>
<ul>
<li>网络存储的问题<ul>
<li>对存储对读写性能会受到网络的影响(如其它的网络请求可能会影响存储的IO性能)</li>
<li>云服务器厂商还得购买专门的设备提供网络存储的服务</li>
<li>用户可能希望能够使用baremetal机来自定义,这种时候一般都一定是本地存储</li>
</ul>
</li>
</ul>
<h3 id="Deterministic-Network-Calculus"><a href="#Deterministic-Network-Calculus" class="headerlink" title="Deterministic Network Calculus"></a>Deterministic Network Calculus</h3><ul>
<li>本来是用来计算在最坏情况下网络通信延迟</li>
<li>重要的三个概念<ul>
<li>arrival curve: 输入的流量在任意时间窗口内的最大积累量</li>
<li>service curve: 系统在给定时间窗口内保证提供的最小服务量</li>
<li>virtual delay: 两个curve的最大水平距离</li>
</ul>
</li>
<li>针对NVMe进行的一些假设<ul>
<li>NVMe的处理性能稳定不变,除非在GC并且使用FIFO策略的时候</li>
<li>多租户情况下,需要吞吐量的用户使用最大的队列深度; 需要延迟敏感的租户队列深度为1</li>
</ul>
</li>
<li>三个概念转换到NVMe上<ul>
<li>arrival curve: 虚拟机的IOPS,决定SSD会受到的IO请求频率</li>
<li>service curve: SSD至少能够保证的IOPS</li>
<li>virtual delay: 关注的IO延迟</li>
</ul>
</li>
</ul>
<h2 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h2><ul>
<li>过去虚拟化方向,都只注重吞吐量,不注重延迟</li>
<li>K2针对延迟,但是吞吐量下降太多,而且不是针对虚拟化NVMe的</li>
</ul>
<h2 id="design-and-immplementation"><a href="#design-and-immplementation" class="headerlink" title="design and immplementation"></a>design and immplementation</h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><ul>
<li>基础要求<ul>
<li>延迟可预测(不高于设定值)</li>
<li>性能损失不能太多(5%),严格保持延迟要求</li>
<li>不同虚拟机的延迟在初始化的时候确定,运行时更改要经用户同意</li>
</ul>
</li>
<li>架构:<ul>
<li>有点类似“劫持”来自虚拟机的IO请求,然后根据要求来重新排队,确保延迟敏感的用户的请求始终能够尽快发送到NVMe上</li>
</ul>
</li>
<li>全虚拟化<ul>
<li>hypervisor直接把HWQ的寄存器映射到VM地址空间,通过IOMMU限制VM只能访问分配给它的HWQ,同时拦截危险命令.</li>
<li>对于虚拟机而言,它感觉就是在直接通过标准的NVME方式发IO命令,不用像VirtIO一样修改虚拟机的驱动</li>
</ul>
</li>
<li>自反馈的QoS控制<ul>
<li>在创建虚拟机的时候给这个虚拟机一个标签,判断这个虚拟机是否需要延迟敏感保证</li>
<li>在轮训线程中插入探针,定期收集各种数据指标,这些指标可以为调度器提供决策依据,来动态调度</li>
</ul>
</li>
<li>灵活可扩展到轮询<ul>
<li>可以用一个轮询线程轮询所有的延迟不敏感的虚拟机,并充分利用NVMe的性能</li>
<li>对所有延迟敏感的虚拟机都专开一个轮询线程,确保延迟</li>
<li>以上两种线程都根据运行时状态动态开启或关闭,需要的时候开启保证性能,不需要的时候关闭减少CPU负担</li>
</ul>
</li>
<li>硬件队列池<ul>
<li>1-1 HWQ: 用于延迟敏感虚拟机</li>
<li>1-N HWQ: 用于延迟不敏感虚拟机</li>
<li>全局队列调度器动态的吧1-1 HWQ和1-N HWQ分配给需要的虚拟机,保证延迟</li>
</ul>
</li>
<li>IO命令的控制<ul>
<li>通过控制(暂时不发放)部分IO请求,保证延迟敏感的请求能够一定在时间内完成</li>
<li>控制是根据deterministic network calculus的限制来调度的</li>
</ul>
</li>
</ul>
<h3 id="可扩展的IO队列处理"><a href="#可扩展的IO队列处理" class="headerlink" title="可扩展的IO队列处理"></a>可扩展的IO队列处理</h3><ul>
<li>过去的方法: 静态的队列,SSD暴露出来HWQ的数量直接限制了可以共享一块SSD的VM的数量</li>
<li>LPNS: 灵活的重映射,虽然总量仍然不可以超过HWQ的总量.</li>
<li>design: IO queue scheduler, 分时复用HWQ,把所有的HWQ放到HWQ Pool中<ul>
<li>1-1HWQ: 一个HWQ只绑定到一个Virtual Queue上,</li>
<li>1-NHWQ: 一个HWQ同时接受来自多个VQ的请求</li>
<li>在初始化LPNS的时候就必须要确定1-1HWQ和1-NHWQ的数量</li>
<li>1-1HWQ一般分给SVM,1-N就分给IVM</li>
</ul>
</li>
<li>调度算法&#x2F;策略<ul>
<li>输入:<ul>
<li>各VM的QoS目标</li>
<li>运行时的工作负载</li>
</ul>
</li>
<li>阶段:<ul>
<li>分层VQ权重计算: 文强诶所有VM的VQ动态分配权重</li>
<li>切换HWQ:高优先队列绑定到1-1HWQ上,剩下的绑定去1-NHWQ上</li>
</ul>
</li>
<li>权重的计算规则:<ul>
<li>SVM: 如果VQ为空,权重为0,否则为最大权重</li>
<li>IVM: 权重&#x3D;积压命令数, 负载更重的可以相对获得更高的优先级</li>
</ul>
</li>
<li>sleep直到下一次调度</li>
</ul>
</li>
<li>潜在问题: 当切换HWQ和VQ的绑定的时候,可能上一次VQ的请求并未被完成<ul>
<li>直接转发的问题: IO error</li>
<li>解决方法: seamless switching mechanism<ul>
<li>扩展虚拟nvme命令,增加一个VM的表示字段,这样的话HWQ就可以同时处理来自不同VM的VQ命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="IO命令限流机制"><a href="#IO命令限流机制" class="headerlink" title="IO命令限流机制"></a>IO命令限流机制</h3><p>通过deterministic network calculus的来解决多个虚拟设备竞争同一个SSD的问题,这样hypervisor就可以通过在不同的虚拟设备之间调度资源队列+对IO命令限流,来同时消除OS级别和设备级别的延迟干扰</p>
<ul>
<li><p>arrival curve:</p>
<ul>
<li>$\theta$: 延迟不敏感虚拟机比延迟敏感虚拟机IO命令数量多出来的倍数</li>
<li>$j$: 延迟不敏感虚拟机数量</li>
<li>$i$: 延迟敏感虚拟机数量</li>
<li>$p$: IOPS</li>
<li>$d$: 队列深度</li>
<li>$v &#x3D; p \cdot (j \cdot \theta + i)$: IO命令的提交频率</li>
<li>$b &#x3D; d \cdot (j \cdot \theta + i)$: 一次性还可以发送的命令的数量</li>
<li>到达曲线: $\alpha(t) &#x3D; v \cdot t + b$</li>
</ul>
</li>
<li><p>service curve:</p>
<ul>
<li>$R$: 硬件并行(读)写速率 (因为一般随机读读性能高于写,采用最低值,所以是写)</li>
<li>$L_h$: 完成一个IO请求的最低延迟</li>
<li>服务曲线$\beta(t) &#x3D; R \cdot t + L_h$</li>
</ul>
</li>
<li><p>Latency Upper bound</p>
<ul>
<li>公式: $d(t) &#x3D; inf {\tau &gt;&#x3D; 0 | \alpha(t) &lt;&#x3D; \beta(t + \tau)}$</li>
<li>$L_{max} &lt;&#x3D; \frac{b}{R} + L_h &#x3D; d \cdot \frac{(j \cdot \theta + i)}{R} + L_h$</li>
</ul>
</li>
<li><p>LPNS通过控制$\Omega &#x3D; j \cdot \theta + i$来控制可预测延迟表现</p>
</li>
<li><p>比较小的$\Omega$可以确保更加可控,但是吞吐量损失也较多</p>
</li>
<li><p>LPNS允许VM提前预设好租户定义的延迟目标,来调整$\Omega$参数</p>
</li>
</ul>
<h3 id="可预测延迟的IO处理"><a href="#可预测延迟的IO处理" class="headerlink" title="可预测延迟的IO处理"></a>可预测延迟的IO处理</h3><h4 id="SVM的处理"><a href="#SVM的处理" class="headerlink" title="SVM的处理"></a>SVM的处理</h4><ol>
<li>VM产生IO请求,LPNS的shadow IO queue会存储到SQ中</li>
<li>轮询线程立刻获取这个SQ的head,并且翻译DMA和LBA地址,并存放到1-1HWQ中,通过doorbell register告知硬件</li>
<li>硬件收到请求以后,获取数据,通过DMA把数据放到内存中,然后把完成消息放入HWQ的CQ中</li>
<li>轮询线程发现CQ有东西了,立刻把CQ添加到shadow queue的CQ中,并且向VM发送一条中断告知它数据读完了</li>
</ol>
<h4 id="IVM的处理"><a href="#IVM的处理" class="headerlink" title="IVM的处理"></a>IVM的处理</h4><p>当数据进入shadow queue,发送到HWQ之前,有可能会被轮询线程限制,以防止感染延迟敏感虚拟机的性能.</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>轮询的效率: 1个SVM,多个IVM的时候,LPNS可以充分利用测试设备的性能,并且比竞品有更好的可扩展性</li>
<li>性能损耗: 使用two-phase数组,一个phase被读并做计算,另一个phase用来写入IO数据. 没有锁. 可以忽略这点性能损耗</li>
<li>资源损耗: 如果不好好处理,那么数以万计的IO请求可能会消耗几百KB的空间<ul>
<li>分段检测:<ul>
<li>10ms做一个检测(远短于调度周期)</li>
<li>计算平均指令的延迟</li>
<li>获得周期的结果</li>
</ul>
</li>
<li>轮询线程可以动态被调整为空闲状态<ul>
<li>如果500ms没有IO,轮询线程转空闲</li>
<li>遇到IO,立刻激活轮询线程</li>
</ul>
</li>
</ul>
</li>
<li>不足与改进:<ul>
<li>要针对特定场景调优</li>
<li>当写性能远低于读性能的设备上时,吞吐量的牺牲较大</li>
</ul>
</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验主要有两个部分,一方面是比较与其它主流SSD虚拟化的性能差异; 另一方面就是比较QoS控制系统的优劣</p>
<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><ul>
<li>硬件的详细型号</li>
<li>软件的详细情况<ul>
<li>保证总的HWQ数量小于总的VQ数量,来模拟在资源短缺的场景下的环境</li>
</ul>
</li>
<li>负载: 使用FIO<ul>
<li>引擎使用libaio(非阻塞异步io),能够绕过内核缓冲区直接访问磁盘</li>
</ul>
</li>
</ul>
<h3 id="micro-benchmark"><a href="#micro-benchmark" class="headerlink" title="micro benchmark"></a>micro benchmark</h3><ul>
<li>1个SVM</li>
<li>多个IVM</li>
<li>依次测试LPNS, MDev-NVMe, SPDK with vhost-blk, virtio</li>
<li>SVM最轻量的负载</li>
<li>IVM负载刚开始和SVM一样,然后主线提高负载</li>
<li>整体上LPNS效果好,但是在PM1735上,因为读写性能不一致,所以IVM的吞吐率牺牲比较多</li>
</ul>
<h1 id="YouTube"><a href="#YouTube" class="headerlink" title="YouTube"></a>YouTube</h1><h2 id="background-1"><a href="#background-1" class="headerlink" title="background"></a>background</h2><ul>
<li>High-performance NVMe Storage<ul>
<li>Efficient and scalable interface designed for high-performance SSDs</li>
<li>up to 65535 pairs of I&#x2F;O queues, up to 65535 depth, enabling high-parallel I&#x2F;o processing</li>
<li>High-parallel SQ&#x2F;CQ interacation between the host and tghe SSD controller(with interrupt)</li>
<li>High throughtput and micro-second-level latency advantages over the traditional interfaces, such as sata</li>
</ul>
</li>
<li>two solutions for cloud instance storage resources<ul>
<li>using remote storage pools or dedicated storage servers<ul>
<li>disaggregated computing and Storgae resources</li>
<li>Efficient, scalable and portable</li>
<li>Related works: Reflex, LeapIO, Mellonox SNAP</li>
</ul>
</li>
<li>using the local storage resources from the SSDs on the native servers<ul>
<li>removing the additional bottleneck of latency performance incurred by the network</li>
<li>removing expensive costs on network devices of cloud infrastructures</li>
<li>more friendly to bare-metal cloud service tenents</li>
<li>related works: VFIO, VirtIO, SPDK, MDev-NVMe, VirtIO-fs, SR-IOV, FVM, BM-store</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="motivation-1"><a href="#motivation-1" class="headerlink" title="motivation"></a>motivation</h2><ul>
<li>limitation of the current storage virtulization<ul>
<li>only concentrating on high throughput, no efficient latency-predicatble QoS control</li>
<li>inaccurate perception of the imbalanced multi-tenant workloads with different QoS requirement</li>
<li>cannot bypass the device-sdie latency interference on the OS level</li>
</ul>
</li>
<li>device-side latency interference<ul>
<li>multiple VMs with virtulized NVMe storage sharing the same underlying NVMe SSDs</li>
<li>throughtput-intensive VMs complete for NVMe I&#x2F;O queue resources, congestion on SSD controller</li>
<li>latency degradation, unbounded latency, and the miss  of latency QoS (or SLA)</li>
</ul>
</li>
<li>typical case<ul>
<li>VM1 run light but latency-sensitive adata I&#x2F;O workloads (e.g. data query) with a 30 us SLA</li>
<li>VM2 run thourhgput-intensive data I&#x2F;O workloads without latency QoS requirement but arriving with burst</li>
</ul>
</li>
<li>further strudy in the device-side latency interference<ul>
<li>the state-of-the-art NVMe virtualization (SPDK, SR-IOV, MDev-NVMe) cannot eliminate the latency innterference</li>
<li>the more intensive the competitor’s workload is, the more severe latency interference happens</li>
<li>average latency on the NVMe controller grows from 62.5% to 93.0% of the total latency with the increasing IOPS of othe VM2 workload: the controller of unpredicatble NVMe SSD is bottleneck</li>
<li>in HW&#x2F;SW co-design virtualization, an accelerator card (smartNIC or FPGA) attacehs standard and unpredictable NVMe and use SR-IOV, cannot bypass the device-sidew latency interference</li>
</ul>
</li>
<li>Storage I&#x2F;O QoS researches (with or without virtualized device designs)<ul>
<li>High total throughput: SPDK, Spool, LeapIO, FVM, BM-Store2</li>
<li>Fair queueing control: FIOS, FLIN, MQFQ, D2FQ</li>
<li>latency control: differentiated storage services, autossd, K2</li>
</ul>
</li>
</ul>
<h2 id="design"><a href="#design" class="headerlink" title="design"></a>design</h2><ul>
<li>Scalable architecture<ul>
<li>Hybrid depolyment of host processes, containeres, VMs</li>
</ul>
</li>
<li>full virtualization<ul>
<li>each virtualized storage is a device with NVMe feature(&#x2F;dev&#x2F;nvmeXnY)</li>
</ul>
</li>
<li>self-feedback Qos control<ul>
<li>SVM: VM with latency-predictable QoS</li>
<li>IVM: VM without latency-predictable QoS</li>
</ul>
</li>
<li>flexible and scalable polling<ul>
<li>Accelerating VM I&#x2F;O processing</li>
<li>flexibly configure the number of threads</li>
<li>one thread can utilize the high throughput</li>
<li>one dedicated polling thread for each SVM</li>
</ul>
</li>
<li>scalable I&#x2F;O queue handling<ul>
<li>design a hardware queue pool in the kernel module to manage queue resources</li>
<li>flexibly allocate any number of the HWQs(&lt;the max number of NVMe SSD) into the Pool</li>
<li>An I&#x2F;O queue scheduler to manage the Time Division Multiplexing(TDM) of I&#x2F;O queues</li>
<li>1-1 HWQs (bound to 1 VQ) and 1-N HWQs (shared by multiple VQ)</li>
</ul>
</li>
<li>I&#x2F;O conmmand throttling with DNC<ul>
<li>overcom device-level latency interference from OS-level storage virtualization</li>
<li>the polling thread can monitor the workload and control the command distribution speed</li>
<li>LPNS Module can control the throttling IVM throughput as $\theta$ times of IOPS of SVM with the slowest submission rate</li>
<li>a deterministic queuing system with deterministic network calculus</li>
</ul>
</li>
<li>using the deterministic network calculus to modle NVMe virtulization<ul>
<li>Concentraing point: 4K block size random read and write, the device-level latency interference are caused by the congestion on the SSD controller</li>
<li>scenario: j iVMs co-running with i SVM, the IOPS of SVM is p and its command queue depth is d</li>
<li>arrive curve: $\alpha (t) &#x3D; v \cdot t + b &#x3D; (p \cdot (j \cdot \theta + i)) \cdot t + d \cdot(j \cdot \theta + i)$</li>
<li>service curve: $\beta (t) &#x3D; R \cdot t + L_h$</li>
<li>latency upper bound $L_{max} &lt;&#x3D; \frac{b}{R} + L_h &#x3D; \frac{d \cdot(j \cdot \theta + i)}{R} + L_h$</li>
</ul>
</li>
<li>for SVM <ul>
<li>using 1-1 HWQ</li>
<li>dedicated polling thread for better latency performance</li>
<li>no I&#x2F;O command throttling</li>
<li>no throughput sacrifice</li>
</ul>
</li>
<li>for IVM<ul>
<li>using the idle 1-1 HWQs and sharing 1-N HWQs</li>
<li>one polling thread for all IVMs, reducing overhead</li>
<li>dynamic I&#x2F;O command throttling according to DNC</li>
<li>smaller throughput sacrifice than previous works in K2</li>
</ul>
</li>
</ul>
<h2 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h2><ul>
<li>all the implementations of LPNS are included in a linux kernel source code</li>
<li>LPNS implementation is based on mediated pass-through<ul>
<li>cooperate by the vfio-0mdev support of linux kernel</li>
<li>a kernel module (nvme-mdev.ko) to provide virtualized storage with full NVMe</li>
<li>coexist and cooperate with the origianl nvme.ko module (the NVMe driver)</li>
<li>Admin and I&#x2F;O queue resource management (resource emulation and pass-through)</li>
<li>polling thread is resposible for performance detection, optimization and I&#x2F;O throttling</li>
<li>providing CONFIG_NVME_MDEV kconfig for cloud system maintainers</li>
</ul>
</li>
<li>LPNS works on the mainstream intel&#x2F;AMD CPUs and all commercial NVMe SSD</li>
</ul>
<h2 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h2><ul>
<li>hardware comfiguration</li>
<li>Micro benchmark (comparison with other storage virtualization)<ul>
<li>Flexible I&#x2F;O tester(FIO), 4K random read or write, using libaio and O_DIRECT</li>
<li>VirtIO, SPDK vhost-blk, MDev-NVMe on intel P5800X, MDev-NVMe and SR-IOV on samsung PM1735</li>
</ul>
</li>
<li>application benchmark<ul>
<li>webuser</li>
<li>ycsb</li>
</ul>
</li>
</ul>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><ul>
<li>latency predictability trade-off<ul>
<li>different NVMe SSD has different service curve</li>
<li>most NVMe SSDs has poorer random write performance thant read, wasting more total throughput than random read</li>
</ul>
</li>
<li>performance and resource overhead<ul>
<li>flexible and scalable polling to reduce CPU overhead</li>
<li>periodical workload and performance detection, saving kernel memory resoures</li>
</ul>
</li>
<li>LPNS: Scalable and Latency-Predicatble virtualization<ul>
<li>we analyze the device-level latency interference, and argu the signifigance of overcoming this interference from ths OS-level storage virtualization</li>
<li>we design LPNS, the first OS-level NVMe virtualization solution with latency-predictable QoS enhancement</li>
<li>we implement LPNS in the linux kernel without any further purchase of accelerator cards</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>SJTU</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssd</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
</search>
